diff --git a/.gitignore b/.gitignore
index b3300c5..18dac68 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,6 +3,3 @@ build/ksdk1.1/work
 setup.conf
 tools/scripts/warp.jlink.commands
 tools/scripts/glaux.jlink.commands
-settings.json
-vscode/
-./vscode
\ No newline at end of file
diff --git a/.vscode/settings.json b/.vscode/settings.json
deleted file mode 100644
index 3d6df41..0000000
--- a/.vscode/settings.json
+++ /dev/null
@@ -1,10 +0,0 @@
-{
-    "files.associations": {
-        "fsl_os_abstraction.h": "c",
-        "complex.h": "c",
-        "config.h": "c",
-        "fft.h": "c",
-        "warp.h": "c",
-        "devadc.h": "c"
-    }
-}
\ No newline at end of file
diff --git a/Makefile b/Makefile
index cd039af..193589c 100755
--- a/Makefile
+++ b/Makefile
@@ -12,22 +12,71 @@ warp:
 	cp src/boot/ksdk1.1.0/config.h					build/ksdk1.1/work/demos/Warp/src/
 	cp src/boot/ksdk1.1.0/boot.c					build/ksdk1.1/work/demos/Warp/src/
 	cp src/boot/ksdk1.1.0/errstrs*					build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/powermodes.c				build/ksdk1.1/work/demos/Warp/src/
 	cp src/boot/ksdk1.1.0/warp.h					build/ksdk1.1/work/demos/Warp/src/
 	cp src/boot/ksdk1.1.0/startup_MKL03Z4.S				build/ksdk1.1/work/platform/startup/MKL03Z4/gcc/startup_MKL03Z4.S
 	cp src/boot/ksdk1.1.0/gpio_pins.c				build/ksdk1.1/work/boards/Warp
 	cp src/boot/ksdk1.1.0/gpio_pins.h				build/ksdk1.1/work/boards/Warp
 	cp src/boot/ksdk1.1.0/config.h					build/ksdk1.1/work/boards/Warp
+	cp src/boot/ksdk1.1.0/glaux.h					build/ksdk1.1/work/boards/Warp
 	cp src/boot/ksdk1.1.0/CMakeLists-Warp.txt			build/ksdk1.1/work/demos/Warp/armgcc/Warp/CMakeLists.txt
-	cp src/boot/ksdk1.1.0/devSSD1331.*				build/ksdk1.1/work/demos/Warp/src/
-	cp src/boot/ksdk1.1.0/devADC.*					build/ksdk1.1/work/demos/Warp/src/
-	cp src/boot/ksdk1.1.0/fft.*						build/ksdk1.1/work/demos/Warp/src/
-
+	cp src/boot/ksdk1.1.0/devBMX055.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devADXL362.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devMMA8451Q.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devLPS25H.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devHDC1000.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devMAG3110.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devSI7021.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devL3GD20H.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devBME680.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devTCS34725.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devSI4705.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devCCS811.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devAMG8834.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devAS7262.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devAS7263.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devAS726x.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devRV8803C7.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devBGX.*					build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devISL23415.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devIS25xP.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devAT45DB.*				build/ksdk1.1/work/demos/Warp/src/
+	cp src/boot/ksdk1.1.0/devICE40.*				build/ksdk1.1/work/demos/Warp/src/
 	cd build/ksdk1.1/work/lib/ksdk_platform_lib/armgcc/KL03Z4 && ./clean.sh; ./build_release.sh
 	cd build/ksdk1.1/work/demos/Warp/armgcc/Warp && ./clean.sh; ./build_release.sh
 	@echo "\n\nNow, run\n\n\tmake load-warp\n\n"
 
+glaux:
+	mkdir -p build/ksdk1.1/work
+	mkdir -p build/ksdk1.1/work/boards/Glaux
+	mkdir -p build/ksdk1.1/work/demos/Glaux/src
+	mkdir -p build/ksdk1.1/work/demos/Glaux/armgcc/Glaux
+	cp -r tools/sdk/ksdk1.1.0/*					build/ksdk1.1/work
+	cp src/boot/ksdk1.1.0/SEGGER*					build/ksdk1.1/work/demos/Glaux/src/
+	cp src/boot/ksdk1.1.0/config.h					build/ksdk1.1/work/demos/Glaux/src/
+	cp src/boot/ksdk1.1.0/boot.c					build/ksdk1.1/work/demos/Glaux/src/
+	cp src/boot/ksdk1.1.0/errstrs*					build/ksdk1.1/work/demos/Glaux/src/
+	cp src/boot/ksdk1.1.0/powermodes.c				build/ksdk1.1/work/demos/Glaux/src/
+	cp src/boot/ksdk1.1.0/warp.h					build/ksdk1.1/work/demos/Glaux/src/
+	cp src/boot/ksdk1.1.0/startup_MKL03Z4.S				build/ksdk1.1/work/platform/startup/MKL03Z4/gcc/startup_MKL03Z4.S
+	cp src/boot/ksdk1.1.0/gpio_pins.c				build/ksdk1.1/work/boards/Glaux
+	cp src/boot/ksdk1.1.0/gpio_pins.h				build/ksdk1.1/work/boards/Glaux
+	cp src/boot/ksdk1.1.0/config.h					build/ksdk1.1/work/boards/Glaux
+	cp src/boot/ksdk1.1.0/glaux.h					build/ksdk1.1/work/boards/Glaux
+	cp src/boot/ksdk1.1.0/CMakeLists-Glaux.txt			build/ksdk1.1/work/demos/Glaux/armgcc/Glaux/CMakeLists.txt
+	cp src/boot/ksdk1.1.0/devBME680.*				build/ksdk1.1/work/demos/Glaux/src/
+	cp src/boot/ksdk1.1.0/devIS25xP.*				build/ksdk1.1/work/demos/Glaux/src/
+	cp src/boot/ksdk1.1.0/devRV8803C7.*				build/ksdk1.1/work/demos/Glaux/src/
+	cp src/boot/ksdk1.1.0/devBME680.*				build/ksdk1.1/work/demos/Glaux/src/
+	cd build/ksdk1.1/work/lib/ksdk_platform_lib/armgcc/KL03Z4 && ./clean.sh; ./build_release.sh
+	cd build/ksdk1.1/work/demos/Glaux/armgcc/Glaux && ./clean.sh; ./build_release.sh
+	@echo "\n\nNow, run\n\n\tmake load-glaux\n\n"
+
 load-warp:
 	$(JLINKPATH) -device MKL03Z32XXX4 -if SWD -speed 10000 -CommanderScript tools/scripts/warp.jlink.commands
 
+load-glaux:
+	$(JLINKPATH) -device MKL03Z32XXX4 -if SWD -speed 10000 -CommanderScript tools/scripts/glaux.jlink.commands
+
 clean:
 	rm -rf build/ksdk1.1/work
diff --git a/README.md b/README.md
index e39a96e..2d33bbf 100644
--- a/README.md
+++ b/README.md
@@ -1,31 +1,10 @@
-# Music Visualiser for 4B25 CW5
-## Finn Ashley, fwa20, Gonville & Caius College
-
-This reposistory contains an implementation for a music visualiser, operating on the NXP FRDM KL03 evaluation board equipped with an SSD1331 OLED screen and microphone input to the ADC. On boot up, the hardware will configure itself before dynamically splitting up incoming audio into 6 frequency bins online. These will be shown as an evolving chart on the OLED screen, where each bar will correspond to different frequency depending on the sampling frequency specified in the firmware.
-
-The codebase is built off of the Warp firmware, which this repository is forked off of. This program was severly memory constrained due to the need to store sampled audio values and perform intensive calculations on them, and as such the Warp firmware had to be stripped down signficantly - code for un-needed components on the freedom board was removed, and the more 'investigative' warp capabilities were removed in order to capitalise on their space. Relative to previous courseworks, the following files have been altered or added:
-
-* `boot.c` has been significantly simplifed, with the main loop now repeatedly calling a small set of functions that lay out the steps needed to perform frequecny decomposition.
-* `fft.c` has been added. This contains the simplest implementation of the FFT, which is therefore low memory. Credit goes to https://github.com/brendanashworth/fft-small for this, which was added to this project as allowed under their MIT license. Extra code was added to this in order to deal with the complex output of a real FFT.
-* `devADC.c` has been added. This contains functions to set up the board's ADC and start taking readings continously. This assumes an analogue audio input is connected to pin PTB1 on the FRDM board.
-* `devSSD1331.c` has been altered. Code to draw a green square has been removed, and replaced with a number of methods that are utilised to draw a frequency chart on the OLED screen. This includes code to dynamically scale the bars in order to keep then interesting.
-
-## Running
-
-Having been built off of Warp, getting the code running is relatively simple. Simply clone the reposistory with `git clone https://github.com/Finn-Ashley/Warp-firmware/` and navigate into it with a terminal.
-
-Subsequently call `make warp` and copy the resulting file at `build/ksdk1.1/work/demos/Warp/armgcc/Warp/release/Warp.srec` onto your board using the appropriate JLINK tools. This process is extensively detailed below, such that only a brief explanation has been provided here.
-
-
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
 # Baseline firmware for the [Warp](https://github.com/physical-computation/Warp-hardware) family of hardware platforms
 This is the firmware for the [Warp hardware](https://github.com/physical-computation/Warp-hardware) and its publicly available and unpublished derivatives. This firmware also runs on the Freescale/NXP FRDM KL03 evaluation board which we use for teaching at the University of Cambridge. When running on platforms other than Warp, only the sensors available in the corresponding hardware platform are accessible.
 
 **Prerequisites:** You need an arm cross-compiler such as `arm-none-eabi-gcc` installed as well as a working `cmake` (installed, e.g., via `apt-get` on Linux or via [MacPorts](https://www.macports.org) on macOS). On Ubuntu, the package you need is `gcc-arm-none-eabi`. You will also need an installed copy of the SEGGER [JLink commander](https://www.segger.com/downloads/jlink/), `JlinkExe`, which is available for Linux, macOS, and Windows (here are direct links for downloading it for [macOS](https://www.segger.com/downloads/jlink/JLink_MacOSX.pkg), and [Linux tgz 64-bit](https://www.segger.com/downloads/jlink/JLink_Linux_x86_64.tgz)).
 
 ## 1.  Compiling the Warp firmware
-First, edit [setup.conf](setup.conf) to set the variable `ARMGCC_DIR` and `JLINKPATH`. If your `arm-none-eabi-gcc` is in `/usr/local/bin/arm-none-eabi-gcc`, then you want to set  `ARMGCC_DIR` to `/usr/local`. In the following, this `README.md` will refer to the top of the repository as `$TREEROOT`.
+First, edit [setup.conf](setup.conf) to set the variable `ARMGCC_DIR` and `JLINKPATH`. If your `arm-none-eabi-gcc` is in `/usr/local/bin/arm-none-eabi-gcc`, then you want to set  `ARMGCC_DIR` to `/usr/local`. In the following, this `README.md` will refer to the top of the repository as `$TREEROOT`. On some platforms, you might need to also, in addition, set the `ARMGCC_DIR` environment variable in your shell (using `setenv` or `export` as appropriate), to point to the same path as you set in [setup.conf](setup.conf).
 
 Second, edit [`tools/scripts/glaux.jlink.commands`](tools/scripts/glaux.jlink.commands) and [`tools/scripts/warp.jlink.commands`](tools/scripts/warp.jlink.commands) to replace `<full-path-to-warp-firmware>` with the full path to your Warp firmware directory.
 
diff --git a/build/ksdk1.1/build.sh b/build/ksdk1.1/build.sh
old mode 100644
new mode 100755
index a6e6f7e..667c1e6
--- a/build/ksdk1.1/build.sh
+++ b/build/ksdk1.1/build.sh
@@ -32,8 +32,6 @@
 	cp ../../src/boot/ksdk1.1.0/devRV8803C7.*			work/demos/Warp/src/
 	cp ../../src/boot/ksdk1.1.0/devISL23415.*			work/demos/Warp/src/
 	cp ../../src/boot/ksdk1.1.0/devMAX11300.*			work/demos/Warp/src/
-    cp ../../src/boot/ksdk1.1.0/devSSD1331.*			work/demos/Warp/src/
-
 	cp ../../src/boot/ksdk1.1.0/CMakeLists.txt			work/demos/Warp/armgcc/Warp/
 	cp ../../src/boot/ksdk1.1.0/startup_MKL03Z4.S			work/platform/startup/MKL03Z4/gcc/startup_MKL03Z4.S
 	cp ../../src/boot/ksdk1.1.0/gpio_pins.c				work/boards/Warp
@@ -42,3 +40,4 @@
 	cd work/lib/ksdk_platform_lib/armgcc/KL03Z4 && ./clean.sh; ./build_release.sh
 	cd ../../../../demos/Warp/armgcc/Warp && ./clean.sh; ./build_release.sh
 	echo "\n\nNow, run\n\n\t/Applications/SEGGER/JLink/JLinkExe -device MKL03Z32XXX4 -if SWD -speed 100000 -CommanderScript ../../tools/scripts/jlink.commands\n\n"
+
diff --git a/examples/adc_low_power.c b/examples/adc_low_power.c
deleted file mode 100644
index 120e37e..0000000
--- a/examples/adc_low_power.c
+++ /dev/null
@@ -1,447 +0,0 @@
-/*
- * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * o Redistributions of source code must retain the above copyright notice, this list
- *   of conditions and the following disclaimer.
- *
- * o Redistributions in binary form must reproduce the above copyright notice, this
- *   list of conditions and the following disclaimer in the documentation and/or
- *   other materials provided with the distribution.
- *
- * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
- *   contributors may be used to endorse or promote products derived from this
- *   software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
- 
-///////////////////////////////////////////////////////////////////////////////
-// Includes
-///////////////////////////////////////////////////////////////////////////////
-
-// Standard C Included Files
-#include <stdlib.h>
-#include <assert.h>
-#include <string.h>
-#include <stdio.h>
-
-// SDK Included Files
-#include "adc_low_power.h"
-#include "fsl_smc_hal.h"
-#include "fsl_pmc_hal.h"
-#include "fsl_adc16_driver.h"
-#include "board.h"
-
-///////////////////////////////////////////////////////////////////////////////
-// Definitions
-///////////////////////////////////////////////////////////////////////////////
-
-#define ADC_0                   (0U)
-#define CHANNEL_0               (0U)
-#define LED_ON                  (0U)
-#define LED_OFF                 (1U)
-/*!
- * @brief These values are used to get the temperature. DO NOT MODIFY
- * The method used in this demo to calculate temperature of chip is mapped to
- * Temperature Sensor for the HCS08 Microcontroller Family document (Document Number: AN3031)
- */
-#define ADCR_VDD                (65535U)    /*! Maximum value when use 16b resolution */
-#define V_BG                    (1000U)     /*! BANDGAP voltage in mV (trim to 1.0V) */
-#define V_TEMP25                (716U)      /*! Typical VTEMP25 in mV */
-#define M                       (1620U)     /*! Typical slope: (mV x 1000)/oC */
-#define STANDARD_TEMP           (25)
-
-#define UPPER_VALUE_LIMIT       (1U)        /*! This value/10 is going to be added to current Temp to set the upper boundary*/
-#define LOWER_VALUE_LIMIT       (1U)        /*! This Value/10 is going to be subtracted from current Temp to set the lower boundary*/
-#define UPDATE_BOUNDARIES_TIME  (20U)       /*! This value indicates the number of cycles needed to update boundaries. To know the Time it will take, multiply this value times LPTMR_COMPARE_VALUE*/
-#define kAdcChannelTemperature  (26U)       /*! ADC channel of temperature sensor */
-#define kAdcChannelBandgap      (27U)       /*! ADC channel of BANDGAP */
-
-///////////////////////////////////////////////////////////////////////////////
-// Prototypes
-///////////////////////////////////////////////////////////////////////////////
-
-extern void init_trigger_source(uint32_t instance);
-
-///////////////////////////////////////////////////////////////////////////////
-// Variables
-///////////////////////////////////////////////////////////////////////////////
-
-static uint32_t adcValue = 0;               /*! ADC value */
-static uint32_t adcrTemp25 = 0;             /*! Calibrated ADCR_TEMP25 */
-static uint32_t adcr100m = 0;
-volatile bool conversionCompleted = false;  /*! Conversion is completed Flag */
-const uint32_t gSimBaseAddr[] = SIM_BASE_ADDRS;
-static smc_power_mode_config_t smcConfig;
-
-///////////////////////////////////////////////////////////////////////////////
-// Code
-///////////////////////////////////////////////////////////////////////////////
-
-/* ADC Interrupt Handler */
-void ADC1IRQHandler(void)
-{
-    // Get current ADC value
-    adcValue = ADC_TEST_GetConvValueRAWInt (ADC_0, CHANNEL_0);
-    // Set conversionCompleted flag. This prevents an wrong conversion in main function
-    conversionCompleted = true;
-}
-
-/*!
- * @brief enter in VLPS mode
- */
-void config_vlps(void)
-{
-    smc_power_mode_protection_config_t smcProtConfig;
-
-    // set to allow entering specific modes
-    smcProtConfig.vlpProt = true;
-    SMC_HAL_SetProtection(SMC_BASE, &smcProtConfig);
-
-    // set power mode to specific Run mode 
-#if FSL_FEATURE_SMC_HAS_LPWUI
-    smcConfig.lpwuiOption = false;
-#endif
-#if FSL_FEATURE_SMC_HAS_PORPO
-    smcConfig.porOption = false;
-#endif
-    smcConfig.powerModeName = kPowerModeVlps;
-}
-
-/*!
- * Parameters calibration: VDD and ADCR_TEMP25
- */
-void calibrateParams(void)
-{
-#if FSL_FEATURE_ADC16_HAS_CALIBRATION
-    adc16_calibration_param_t adcCalibraitionParam;
-#endif
-    adc16_user_config_t adcUserConfig;
-    adc16_chn_config_t adcChnConfig;
-    uint32_t bandgapValue = 0;  /*! ADC value of BANDGAP */
-    uint32_t vdd = 0;           /*! VDD in mV */
-
-#if FSL_FEATURE_ADC16_HAS_CALIBRATION
-    // Auto calibration
-    ADC16_DRV_GetAutoCalibrationParam(ADC_0, &adcCalibraitionParam);
-    ADC16_DRV_SetCalibrationParam(ADC_0, &adcCalibraitionParam);
-#endif
-
-    // Enable BANDGAP reference voltage
-    PMC_HAL_SetBandgapBufferCmd(PMC_BASE, true);
-
-    // Initialization ADC for
-    // 16bit resolution, interrupt mode, hw trigger disabled.
-    // normal convert speed, VREFH/L as reference,
-    // disable continuous convert mode.
-    ADC16_DRV_StructInitUserConfigDefault(&adcUserConfig);
-    adcUserConfig.resolutionMode = kAdcResolutionBitOf16;
-    adcUserConfig.continuousConvEnable = false;
-    adcUserConfig.clkSrcMode = kAdcClkSrcOfAsynClk;
-    ADC16_DRV_Init(ADC_0, &adcUserConfig);
-
-#if FSL_FEATURE_ADC16_HAS_HW_AVERAGE
-    ADC16_DRV_EnableHwAverage(ADC_0, kAdcHwAverageCountOf32);
-#endif // FSL_FEATURE_ADC16_HAS_HW_AVERAGE
-
-    adcChnConfig.chnNum = kAdcChannelBandgap;
-    adcChnConfig.diffEnable = false;
-    adcChnConfig.intEnable = false;
-    adcChnConfig.chnMux = kAdcChnMuxOfA;
-    ADC16_DRV_ConfigConvChn(ADC_0, CHANNEL_0, &adcChnConfig);
-
-    // Wait for the conversion to be done
-    ADC16_DRV_WaitConvDone(ADC_0, CHANNEL_0);
-
-    // Get current ADC BANDGAP value
-    bandgapValue = ADC16_DRV_GetConvValueRAW(ADC_0, CHANNEL_0);
-    bandgapValue = ADC16_DRV_ConvRAWData(bandgapValue, false, adcUserConfig.resolutionMode);
-
-    // ADC stop conversion
-    ADC16_DRV_PauseConv(ADC_0, CHANNEL_0);
-
-    // Get VDD value measured in mV: VDD = (ADCR_VDD x V_BG) / ADCR_BG
-    vdd = ADCR_VDD * V_BG / bandgapValue;
-    // Calibrate ADCR_TEMP25: ADCR_TEMP25 = ADCR_VDD x V_TEMP25 / VDD
-    adcrTemp25 = ADCR_VDD * V_TEMP25 / vdd;
-    // ADCR_100M = ADCR_VDD x M x 100 / VDD
-    adcr100m = (ADCR_VDD * M) / (vdd * 10);
-
-#if FSL_FEATURE_ADC16_HAS_HW_AVERAGE
-    ADC16_DRV_DisableHwAverage(ADC_0);
-#endif // FSL_FEATURE_ADC16_HAS_HW_AVERAGE
-
-    // Disable BANDGAP reference voltage
-    PMC_HAL_SetBandgapBufferCmd(PMC_BASE, false);
-}
-/*!
- * @brief Initialize the ADCx for HW trigger.
- *
- * @param instance The ADC instance number
- */
-static int32_t init_adc(uint32_t instance)
-{
-#if FSL_FEATURE_ADC16_HAS_CALIBRATION
-    adc16_calibration_param_t adcCalibraitionParam;
-#endif
-    adc16_user_config_t adcUserConfig;
-    adc16_chn_config_t adcChnConfig;
-
-#if FSL_FEATURE_ADC16_HAS_CALIBRATION
-    // Auto calibration
-    ADC16_DRV_GetAutoCalibrationParam(instance, &adcCalibraitionParam);
-    ADC16_DRV_SetCalibrationParam(instance, &adcCalibraitionParam);
-#endif
-
-    // Initialization ADC for
-    // 16bit resolution, interrupt mode, hw trigger enabled.
-    // normal convert speed, VREFH/L as reference,
-    // disable continuous convert mode.
-    ADC16_DRV_StructInitUserConfigDefault(&adcUserConfig);
-    adcUserConfig.intEnable = true;
-    adcUserConfig.resolutionMode = kAdcResolutionBitOf16;
-    adcUserConfig.hwTriggerEnable = true;
-    adcUserConfig.continuousConvEnable = false;
-    adcUserConfig.clkSrcMode = kAdcClkSrcOfAsynClk;
-    ADC16_DRV_Init(instance, &adcUserConfig);
-
-    // Install Callback function into ISR
-    ADC_TEST_InstallCallback(instance, CHANNEL_0, ADC1IRQHandler);
-
-    adcChnConfig.chnNum = kAdcChannelTemperature;
-    adcChnConfig.diffEnable = false;
-    adcChnConfig.intEnable = true;
-    adcChnConfig.chnMux = kAdcChnMuxOfA;
-
-    // Configure channel0
-    ADC16_DRV_ConfigConvChn(instance, CHANNEL_0, &adcChnConfig);
-
-    return 0;
-}
-
-/* Calculate the current temperature */
-int32_t GetCurrentTempValue(void)
-{
-    int32_t currentTemperature = 0;
-
-    // Temperature = 25 - (ADCR_T - ADCR_TEMP25) * 100 / ADCR_100M
-    currentTemperature = (int32_t)(STANDARD_TEMP - ((int32_t)adcValue - (int32_t)adcrTemp25) * 100 / (int32_t)adcr100m);
-
-    return currentTemperature;
-}
-
-/* Calculate the average temperature and set boundaries */
-lowPowerAdcBoundaries_t TempSensorCalibration(uint32_t updateBoundariesCounter,
-                                                     int32_t *tempArray)
-{
-    uint32_t avgTemp = 0;
-    lowPowerAdcBoundaries_t boundaries;
-
-    for(int i = 0; i < updateBoundariesCounter; i++)
-    {
-        avgTemp += tempArray[i];
-    }
-    // Get average temperature
-    avgTemp /= updateBoundariesCounter;
-
-    // Set upper boundary
-    boundaries.upperBoundary = avgTemp + UPPER_VALUE_LIMIT;
-
-    // Set lower boundary
-    boundaries.lowerBoundary = avgTemp - LOWER_VALUE_LIMIT;
-
-    return boundaries;
-}
-
-/*!
- * @brief main function
- */
-int main(void)
-{
-    int32_t currentTemperature = 0;
-    uint32_t updateBoundariesCounter = 0;
-    int32_t tempArray[UPDATE_BOUNDARIES_TIME * 2];
-    lowPowerAdcBoundaries_t boundaries;
-
-    // Init hardware
-    hardware_init();
-
-    // Call this function to initialize the console UART.  This function
-    // enables the use of STDIO functions (printf, scanf, etc.)
-    dbg_uart_init();
-
-    // Initialize GPIO pins
-    GPIO_DRV_Init(accelIntPins, ledPins);
-
-    // Configure SMC module to entry to vlps mode
-    config_vlps();
-
-    // Calibrate param Temperature sensor
-    calibrateParams();
-
-    // Initialize ADC
-    if (init_adc(ADC_0))
-    {
-        printf("Failed to do the ADC init\n");
-        return -1;
-    }
-
-    // Show the currentTemperature value
-    printf("\r\n ADC LOW POWER DEMO \r\n\n\n");
-    printf("\r\nThe Low Power ADC project is designed to work with the Tower System or in a stand alone setting. \n\n");
-    printf("\r 1. Set your target board in a place where the temperature is constant.  \n");
-#ifndef FREEDOM
-    printf("\r 2. Wait until the green LED light turns on. \n");
-#else
-    printf("\r 2. Wait until the white LED light turns on. \n");
-#endif
-    printf("\r 3. Increment or decrement the temperature to see the changes. \n");
-
-    // setup the HW trigger source
-    init_trigger_source(ADC_0);
-
-    // Warm up microcontroller and allow to set first boundaries
-    while(updateBoundariesCounter < (UPDATE_BOUNDARIES_TIME * 2))
-    {
-        while(!conversionCompleted);
-        currentTemperature = GetCurrentTempValue();
-        tempArray[updateBoundariesCounter] = currentTemperature;
-        updateBoundariesCounter++;
-        conversionCompleted = false;
-    }
-
-    // Temp Sensor Calibration 
-    boundaries = TempSensorCalibration(updateBoundariesCounter, tempArray);
-    updateBoundariesCounter = 0;
-
-#ifndef FREEDOM
-    // Green LED is turned on indicating calibration is done
-    GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_GREEN, LED_ON);
-#endif
-    
-    // Wait for user input before beginning demo
-    printf("\n\n\rEnter any character to begin...\n\n\r");
-    getchar();
-    
-    ///////////////////////////////////////////////////////////////////////////
-    // Main application loop
-    //
-    // NOTE: UART prints in this loop may not work. 
-    // 
-    // This demo performs ADC conversions and then moves to a low power mode. 
-    // By default, the startup code of this demo enters PEE mode at the 
-    // maximum operating frequency of the device. However, after exiting the
-    // low power mode, the device will no longer be operating at the maximum
-    // operating frequency of the device in PEE mode.  It will be in PBE mode
-    // operating at the frequency of the external crystal.  Therefore, UART 
-    // prints may not work inside this loop.  
-    ///////////////////////////////////////////////////////////////////////////
-    for(;;)
-    {
-        // Prevents the use of wrong values
-        while(!conversionCompleted)
-        {}
-
-        // Get current Temperature Value
-        currentTemperature = GetCurrentTempValue();
-
-        // Store temperature values that are going to be use to calculate average temperature
-        tempArray[updateBoundariesCounter] = currentTemperature;
-
-#ifdef FREEDOM
-#if !defined(BOARD_GPIO_LED_BLUE)
-        // Select which LED is going to be turned on and off
-        if(currentTemperature > boundaries.upperBoundary)
-        {
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_RED, LED_ON);
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_GREEN, LED_OFF);
-        }
-        else if(currentTemperature < boundaries.lowerBoundary)
-        {
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_RED, LED_OFF);
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_GREEN, LED_ON);
-        }
-        else
-        {
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_RED, LED_OFF);
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_GREEN, LED_OFF);
-        }
-#else
-        // Select which LED is going to be turned on and off
-        if(currentTemperature > boundaries.upperBoundary)
-        {
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_RED, LED_ON);
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_BLUE, LED_OFF);
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_GREEN, LED_OFF);
-        }
-        else if(currentTemperature < boundaries.lowerBoundary)
-        {
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_RED, LED_OFF);
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_BLUE, LED_ON);
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_GREEN, LED_OFF);
-        }
-        else
-        {
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_RED, LED_ON);
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_BLUE, LED_ON);
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_GREEN, LED_ON);
-        }
-#endif
-#else
-
-        // Show how fast is each cycle
-        GPIO_DRV_TogglePinOutput(BOARD_GPIO_LED_GREEN);
-
-        // Select which LED is going to be turned on and off
-        if(currentTemperature > boundaries.upperBoundary)
-        {
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_RED, LED_ON);
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_BLUE, LED_OFF);
-        }
-        else if(currentTemperature < boundaries.lowerBoundary)
-        {
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_RED, LED_OFF);
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_BLUE, LED_ON);
-        }
-        else
-        {
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_RED, LED_OFF);
-            GPIO_DRV_WritePinOutput(BOARD_GPIO_LED_BLUE, LED_OFF);
-        }
-#endif
-
-        // Call update function
-        if(updateBoundariesCounter >= (UPDATE_BOUNDARIES_TIME))
-        {
-            boundaries = TempSensorCalibration(updateBoundariesCounter, tempArray);
-            updateBoundariesCounter = 0;
-        }
-        else
-        {
-            updateBoundariesCounter++;
-        }
-
-        // Clear conversionCompleted flag
-        conversionCompleted = false;
-
-        // Entry to Low Power Mode
-        // Once this mode exited, it will no longer be in PEE mode (assuming
-        // the device entered this mode from PEE).  Therefore, the UART 
-        // baud rate will not be correct because the device's operating 
-        // frequency will be different from the startup of the demo. 
-        SMC_HAL_SetMode(SMC_BASE, &smcConfig);
-    }
-}
diff --git a/examples/adc_low_power.h b/examples/adc_low_power.h
deleted file mode 100644
index a681bcd..0000000
--- a/examples/adc_low_power.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.                           *
- * All rights reserved.                                                        *
- *                                                                             *
- * Redistribution and use in source and binary forms, with or without modifi-  *
- * cation, are permitted provided that the following conditions are met:       *
- *                                                                             *
- * o Redistributions of source code must retain the above copyright notice,    *
- * this list of conditions and the following disclaimer.                       *
- *                                                                             *
- * o Redistributions in binary form must reproduce the above copyright notice, *
- * this list of conditions and the following disclaimer in the documentation   *
- * and/or other materials provided with the distribution.                      *
- *                                                                             *
- * o Neither the name of Freescale Semiconductor, Inc. nor the names of its    *
- *   contributors may be used to endorse or promote products derived from this *
- *   software without specific prior written permission.                       *
- *                                                                             *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" *
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   *
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   *
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         *
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        *
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    *
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     *
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     *
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  *
- * POSSIBILITY OF SUCH DAMAGE.                                                 *
- *                                                                             *
- *******************************************************************************/
-
-
-#ifndef __LOWPOWER_ADC_H__
-#define __LOWPOWER_ADC_H__
-
-///////////////////////////////////////////////////////////////////////////////
-// Includes
-///////////////////////////////////////////////////////////////////////////////
-
-#include <stdint.h>
-
-///////////////////////////////////////////////////////////////////////////////
-// Definitions
-///////////////////////////////////////////////////////////////////////////////
-
-/*!
-* @brief Boundaries struct
-*/
-typedef struct lowPowerAdcBoundaries
-{
-    int32_t upperBoundary;
-    int32_t lowerBoundary;
-} lowPowerAdcBoundaries_t;
-
-/*!
- * @brief Low Power Timer Interrupt handler. Clear LPT Compare flag.
- */
-void LowPowerTimerIRQHandler(void);
-
-/*!
- * @brief ADC Interrupt handler. Get current ADC value and set conversionCompleted flag.
- */
-void ADC1IRQHandler(void);
-
-/*!
- * @brief Initialize Low Power Timer. Use 1 kHz LPO with no preescaler and enable LPT interrupt.
- */
-void InitLowPowerTmr(void);
-
-/*!
- * @brief Calculate current temperature.
- *
- * @return uint32_t Returns current temperature.
- */
-int32_t GetCurrentTempValue(void);
-
-/*!
- * @brief Calculate current temperature.
- *
- * @param updateBoundariesCounter Indicate number of values into tempArray.
- *
- * @param tempArray Store temperature value.
- *
- * @return lowPowerAdcBoundaries_t Returns upper and lower temperature boundaries.
- */
-lowPowerAdcBoundaries_t TempSensorCalibration(uint32_t updateBoundariesCounter,
-                                                     int32_t *tempArray);
-
-/*!
- * @brief User-defined function to install callback.
- */
-void ADC_TEST_InstallCallback(uint32_t instance, uint32_t chnGroup, void (*callbackFunc)(void) );
-
-/*!
- * @brief User-defined function to read conversion value in ADC ISR. 
- */
-uint16_t ADC_TEST_GetConvValueRAWInt(uint32_t instance, uint32_t chnGroup);
-
-#endif // __LOWPOWER_ADC_H__
diff --git a/examples/fsl_adc_irq.c b/examples/fsl_adc_irq.c
deleted file mode 100644
index 8170d6e..0000000
--- a/examples/fsl_adc_irq.c
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (c) 2013 -2014, Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * o Redistributions of source code must retain the above copyright notice, this list
- *   of conditions and the following disclaimer.
- *
- * o Redistributions in binary form must reproduce the above copyright notice, this
- *   list of conditions and the following disclaimer in the documentation and/or
- *   other materials provided with the distribution.
- *
- * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
- *   contributors may be used to endorse or promote products derived from this
- *   software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-///////////////////////////////////////////////////////////////////////////////
-// Includes
-///////////////////////////////////////////////////////////////////////////////
-
-// Standard C Included Files
-#include <stdint.h>
-#include <stdbool.h>
-// SDK Included Files
-#include "fsl_adc16_driver.h"
-
-///////////////////////////////////////////////////////////////////////////////
-// Global Variables
-///////////////////////////////////////////////////////////////////////////////
-
-// Define array to keep run-time callback set by application
-void (* volatile g_AdcTestCallback[HW_ADC_INSTANCE_COUNT][HW_ADC_SC1n_COUNT])(void);
-volatile uint16_t g_AdcValueInt[HW_ADC_INSTANCE_COUNT][HW_ADC_SC1n_COUNT];
-
-///////////////////////////////////////////////////////////////////////////////
-// Code
-///////////////////////////////////////////////////////////////////////////////
-
-/* User-defined function to install callback. */
-void ADC_TEST_InstallCallback(uint32_t instance, uint32_t chnGroup, void (*callbackFunc)(void) )
-{
-    g_AdcTestCallback[instance][chnGroup] = callbackFunc;
-}
-
-/* User-defined function to read conversion value in ADC ISR. */
-uint16_t ADC_TEST_GetConvValueRAWInt(uint32_t instance, uint32_t chnGroup)
-{
-    return g_AdcValueInt[instance][chnGroup];
-}
-
-/* User-defined ADC ISR. */
-static void ADC16_TEST_IRQHandler(uint32_t instance)
-{
-    uint32_t chnGroup;
-    for (chnGroup = 0U; chnGroup < HW_ADC_SC1n_COUNT; chnGroup++)
-    {
-        if (   ADC16_DRV_GetChnFlag(instance, chnGroup, kAdcChnConvCompleteFlag) )
-        {
-            g_AdcValueInt[instance][chnGroup] = ADC16_DRV_GetConvValueRAW(instance, chnGroup);
-            if ( g_AdcTestCallback[instance][chnGroup] )
-            {
-                (void)(*(g_AdcTestCallback[instance][chnGroup]))();
-            }
-        }
-    }
-}
-
-///////////////////////////////////////////////////////////////////////////////
-// IRQ Handlers
-///////////////////////////////////////////////////////////////////////////////
-
-/* ADC IRQ handler that would cover the same name's APIs in startup code */
-void ADC0_IRQHandler(void)
-{
-    // Add user-defined ISR for ADC0
-    ADC16_TEST_IRQHandler(0U);
-}
-
-#if (HW_ADC_INSTANCE_COUNT > 1U)
-void ADC1_IRQHandler(void)
-{
-    // Add user-defined ISR for ADC1
-    ADC16_TEST_IRQHandler(1U);
-}
-#endif
-
-#if (HW_ADC_INSTANCE_COUNT > 2U)
-void ADC2_IRQHandler(void)
-{
-    // Add user-defined ISR for ADC2. */
-    ADC16_TEST_IRQHandler(2U);
-}
-#endif
-
-#if (HW_ADC_INSTANCE_COUNT > 3U)
-void ADC3_IRQHandler(void)
-{
-    // Add user-defined ISR for ADC3
-    ADC16_TEST_IRQHandler(3U);
-}
-#endif
diff --git a/examples/lptmr_trigger.c b/examples/lptmr_trigger.c
deleted file mode 100644
index 614ee7f..0000000
--- a/examples/lptmr_trigger.c
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (c) 2014, Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * o Redistributions of source code must retain the above copyright notice, this list
- *   of conditions and the following disclaimer.
- *
- * o Redistributions in binary form must reproduce the above copyright notice, this
- *   list of conditions and the following disclaimer in the documentation and/or
- *   other materials provided with the distribution.
- *
- * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
- *   contributors may be used to endorse or promote products derived from this
- *   software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-///////////////////////////////////////////////////////////////////////////////
-// Includes
-///////////////////////////////////////////////////////////////////////////////
-
-// SDK Included Files
-#include "fsl_lptmr_driver.h"
-#include "fsl_gpio_hal.h"
-#include "fsl_port_hal.h"
-#include "fsl_sim_hal.h"
-
-///////////////////////////////////////////////////////////////////////////////
-// Definitions
-///////////////////////////////////////////////////////////////////////////////
-
-#define LPTMR_COMPARE_VALUE     (500000U)   // Low Power Timer interrupt time in microseconds
-
-///////////////////////////////////////////////////////////////////////////////
-// Variables
-///////////////////////////////////////////////////////////////////////////////
-
-extern const uint32_t gSimBaseAddr[];
-static lptmr_state_t gLPTMRState;
-
-///////////////////////////////////////////////////////////////////////////////
-//  Code
-///////////////////////////////////////////////////////////////////////////////
-
-/* enable the trigger source of LPTimer */
-void init_trigger_source(uint32_t adcInstance)
-{
-    lptmr_user_config_t lptmrUserConfig =
-    {
-        .timerMode = kLptmrTimerModeTimeCounter,
-        .freeRunningEnable = false,
-        .prescalerEnable = false, // bypass perscaler
-        .prescalerClockSource = kClockLptmrSrcLpoClk, // use LPO, 1KHz
-        .isInterruptEnabled = false
-    };
-
-    // Init LPTimer driver
-    LPTMR_DRV_Init(0, &lptmrUserConfig, &gLPTMRState);
-
-    // Set the LPTimer period
-    LPTMR_DRV_SetTimerPeriodUs(0, LPTMR_COMPARE_VALUE);
-
-    // Start the LPTimer
-    LPTMR_DRV_Start(0);
-
-    // Configure SIM for ADC hw trigger source selection
-    SIM_HAL_SetAdcAlternativeTriggerCmd(gSimBaseAddr[0], adcInstance, true);
-    SIM_HAL_SetAdcPreTriggerMode(gSimBaseAddr[0], adcInstance, kSimAdcPretrgselA);
-    SIM_HAL_SetAdcTriggerMode(gSimBaseAddr[0], adcInstance, kSimAdcTrgSelLptimer);
-}
-
-/* disable the trigger source */
-void deinit_trigger_source(uint32_t adcInstance)
-{
-    LPTMR_DRV_Stop(0);
-    LPTMR_DRV_Deinit(0);
-}
diff --git a/setup.conf b/setup.conf
index 406abf3..865c827 100644
--- a/setup.conf
+++ b/setup.conf
@@ -1,2 +1,2 @@
 JLINKPATH	=	<full path to JLink binary>
-ARMGCC_DIR	=	/usr
+ARMGCC_DIR	=	<full path to directory>
diff --git a/src/boot/ksdk1.1.0/CMakeLists-Glaux.txt b/src/boot/ksdk1.1.0/CMakeLists-Glaux.txt
new file mode 100755
index 0000000..37b137f
--- /dev/null
+++ b/src/boot/ksdk1.1.0/CMakeLists-Glaux.txt
@@ -0,0 +1,133 @@
+INCLUDE(CMakeForceCompiler)
+
+# CROSS COMPILER SETTING
+SET(CMAKE_SYSTEM_NAME Generic)
+CMAKE_MINIMUM_REQUIRED (VERSION 2.6)
+
+# THE VERSION NUMBER
+SET (Tutorial_VERSION_MAJOR 1)
+SET (Tutorial_VERSION_MINOR 0)
+
+# ENABLE ASM
+ENABLE_LANGUAGE(ASM)
+
+SET(CMAKE_STATIC_LIBRARY_PREFIX)
+SET(CMAKE_STATIC_LIBRARY_SUFFIX)
+
+SET(CMAKE_EXECUTABLE_LIBRARY_PREFIX)
+SET(CMAKE_EXECUTABLE_LIBRARY_SUFFIX)
+
+
+# CURRENT DIRECTORY
+SET(ProjDirPath ${CMAKE_CURRENT_SOURCE_DIR})
+
+# DEBUG LINK FILE
+set(CMAKE_EXE_LINKER_FLAGS_DEBUG "${CMAKE_EXE_LINKER_FLAGS_DEBUG} -T${ProjDirPath}/../../../../platform/linker/MKL03Z4/gcc/MKL03Z32xxx4_flash.ld  -static")
+
+# RELEASE LINK FILE
+set(CMAKE_EXE_LINKER_FLAGS_RELEASE "${CMAKE_EXE_LINKER_FLAGS_RELEASE} -T${ProjDirPath}/../../../../platform/linker/MKL03Z4/gcc/MKL03Z32xxx4_flash.ld  -static")
+
+# DEBUG ASM FLAGS
+SET(CMAKE_ASM_FLAGS_DEBUG "${CMAKE_ASM_FLAGS_DEBUG} -g  -mcpu=cortex-m0plus  -mthumb  -Wall  -fno-common  -ffunction-sections  -fdata-sections  -ffreestanding  -fno-builtin  -Os  -mapcs  -std=gnu99")
+
+# DEBUG C FLAGS
+SET(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -g  -mcpu=cortex-m0plus  -mthumb  -MMD  -MP  -Wall  -fno-common  -ffunction-sections  -fdata-sections  -ffreestanding  -fno-builtin  -Os  -mapcs  -std=gnu99 -fshort-enums")
+
+# DEBUG LD FLAGS
+SET(CMAKE_EXE_LINKER_FLAGS_DEBUG "${CMAKE_EXE_LINKER_FLAGS_DEBUG} -g  --specs=nano.specs  -lm  -Wall  -fno-common  -ffunction-sections  -fdata-sections  -ffreestanding  -fno-builtin  -Os  -mthumb  -mapcs  -Xlinker --gc-sections  -Xlinker -static  -Xlinker -z  -Xlinker muldefs  -Xlinker --defsym=__stack_size__=0x300  -Xlinker --defsym=__heap_size__=0x0")
+
+# RELEASE ASM FLAGS
+SET(CMAKE_ASM_FLAGS_RELEASE "${CMAKE_ASM_FLAGS_RELEASE} -mcpu=cortex-m0plus  -mthumb  -Wall  -fno-common  -ffunction-sections  -fdata-sections  -ffreestanding  -fno-builtin  -Os  -mapcs  -std=gnu99")
+
+# RELEASE C FLAGS
+SET(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -mcpu=cortex-m0plus  -mthumb  -MMD  -MP  -Wall  -fno-common  -ffunction-sections  -fdata-sections  -ffreestanding  -fno-builtin  -Os  -mapcs  -std=gnu99 -fshort-enums")
+
+# RELEASE LD FLAGS
+SET(CMAKE_EXE_LINKER_FLAGS_RELEASE "${CMAKE_EXE_LINKER_FLAGS_RELEASE} --specs=nano.specs  -lm  -Wall  -fno-common  -ffunction-sections  -fdata-sections  -ffreestanding  -fno-builtin  -Os  -mthumb  -mapcs  -Xlinker --gc-sections  -Xlinker -static  -Xlinker -z  -Xlinker muldefs  -Xlinker --defsym=__stack_size__=0x300  -Xlinker --defsym=__heap_size__=0x0")
+
+# ASM MACRO
+SET(CMAKE_ASM_FLAGS_DEBUG "${CMAKE_ASM_FLAGS_DEBUG}  -DDEBUG")
+
+# C MACRO
+SET(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG}  -DDEBUG")
+SET(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG}  -DCPU_MKL03Z32VFK4")
+SET(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG}  -DFRDM_KL03Z48M")
+SET(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG}  -DFREEDOM")
+SET(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG}  -DWARP_BUILD_ENABLE_GLAUX_VARIANT")
+SET(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE}  -DNDEBUG")
+SET(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE}  -DCPU_MKL03Z32VFK4")
+SET(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE}  -DFRDM_KL03Z48M")
+SET(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE}  -DFREEDOM")
+SET(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE}  -DWARP_BUILD_ENABLE_GLAUX_VARIANT")
+
+# CXX MACRO
+
+# INCLUDE_DIRECTORIES
+IF(CMAKE_BUILD_TYPE MATCHES Debug)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../platform/utilities/inc)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../platform/osa/inc)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../platform/CMSIS/Include)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../platform/CMSIS/Include/device)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../platform/startup/MKL03Z4)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../platform/hal/inc)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../platform/drivers/inc)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../platform/system/inc)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../boards/Glaux)
+ELSEIF(CMAKE_BUILD_TYPE MATCHES Release)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../platform/utilities/inc)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../platform/osa/inc)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../platform/CMSIS/Include)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../platform/CMSIS/Include/device)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../platform/startup/MKL03Z4)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../platform/hal/inc)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../platform/drivers/inc)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../platform/system/inc)
+    INCLUDE_DIRECTORIES(${ProjDirPath}/../../../../boards/Glaux)
+ENDIF()
+
+# ADD_EXECUTABLE
+ADD_EXECUTABLE(Glaux 
+    "${ProjDirPath}/../../../../platform/utilities/src/fsl_misc_utilities.c"
+    "${ProjDirPath}/../../../../platform/startup/MKL03Z4/gcc/startup_MKL03Z4.S"
+    "${ProjDirPath}/../../src/boot.c"
+    "${ProjDirPath}/../../src/errstrsEN.c"
+    "${ProjDirPath}/../../src/powermodes.c"
+    "${ProjDirPath}/../../src/devIS25xP.c"
+    "${ProjDirPath}/../../src/devBME680.c"
+    "${ProjDirPath}/../../src/devRV8803C7.c"
+    "${ProjDirPath}/../../src/SEGGER_RTT.c"
+    "${ProjDirPath}/../../src/SEGGER_RTT_printf.c"
+    "${ProjDirPath}/../../../../platform/drivers/src/i2c/fsl_i2c_irq.c"
+    "${ProjDirPath}/../../../../platform/drivers/src/spi/fsl_spi_irq.c"
+    "${ProjDirPath}/../../../../platform/drivers/src/lpuart/fsl_lpuart_irq.c"
+    "${ProjDirPath}/../../../../platform/startup/MKL03Z4/system_MKL03Z4.c"
+    "${ProjDirPath}/../../../../platform/startup/startup.c"
+    "${ProjDirPath}/../../../../platform/startup/startup.h"
+    "${ProjDirPath}/../../../../boards/Glaux/gpio_pins.c"
+    "${ProjDirPath}/../../../../boards/Glaux/gpio_pins.h"
+)
+SET_TARGET_PROPERTIES(Glaux PROPERTIES OUTPUT_NAME "Glaux.elf")
+
+TARGET_LINK_LIBRARIES(Glaux -Wl,--start-group)
+# LIBRARIES
+IF(CMAKE_BUILD_TYPE MATCHES Debug)
+    TARGET_LINK_LIBRARIES(Glaux ${ProjDirPath}/../../../../lib/ksdk_platform_lib/armgcc/KL03Z4/debug/libksdk_platform.a)
+ELSEIF(CMAKE_BUILD_TYPE MATCHES Release)
+    TARGET_LINK_LIBRARIES(Glaux ${ProjDirPath}/../../../../lib/ksdk_platform_lib/armgcc/KL03Z4/release/libksdk_platform.a)
+ENDIF()
+
+# SYSTEM LIBRARIES
+TARGET_LINK_LIBRARIES(Glaux m)
+TARGET_LINK_LIBRARIES(Glaux c)
+TARGET_LINK_LIBRARIES(Glaux gcc)
+TARGET_LINK_LIBRARIES(Glaux nosys)
+TARGET_LINK_LIBRARIES(Glaux -Wl,--end-group)
+
+# MAP FILE
+SET(CMAKE_EXE_LINKER_FLAGS_DEBUG "${CMAKE_EXE_LINKER_FLAGS_DEBUG}  -Xlinker -Map=debug/Glaux.map")
+SET(CMAKE_EXE_LINKER_FLAGS_RELEASE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}  -Xlinker -Map=release/Glaux.map")
+
+# BIN AND HEX
+ADD_CUSTOM_COMMAND(TARGET Glaux POST_BUILD COMMAND ${CMAKE_OBJCOPY} -Oihex ${EXECUTABLE_OUTPUT_PATH}/Glaux.elf ${EXECUTABLE_OUTPUT_PATH}/Glaux.hex)
+ADD_CUSTOM_COMMAND(TARGET Glaux POST_BUILD COMMAND ${CMAKE_OBJCOPY} -Obinary ${EXECUTABLE_OUTPUT_PATH}/Glaux.elf ${EXECUTABLE_OUTPUT_PATH}/Glaux.bin)
+ADD_CUSTOM_COMMAND(TARGET Glaux POST_BUILD COMMAND ${CMAKE_OBJCOPY} -Osrec ${EXECUTABLE_OUTPUT_PATH}/Glaux.elf ${EXECUTABLE_OUTPUT_PATH}/Glaux.srec)
diff --git a/src/boot/ksdk1.1.0/CMakeLists-Warp.txt b/src/boot/ksdk1.1.0/CMakeLists-Warp.txt
index d2db1ac..4107e57 100755
--- a/src/boot/ksdk1.1.0/CMakeLists-Warp.txt
+++ b/src/boot/ksdk1.1.0/CMakeLists-Warp.txt
@@ -89,11 +89,31 @@ ADD_EXECUTABLE(Warp
     "${ProjDirPath}/../../../../platform/startup/MKL03Z4/gcc/startup_MKL03Z4.S"
     "${ProjDirPath}/../../src/boot.c"
     "${ProjDirPath}/../../src/errstrsEN.c"
+    "${ProjDirPath}/../../src/powermodes.c"
+    "${ProjDirPath}/../../src/devBMX055.c"
+    "${ProjDirPath}/../../src/devADXL362.c"
+    "${ProjDirPath}/../../src/devIS25xP.c"
+    "${ProjDirPath}/../../src/devISL23415.c"
+    "${ProjDirPath}/../../src/devAT45DB.c"
+#    "${ProjDirPath}/../../src/devICE40.c"
+    "${ProjDirPath}/../../src/devMMA8451Q.c"
+    "${ProjDirPath}/../../src/devLPS25H.c"
+    "${ProjDirPath}/../../src/devHDC1000.c"
+    "${ProjDirPath}/../../src/devMAG3110.c"
+    "${ProjDirPath}/../../src/devSI7021.c"
+    "${ProjDirPath}/../../src/devL3GD20H.c"
+    "${ProjDirPath}/../../src/devBME680.c"
+    "${ProjDirPath}/../../src/devTCS34725.c"
+    "${ProjDirPath}/../../src/devSI4705.c"
+    "${ProjDirPath}/../../src/devCCS811.c"
+    "${ProjDirPath}/../../src/devAMG8834.c"
+    "${ProjDirPath}/../../src/devRV8803C7.c"
+    "${ProjDirPath}/../../src/devBGX.c"
+    "${ProjDirPath}/../../src/devAS7262.c"
+    "${ProjDirPath}/../../src/devAS7263.c"
+#   "${ProjDirPath}/../../src/devMAX11300.c
     "${ProjDirPath}/../../src/SEGGER_RTT.c"
     "${ProjDirPath}/../../src/SEGGER_RTT_printf.c"
-    "${ProjDirPath}/../../src/devSSD1331.c"
-    "${ProjDirPath}/../../src/devADC.c"
-    "${ProjDirPath}/../../src/fft.c"
     "${ProjDirPath}/../../../../platform/drivers/src/i2c/fsl_i2c_irq.c"
     "${ProjDirPath}/../../../../platform/drivers/src/spi/fsl_spi_irq.c"
     "${ProjDirPath}/../../../../platform/drivers/src/lpuart/fsl_lpuart_irq.c"
@@ -102,7 +122,6 @@ ADD_EXECUTABLE(Warp
     "${ProjDirPath}/../../../../platform/startup/startup.h"
     "${ProjDirPath}/../../../../boards/Warp/gpio_pins.c"
     "${ProjDirPath}/../../../../boards/Warp/gpio_pins.h"
-    
 )
 SET_TARGET_PROPERTIES(Warp PROPERTIES OUTPUT_NAME "Warp.elf")
 
@@ -128,4 +147,4 @@ SET(CMAKE_EXE_LINKER_FLAGS_RELEASE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}  -Xlinker
 # BIN AND HEX
 ADD_CUSTOM_COMMAND(TARGET Warp POST_BUILD COMMAND ${CMAKE_OBJCOPY} -Oihex ${EXECUTABLE_OUTPUT_PATH}/Warp.elf ${EXECUTABLE_OUTPUT_PATH}/Warp.hex)
 ADD_CUSTOM_COMMAND(TARGET Warp POST_BUILD COMMAND ${CMAKE_OBJCOPY} -Obinary ${EXECUTABLE_OUTPUT_PATH}/Warp.elf ${EXECUTABLE_OUTPUT_PATH}/Warp.bin)
-ADD_CUSTOM_COMMAND(TARGET Warp POST_BUILD COMMAND ${CMAKE_OBJCOPY} -Osrec ${EXECUTABLE_OUTPUT_PATH}/Warp.elf ${EXECUTABLE_OUTPUT_PATH}/Warp.srec)
\ No newline at end of file
+ADD_CUSTOM_COMMAND(TARGET Warp POST_BUILD COMMAND ${CMAKE_OBJCOPY} -Osrec ${EXECUTABLE_OUTPUT_PATH}/Warp.elf ${EXECUTABLE_OUTPUT_PATH}/Warp.srec)
diff --git a/src/boot/ksdk1.1.0/boot.c b/src/boot/ksdk1.1.0/boot.c
index 398bae1..1789941 100755
--- a/src/boot/ksdk1.1.0/boot.c
+++ b/src/boot/ksdk1.1.0/boot.c
@@ -40,7 +40,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stdarg.h>
-#include <complex.h>
 
 /*
  *	config.h needs to come first
@@ -57,35 +56,427 @@
 #include "fsl_mcglite_hal.h"
 #include "fsl_port_hal.h"
 #include "fsl_lpuart_driver.h"
+#include "glaux.h"
 #include "warp.h"
-
 #include "errstrs.h"
 #include "gpio_pins.h"
 #include "SEGGER_RTT.h"
 
-#include "fft.h"
-#include "devSSD1331.h"
-#include "devADC.h"
 
+#define							kWarpConstantStringI2cFailure		"\rI2C failed, reg 0x%02x, code %d\n"
+#define							kWarpConstantStringErrorInvalidVoltage	"\rInvalid supply voltage [%d] mV!"
+#define							kWarpConstantStringErrorSanity		"\rSanity check failed!"
+
+
+#if (WARP_BUILD_ENABLE_DEVADXL362)
+	#include "devADXL362.h"
+	volatile WarpSPIDeviceState			deviceADXL362State;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVIS25xP)
+	#include "devIS25xP.h"
+	volatile WarpSPIDeviceState			deviceIS25xPState;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVISL23415)
+	#include "devISL23415.h"
+	volatile WarpSPIDeviceState			deviceISL23415State;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVAT45DB)
+	#include "devAT45DB.h"
+	volatile WarpSPIDeviceState			deviceAT45DBState;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVICE40)
+	#include "devICE40.h"
+	volatile WarpSPIDeviceState			deviceICE40State;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVBMX055)
+	#include "devBMX055.h"
+	volatile WarpI2CDeviceState			deviceBMX055accelState;
+	volatile WarpI2CDeviceState			deviceBMX055gyroState;
+	volatile WarpI2CDeviceState			deviceBMX055magState;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVMMA8451Q)
+	#include "devMMA8451Q.h"
+	volatile WarpI2CDeviceState			deviceMMA8451QState;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVLPS25H)
+	#include "devLPS25H.h"
+	volatile WarpI2CDeviceState			deviceLPS25HState;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVHDC1000)
+	#include "devHDC1000.h"
+	volatile WarpI2CDeviceState			deviceHDC1000State;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVMAG3110)
+	#include "devMAG3110.h"
+	volatile WarpI2CDeviceState			deviceMAG3110State;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVSI7021)
+	#include "devSI7021.h"
+	volatile WarpI2CDeviceState			deviceSI7021State;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVL3GD20H)
+	#include "devL3GD20H.h"
+	volatile WarpI2CDeviceState			deviceL3GD20HState;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVBME680)
+	#include "devBME680.h"
+	volatile WarpI2CDeviceState			deviceBME680State;
+	volatile uint8_t				deviceBME680CalibrationValues[kWarpSizesBME680CalibrationValuesCount];
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVTCS34725)
+	#include "devTCS34725.h"
+	volatile WarpI2CDeviceState			deviceTCS34725State;
+#endif
 
-volatile WarpSPIDeviceState			deviceSSD1331State;
+#if (WARP_BUILD_ENABLE_DEVSI4705)
+	#include "devSI4705.h"
+	volatile WarpI2CDeviceState			deviceSI4705State;
+#endif
 
+#if (WARP_BUILD_ENABLE_DEVCCS811)
+	#include "devCCS811.h"
+	olatile WarpI2CDeviceState			deviceCCS811State;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVAMG8834)
+	#include "devAMG8834.h"
+	volatile WarpI2CDeviceState			deviceAMG8834State;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVAS7262)
+	#include "devAS7262.h"
+	volatile WarpI2CDeviceState			deviceAS7262State;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVAS7263)
+	#include "devAS7263.h"
+	volatile WarpI2CDeviceState			deviceAS7263State;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVRV8803C7)
+	#include "devRV8803C7.h"
+	volatile WarpI2CDeviceState			deviceRV8803C7State;
+#endif
+
+#if (WARP_BUILD_ENABLE_DEVBGX)
+	#include "devBGX.h"
+	volatile WarpUARTDeviceState			deviceBGXState;
+#endif
+
+
+volatile i2c_master_state_t				i2cMasterState;
 volatile spi_master_state_t				spiMasterState;
 volatile spi_master_user_config_t			spiUserConfig;
+volatile lpuart_user_config_t				lpuartUserConfig;
+volatile lpuart_state_t					lpuartState;
 
-volatile bool						gWarpBooted				= false;
 
+volatile bool						gWarpBooted				= false;
+volatile uint32_t					gWarpI2cBaudRateKbps			= kWarpDefaultI2cBaudRateKbps;
+volatile uint32_t					gWarpUartBaudRateBps			= kWarpDefaultUartBaudRateBps;
+volatile uint32_t					gWarpSpiBaudRateKbps			= kWarpDefaultSpiBaudRateKbps;
+volatile uint32_t					gWarpSleeptimeSeconds			= kWarpDefaultSleeptimeSeconds;
+volatile WarpModeMask					gWarpMode				= kWarpModeDisableAdcOnSleep;
+volatile uint32_t					gWarpI2cTimeoutMilliseconds		= kWarpDefaultI2cTimeoutMilliseconds;
+volatile uint32_t					gWarpSpiTimeoutMicroseconds		= kWarpDefaultSpiTimeoutMicroseconds;
+volatile uint32_t					gWarpUartTimeoutMilliseconds		= kWarpDefaultUartTimeoutMilliseconds;
+volatile uint32_t					gWarpMenuPrintDelayMilliseconds		= kWarpDefaultMenuPrintDelayMilliseconds;
+volatile uint32_t					gWarpSupplySettlingDelayMilliseconds	= kWarpDefaultSupplySettlingDelayMilliseconds;
+volatile uint16_t					gWarpCurrentSupplyVoltage		= kWarpDefaultSupplyVoltageMillivolts;
+char							gWarpPrintBuffer[kWarpDefaultPrintBufferSizeBytes];
 
 /*
  *	Since only one SPI transaction is ongoing at a time in our implementation
  */
 uint8_t							gWarpSpiCommonSourceBuffer[kWarpMemoryCommonSpiBufferBytes];
 uint8_t							gWarpSpiCommonSinkBuffer[kWarpMemoryCommonSpiBufferBytes];
-volatile uint32_t					gWarpSpiTimeoutMicroseconds		= kWarpDefaultSpiTimeoutMicroseconds;
-volatile uint32_t					gWarpSpiBaudRateKbps			= kWarpDefaultSpiBaudRateKbps;
-char							gWarpPrintBuffer[kWarpDefaultPrintBufferSizeBytes];
 
+static void						sleepUntilReset(void);
 static void						lowPowerPinStates(void);
+static void						disableTPS62740(void);
+static void						enableTPS62740(uint16_t voltageMillivolts);
+static void						setTPS62740CommonControlLines(uint16_t voltageMillivolts);
+static void						dumpProcessorState(void);
+static void						repeatRegisterReadForDeviceAndAddress(WarpSensorDevice warpSensorDevice, uint8_t baseAddress,
+								bool autoIncrement, int chunkReadsPerAddress, bool chatty,
+								int spinDelay, int repetitionsPerAddress, uint16_t sssupplyMillivolts,
+								uint16_t adaptiveSssupplyMaxMillivolts, uint8_t referenceByte);
+static int						char2int(int character);
+static void						activateAllLowPowerSensorModes(bool verbose);
+static void						powerupAllSensors(void);
+static uint8_t						readHexByte(void);
+static int						read4digits(void);
+static void						printAllSensors(bool printHeadersAndCalibration, bool hexModeFlag, int menuDelayBetweenEachRun, bool loopForever);
+
+/*
+ *	TODO: change the following to take byte arrays
+ */
+WarpStatus						writeByteToI2cDeviceRegister(uint8_t i2cAddress, bool sendCommandByte, uint8_t commandByte, bool sendPayloadByte, uint8_t payloadByte);
+WarpStatus						writeBytesToSpi(uint8_t *  payloadBytes, int payloadLength);
+
+
+void							warpLowPowerSecondsSleep(uint32_t sleepSeconds, bool forceAllPinsIntoLowPowerState);
+
+
+
+/*
+ *	Derived from KSDK power_manager_demo.c BEGIN>>>
+ */
+clock_manager_error_code_t clockManagerCallbackRoutine(clock_notify_struct_t *  notify, void *  callbackData);
+
+/*
+ *	static clock callback table.
+ */
+clock_manager_callback_user_config_t		clockManagerCallbackUserlevelStructure =
+									{
+										.callback	= clockManagerCallbackRoutine,
+										.callbackType	= kClockManagerCallbackBeforeAfter,
+										.callbackData	= NULL
+									};
+
+static clock_manager_callback_user_config_t *	clockCallbackTable[] =
+									{
+										&clockManagerCallbackUserlevelStructure
+									};
+
+clock_manager_error_code_t
+clockManagerCallbackRoutine(clock_notify_struct_t *  notify, void *  callbackData)
+{
+	clock_manager_error_code_t result = kClockManagerSuccess;
+
+	switch (notify->notifyType)
+	{
+		case kClockManagerNotifyBefore:
+			break;
+		case kClockManagerNotifyRecover:
+		case kClockManagerNotifyAfter:
+			break;
+		default:
+			result = kClockManagerError;
+		break;
+	}
+
+	return result;
+}
+
+
+/*
+ *	Override the RTC IRQ handler
+ */
+void
+RTC_IRQHandler(void)
+{
+	if (RTC_DRV_IsAlarmPending(0))
+	{
+		RTC_DRV_SetAlarmIntCmd(0, false);
+	}
+}
+
+/*
+ *	Override the RTC Second IRQ handler
+ */
+void
+RTC_Seconds_IRQHandler(void)
+{
+	gWarpSleeptimeSeconds++;
+}
+
+/*
+ *	LLW_IRQHandler override. Since FRDM_KL03Z48M is not defined,
+ *	according to power_manager_demo.c, what we need is LLW_IRQHandler.
+ *	However, elsewhere in the power_manager_demo.c, the code assumes
+ *	FRDM_KL03Z48M _is_ defined (e.g., we need to use LLWU_IRQn, not
+ *	LLW_IRQn). Looking through the code base, we see in
+ *
+ *		ksdk1.1.0/platform/startup/MKL03Z4/gcc/startup_MKL03Z4.S
+ *
+ *	that the startup initialization assembly requires LLWU_IRQHandler,
+ *	not LLW_IRQHandler. See power_manager_demo.c, circa line 216, if
+ *	you want to find out more about this dicsussion.
+ */
+void
+LLWU_IRQHandler(void)
+{
+	/*
+	 *	BOARD_* defines are defined in warp.h
+	 */
+	LLWU_HAL_ClearExternalPinWakeupFlag(LLWU_BASE, (llwu_wakeup_pin_t)BOARD_SW_LLWU_EXT_PIN);
+}
+
+/*
+ *	IRQ handler for the interrupt from RTC, which we wire up
+ *	to PTA0/IRQ0/LLWU_P7 in Glaux. BOARD_SW_LLWU_IRQ_HANDLER
+ *	is a synonym for PORTA_IRQHandler.
+ */
+void
+BOARD_SW_LLWU_IRQ_HANDLER(void)
+{
+	/*
+	 *	BOARD_* defines are defined in warp.h
+	 */
+	PORT_HAL_ClearPortIntFlag(BOARD_SW_LLWU_BASE);
+}
+
+/*
+ *	Power manager user callback
+ */
+power_manager_error_code_t
+callback0(power_manager_notify_struct_t *  notify, power_manager_callback_data_t *  dataPtr)
+{
+	WarpPowerManagerCallbackStructure *		callbackUserData = (WarpPowerManagerCallbackStructure *) dataPtr;
+	power_manager_error_code_t			status = kPowerManagerError;
+
+	switch (notify->notifyType)
+	{
+		case kPowerManagerNotifyBefore:
+			status = kPowerManagerSuccess;
+			break;
+		case kPowerManagerNotifyAfter:
+			status = kPowerManagerSuccess;
+			break;
+		default:
+			callbackUserData->errorCount++;
+			break;
+	}
+
+	return status;
+}
+/*
+ *	Derived from KSDK power_manager_demo.c <<END
+ */
+
+
+
+void
+sleepUntilReset(void)
+{
+	while (1)
+	{
+		#if (WARP_BUILD_ENABLE_DEVSI4705)
+			GPIO_DRV_SetPinOutput(kWarpPinSI4705_nRST);
+		#endif
+
+		warpLowPowerSecondsSleep(1, false /* forceAllPinsIntoLowPowerState */);
+
+		#if (WARP_BUILD_ENABLE_DEVSI4705)
+			GPIO_DRV_ClearPinOutput(kWarpPinSI4705_nRST);
+		#endif
+
+		warpLowPowerSecondsSleep(60, true /* forceAllPinsIntoLowPowerState */);
+	}
+}
+
+
+void
+enableLPUARTpins(void)
+{
+	/*
+	 *	Enable UART CLOCK
+	 */
+	CLOCK_SYS_EnableLpuartClock(0);
+
+	/*
+	 *	Set UART pin association. See, e.g., page 99 in
+	 *
+	 *		https://www.nxp.com/docs/en/reference-manual/KL03P24M48SF0RM.pdf
+	 *
+	 *	Setup:
+	 *		PTB3/kWarpPinI2C0_SCL_UART_TX for UART TX
+	 *		PTB4/kWarpPinI2C0_SCL_UART_RX for UART RX
+
+//TODO: we don't use hw flow control so don't need RTS/CTS
+ *		PTA6/kWarpPinSPI_MISO_UART_RTS for UART RTS
+ *		PTA7/kWarpPinSPI_MOSI_UART_CTS for UART CTS
+	 */
+	PORT_HAL_SetMuxMode(PORTB_BASE, 3, kPortMuxAlt3);
+	PORT_HAL_SetMuxMode(PORTB_BASE, 4, kPortMuxAlt3);
+
+//TODO: we don't use hw flow control so don't need RTS/CTS
+//	PORT_HAL_SetMuxMode(PORTA_BASE, 6, kPortMuxAsGpio);
+//	PORT_HAL_SetMuxMode(PORTA_BASE, 7, kPortMuxAsGpio);
+//	GPIO_DRV_SetPinOutput(kWarpPinSPI_MISO_UART_RTS);
+//	GPIO_DRV_SetPinOutput(kWarpPinSPI_MOSI_UART_CTS);
+
+	/*
+	 *	Initialize LPUART0. See KSDK13APIRM.pdf section 40.4.3, page 1353
+	 */
+	lpuartUserConfig.baudRate = gWarpUartBaudRateBps;
+	lpuartUserConfig.parityMode = kLpuartParityDisabled;
+	lpuartUserConfig.stopBitCount = kLpuartOneStopBit;
+	lpuartUserConfig.bitCountPerChar = kLpuart8BitsPerChar;
+	lpuartUserConfig.clockSource = kClockLpuartSrcMcgIrClk;
+
+	LPUART_DRV_Init(0,(lpuart_state_t *)&lpuartState,(lpuart_user_config_t *)&lpuartUserConfig);
+}
+
+
+void
+disableLPUARTpins(void)
+{
+	/*
+	 *	LPUART deinit
+	 */
+	LPUART_DRV_Deinit(0);
+
+	/*
+	 *	Set UART pin association. See, e.g., page 99 in
+	 *
+	 *		https://www.nxp.com/docs/en/reference-manual/KL03P24M48SF0RM.pdf
+	 *
+	 *	Setup:
+	 *		PTB3/kWarpPinI2C0_SCL_UART_TX for UART TX
+	 *		PTB4/kWarpPinI2C0_SCL_UART_RX for UART RX
+
+//TODO: we don't use the HW flow control and that messes with the SPI any way
+ *		PTA6/kWarpPinSPI_MISO_UART_RTS for UART RTS
+ *		PTA7/kWarpPinSPI_MOSI_UART_CTS for UART CTS
+	 */
+	PORT_HAL_SetMuxMode(PORTB_BASE, 3, kPortPinDisabled);
+	PORT_HAL_SetMuxMode(PORTB_BASE, 4, kPortPinDisabled);
+
+//TODO: we don't use flow-control
+	PORT_HAL_SetMuxMode(PORTA_BASE, 6, kPortMuxAsGpio);
+	PORT_HAL_SetMuxMode(PORTA_BASE, 7, kPortMuxAsGpio);
+
+	GPIO_DRV_ClearPinOutput(kWarpPinSPI_MISO_UART_RTS);
+	GPIO_DRV_ClearPinOutput(kWarpPinSPI_MOSI_UART_CTS);
+
+	/*
+	 *	Disable LPUART CLOCK
+	*/
+	CLOCK_SYS_DisableLpuartClock(0);
+}
+
+
+
+WarpStatus
+sendBytesToUART(uint8_t *  bytes, size_t nbytes)
+{
+	lpuart_status_t	status;
+
+	status = LPUART_DRV_SendDataBlocking(0, bytes, nbytes, gWarpUartTimeoutMilliseconds);
+	if (status != 0)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+
 
 void
 warpEnableSPIpins(void)
@@ -118,21 +509,155 @@ warpEnableSPIpins(void)
 	SPI_DRV_MasterConfigureBus(0 /* SPI master instance */, (spi_master_user_config_t *)&spiUserConfig, &calculatedBaudRate);
 }
 
+
+
+void
+warpDisableSPIpins(void)
+{
+	SPI_DRV_MasterDeinit(0);
+
+	/*	kWarpPinSPI_MISO_UART_RTS	--> PTA6	(GPI)		*/
+	PORT_HAL_SetMuxMode(PORTA_BASE, 6, kPortMuxAsGpio);
+
+	/*	kWarpPinSPI_MOSI_UART_CTS	--> PTA7	(GPIO)		*/
+	PORT_HAL_SetMuxMode(PORTA_BASE, 7, kPortMuxAsGpio);
+
+	#if (WARP_BUILD_ENABLE_GLAUX_VARIANT)
+		/*	kWarpPinSPI_SCK	--> PTA9	(GPIO)			*/
+		PORT_HAL_SetMuxMode(PORTA_BASE, 9, kPortMuxAsGpio);
+	#else
+		/*	kWarpPinSPI_SCK	--> PTB0	(GPIO)			*/
+		PORT_HAL_SetMuxMode(PORTB_BASE, 0, kPortMuxAsGpio);
+	#endif
+
+//TODO: we don't use HW flow control so can remove these since we don't use the RTS/CTS
+	GPIO_DRV_ClearPinOutput(kWarpPinSPI_MOSI_UART_CTS);
+	GPIO_DRV_ClearPinOutput(kWarpPinSPI_MISO_UART_RTS);
+	GPIO_DRV_ClearPinOutput(kWarpPinSPI_SCK);
+
+	CLOCK_SYS_DisableSpiClock(0);
+}
+
+
+
+void
+warpDeasserAllSPIchipSelects(void)
+{
+	/*
+	 *	By default, assusme pins are currently disabled (e.g., by a recent lowPowerPinStates())
+	 *
+	 *	Drive all chip selects high to disable them. Individual drivers call this routine before
+	 *	appropriately asserting their respective chip selects.
+	 *
+	 *	Setup:
+	 *		PTA12/kWarpPinISL23415_SPI_nCS	for GPIO
+	 *		PTA9/kWarpPinAT45DB_SPI_nCS	for GPIO
+	 *		PTA8/kWarpPinADXL362_SPI_nCS	for GPIO
+	 *		PTB1/kWarpPinFPGA_nCS		for GPIO
+	 *
+	 *		On Glaux
+	 		PTB2/kGlauxPinFlash_SPI_nCS for GPIO
+	 */
+	PORT_HAL_SetMuxMode(PORTA_BASE, 12, kPortMuxAsGpio);
+	PORT_HAL_SetMuxMode(PORTA_BASE, 9, kPortMuxAsGpio);
+	PORT_HAL_SetMuxMode(PORTA_BASE, 8, kPortMuxAsGpio);
+	PORT_HAL_SetMuxMode(PORTB_BASE, 1, kPortMuxAsGpio);
+	#if (WARP_BUILD_ENABLE_GLAUX_VARIANT)
+		PORT_HAL_SetMuxMode(PORTB_BASE, 2, kPortMuxAsGpio);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVISL23415)
+		GPIO_DRV_SetPinOutput(kWarpPinISL23415_SPI_nCS);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVAT45DB)
+		GPIO_DRV_SetPinOutput(kWarpPinAT45DB_SPI_nCS);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVADXL362)
+		GPIO_DRV_SetPinOutput(kWarpPinADXL362_SPI_nCS);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVICE40)
+		GPIO_DRV_SetPinOutput(kWarpPinFPGA_nCS);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_GLAUX_VARIANT)
+		GPIO_DRV_SetPinOutput(kGlauxPinFlash_SPI_nCS);
+	#endif
+}
+
+
+
+void
+debugPrintSPIsinkBuffer(void)
+{
+	for (int i = 0; i < kWarpMemoryCommonSpiBufferBytes; i++)
+	{
+		warpPrint("\tgWarpSpiCommonSinkBuffer[%d] = [0x%02X]\n", i, gWarpSpiCommonSinkBuffer[i]);
+	}
+	warpPrint("\n");
+}
+
+
+
+void
+warpEnableI2Cpins(void)
+{
+	CLOCK_SYS_EnableI2cClock(0);
+
+	/*
+	 *	Setup:
+	 *
+	 *		PTB3/kWarpPinI2C0_SCL_UART_TX	-->	(ALT2 == I2C)
+	 *		PTB4/kWarpPinI2C0_SDA_UART_RX	-->	(ALT2 == I2C)
+	 */
+	PORT_HAL_SetMuxMode(PORTB_BASE, 3, kPortMuxAlt2);
+	PORT_HAL_SetMuxMode(PORTB_BASE, 4, kPortMuxAlt2);
+
+	I2C_DRV_MasterInit(0 /* I2C instance */, (i2c_master_state_t *)&i2cMasterState);
+}
+
+
+
 void
-lowPowerPinStates(void)
+warpDisableI2Cpins(void)
+{
+	I2C_DRV_MasterDeinit(0 /* I2C instance */);
+
+	/*
+	 *	Setup:
+	 *
+	 *		PTB3/kWarpPinI2C0_SCL_UART_TX	-->	disabled
+	 *		PTB4/kWarpPinI2C0_SDA_UART_RX	-->	disabled
+	 */
+	PORT_HAL_SetMuxMode(PORTB_BASE, 3, kPortPinDisabled);
+	PORT_HAL_SetMuxMode(PORTB_BASE, 4, kPortPinDisabled);
+
+	CLOCK_SYS_DisableI2cClock(0);
+}
+
+
+#if (WARP_BUILD_ENABLE_GLAUX_VARIANT)
+	void
+	lowPowerPinStates(void)
 	{
 		/*
 		 *	Following Section 5 of "Power Management for Kinetis L Family" (AN5088.pdf),
-		 *	we configure all pins as output and set them to a known state. We choose
-		 *	to set them all to '0' since it happens that the devices we want to keep
-		 *	deactivated (SI4705) also need '0'.
+		 *	we configure all pins as output and set them to a known state, except for the
+		 *	sacrificial pins (WLCSP package, Glaux) where we set them to disabled. We choose
+		 *	to set non-disabled pins to '0'.
+		 *
+		 *	NOTE: Pin state "disabled" means default functionality is active.
 		 */
 
 		/*
 		 *			PORT A
 		 */
 		/*
-		 *	For now, don't touch the PTA0/1/2 SWD pins. Revisit in the future.
+		 *	Leave PTA0/1/2 SWD pins in their default state (i.e., as SWD / Alt3).
+		 *
+		 *	See GitHub issue https://github.com/physical-computation/Warp-firmware/issues/54
 		 */
 		PORT_HAL_SetMuxMode(PORTA_BASE, 0, kPortMuxAlt3);
 		PORT_HAL_SetMuxMode(PORTA_BASE, 1, kPortMuxAlt3);
@@ -153,12 +678,14 @@ lowPowerPinStates(void)
 		 *	Disable PTA5
 		 *
 		 *	NOTE: Enabling this significantly increases current draw
-		 *	(from ~180uA to ~4mA) and we don't need the RTC on revC.
+		 *	(from ~180uA to ~4mA) and we don't need the RTC on Glaux.
 		 *
 		 */
 		PORT_HAL_SetMuxMode(PORTA_BASE, 5, kPortPinDisabled);
 
 		/*
+		 *	PTA6, PTA7, PTA8, and PTA9 on Glaux are SPI and sacrificial SPI.
+		 *
 		 *	Section 2.6 of Kinetis Energy Savings  Tips and Tricks says
 		 *
 		 *		"Unused pins should be configured in the disabled state, mux(0),
@@ -175,190 +702,487 @@ lowPowerPinStates(void)
 		/*
 		 *	NOTE: The KL03 has no PTA10 or PTA11
 		 */
+
+		/*
+		 *	In Glaux, PTA12 is a sacrificial pin for SWD_RESET, so careful not to drive it.
+		 */
 		PORT_HAL_SetMuxMode(PORTA_BASE, 12, kPortPinDisabled);
 
 
+
 		/*
 		 *			PORT B
+		 *
+		 *	PTB0 is LED on Glaux. PTB1 is unused, and PTB2 is FLASH_!CS
 		 */
-		PORT_HAL_SetMuxMode(PORTB_BASE, 0, kPortPinDisabled);
+		PORT_HAL_SetMuxMode(PORTB_BASE, 0, kPortMuxAsGpio);
 		PORT_HAL_SetMuxMode(PORTB_BASE, 1, kPortPinDisabled);
-		PORT_HAL_SetMuxMode(PORTB_BASE, 2, kPortPinDisabled);
+		PORT_HAL_SetMuxMode(PORTB_BASE, 2, kPortMuxAsGpio);
+
+		/*
+		 *	PTB3 and PTB4 (I2C pins) are true open-drain and we
+		 *	purposefully leave them disabled since they have pull-ups.
+		 *	PTB5 is sacrificial for I2C_SDA, so disable.
+		 */
 		PORT_HAL_SetMuxMode(PORTB_BASE, 3, kPortPinDisabled);
 		PORT_HAL_SetMuxMode(PORTB_BASE, 4, kPortPinDisabled);
 		PORT_HAL_SetMuxMode(PORTB_BASE, 5, kPortPinDisabled);
-		PORT_HAL_SetMuxMode(PORTB_BASE, 6, kPortPinDisabled);
-		PORT_HAL_SetMuxMode(PORTB_BASE, 7, kPortPinDisabled);
-		PORT_HAL_SetMuxMode(PORTB_BASE, 10, kPortPinDisabled);
-		PORT_HAL_SetMuxMode(PORTB_BASE, 11, kPortPinDisabled);
+
+		/*
+		 *	NOTE:
+		 *
+		 *	The KL03 has no PTB8, PTB9, or PTB12.  Additionally, the WLCSP package
+		 *	we in Glaux has no PTB6, PTB7, PTB10, or PTB11.
+		 */
+
+		/*
+		 *	In Glaux, PTB13 is a sacrificial pin for SWD_RESET, so careful not to drive it.
+		 */
 		PORT_HAL_SetMuxMode(PORTB_BASE, 13, kPortPinDisabled);
-	}
 
-void warpStart(void){
-	rtc_datetime_t				warpBootDate;
+		GPIO_DRV_SetPinOutput(kGlauxPinFlash_SPI_nCS);
+		GPIO_DRV_ClearPinOutput(kGlauxPinLED);
 
-	/*
-	 *	We use this as a template later below and change the .mode fields for the different other modes.
-	 */
-	const power_manager_user_config_t	warpPowerModeVlprConfig = {
-							.mode			= kPowerManagerVlpr,
-							.sleepOnExitValue	= false,
-							.sleepOnExitOption	= false
-						};
+		return;
+	}
+#else
+	void
+	lowPowerPinStates(void)
+	{
+		/*
+		 *	Following Section 5 of "Power Management for Kinetis L Family" (AN5088.pdf),
+		 *	we configure all pins as output and set them to a known state. We choose
+		 *	to set them all to '0' since it happens that the devices we want to keep
+		 *	deactivated (SI4705) also need '0'.
+		 */
 
-	power_manager_user_config_t const *	powerConfigs[] = {
-							/*
-							 *	NOTE: POWER_SYS_SetMode() depends on this order
-							 *
-							 *	See KSDK13APIRM.pdf Section 55.5.3
-							 */
-							&warpPowerModeVlprConfig,
-						};
+		/*
+		 *			PORT A
+		 */
+		/*
+		 *	For now, don't touch the PTA0/1/2 SWD pins. Revisit in the future.
+		 */
+		PORT_HAL_SetMuxMode(PORTA_BASE, 0, kPortMuxAlt3);
+		PORT_HAL_SetMuxMode(PORTA_BASE, 1, kPortMuxAlt3);
+		PORT_HAL_SetMuxMode(PORTA_BASE, 2, kPortMuxAlt3);
 
-	/*
-	 *	Enable clock for I/O PORT A and PORT B
-	 */
-	CLOCK_SYS_EnablePortClock(0);
-	CLOCK_SYS_EnablePortClock(1);
+		/*
+		 *	PTA3 and PTA4 are the EXTAL0/XTAL0. They are also connected to the clock output
+		 *	of the RV8803 (and PTA4 is a sacrificial pin for PTA3), so do not want to drive them.
+		 *	We however have to configure PTA3 to Alt0 (kPortPinDisabled) to get the EXTAL0
+		 *	functionality.
+		 *
+		 *	NOTE:	kPortPinDisabled is the equivalent of `Alt0`
+		 */
+		PORT_HAL_SetMuxMode(PORTA_BASE, 3, kPortPinDisabled);
+		PORT_HAL_SetMuxMode(PORTA_BASE, 4, kPortPinDisabled);
 
-	/*
-	 *	Set board crystal value (Warp revB and earlier).
-	 */
-	g_xtal0ClkFreq = 32768U;
+		/*
+		 *	Disable PTA5
+		 *
+		 *	NOTE: Enabling this significantly increases current draw
+		 *	(from ~180uA to ~4mA) and we don't need the RTC on revC.
+		 *
+		 */
+		PORT_HAL_SetMuxMode(PORTA_BASE, 5, kPortPinDisabled);
 
-	/*
-	 *	Initialize KSDK Operating System Abstraction layer (OSA) layer.
-	 */
-	OSA_Init();
+		/*
+		 *	Section 2.6 of Kinetis Energy Savings  Tips and Tricks says
+		 *
+		 *		"Unused pins should be configured in the disabled state, mux(0),
+		 *		to prevent unwanted leakage (potentially caused by floating inputs)."
+		 *
+		 *	However, other documents advice to place pin as GPIO and drive low or high.
+		 *	For now, leave disabled. Filed issue #54 low-power pin states to investigate.
+		 */
+		PORT_HAL_SetMuxMode(PORTA_BASE, 6, kPortPinDisabled);
+		PORT_HAL_SetMuxMode(PORTA_BASE, 7, kPortPinDisabled);
+		PORT_HAL_SetMuxMode(PORTA_BASE, 8, kPortPinDisabled);
+		PORT_HAL_SetMuxMode(PORTA_BASE, 9, kPortPinDisabled);
 
-	/*
-	 *	Setup SEGGER RTT to output as much as fits in buffers.
-	 *
-	 *	Using SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL can lead to deadlock, since
-	 *	we might have SWD disabled at time of blockage.
-	 */
-	SEGGER_RTT_ConfigUpBuffer(0, NULL, NULL, 0, SEGGER_RTT_MODE_NO_BLOCK_TRIM);
+		/*
+		 *	NOTE: The KL03 has no PTA10 or PTA11
+		 */
+		PORT_HAL_SetMuxMode(PORTA_BASE, 12, kPortPinDisabled);
 
-	/*
-	 *	Configure Clock Manager to default, and set callback for Clock Manager mode transition.
-	 *
-	 *	See "Clocks and Low Power modes with KSDK and Processor Expert" document (Low_Power_KSDK_PEx.pdf)
-	 */
-	CLOCK_SYS_Init(	g_defaultClockConfigurations,
-			CLOCK_CONFIG_NUM, /* The default value of this is defined in fsl_clock_MKL03Z4.h as 2 */
-			NULL,
-			0
-			);
-	CLOCK_SYS_UpdateConfiguration(CLOCK_CONFIG_INDEX_FOR_RUN, kClockManagerPolicyForcible);
 
-	/*
-	 *	Initialize RTC Driver (not needed on Glaux, but we enable it anyway for now
-	 *	as that lets us use the current sleep routines). NOTE: We also don't seem to
-	 *	be able to go to VLPR mode unless we enable the RTC.
-	 */
-	RTC_DRV_Init(0);
+		/*
+		 *			PORT B
+		 */
+		PORT_HAL_SetMuxMode(PORTB_BASE, 0, kPortPinDisabled);
+		PORT_HAL_SetMuxMode(PORTB_BASE, 1, kPortPinDisabled);
+		PORT_HAL_SetMuxMode(PORTB_BASE, 2, kPortPinDisabled);
+		PORT_HAL_SetMuxMode(PORTB_BASE, 3, kPortPinDisabled);
+		PORT_HAL_SetMuxMode(PORTB_BASE, 4, kPortPinDisabled);
+		PORT_HAL_SetMuxMode(PORTB_BASE, 5, kPortPinDisabled);
+		PORT_HAL_SetMuxMode(PORTB_BASE, 6, kPortPinDisabled);
+		PORT_HAL_SetMuxMode(PORTB_BASE, 7, kPortPinDisabled);
+		PORT_HAL_SetMuxMode(PORTB_BASE, 10, kPortPinDisabled);
+		PORT_HAL_SetMuxMode(PORTB_BASE, 11, kPortPinDisabled);
+		PORT_HAL_SetMuxMode(PORTB_BASE, 13, kPortPinDisabled);
+	}
+#endif
 
-	/*
-	 *	Set initial date to 1st January 2016 00:00, and set date via RTC driver
-	 */
-	warpBootDate.year	= 2016U;
-	warpBootDate.month	= 1U;
-	warpBootDate.day	= 1U;
-	warpBootDate.hour	= 0U;
-	warpBootDate.minute	= 0U;
-	warpBootDate.second	= 0U;
-	RTC_DRV_SetDatetime(0, &warpBootDate);
 
-	POWER_SYS_Init(	&powerConfigs,
-		sizeof(powerConfigs)/sizeof(power_manager_user_config_t *),
-		NULL,
-		0
-	);
+void
+disableTPS62740(void)
+{
+	#if (!WARP_BUILD_ENABLE_GLAUX_VARIANT)
+		GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_REGCTRL);
+	#endif
+}
 
-	/*
-	 *	Switch CPU to Very Low Power Run (VLPR) mode
-	 */
-	CLOCK_SYS_UpdateConfiguration(CLOCK_CONFIG_INDEX_FOR_VLPR, kClockManagerPolicyForcible);
+void
+enableTPS62740(uint16_t voltageMillivolts)
+{
+	#if (!WARP_BUILD_ENABLE_GLAUX_VARIANT)
+		/*
+		 *	By default, assusme pins are currently disabled (e.g., by a recent lowPowerPinStates())
+		 *
+		 *	Setup:
+		 *		PTB5/kWarpPinTPS62740_REGCTRL for GPIO
+		 *		PTB6/kWarpPinTPS62740_VSEL4 for GPIO
+		 *		PTB7/kWarpPinTPS62740_VSEL3 for GPIO
+		 *		PTB10/kWarpPinTPS62740_VSEL2 for GPIO
+		 *		PTB11/kWarpPinTPS62740_VSEL1 for GPIO
+		 */
+		PORT_HAL_SetMuxMode(PORTB_BASE, 5, kPortMuxAsGpio);
+		PORT_HAL_SetMuxMode(PORTB_BASE, 6, kPortMuxAsGpio);
+		PORT_HAL_SetMuxMode(PORTB_BASE, 7, kPortMuxAsGpio);
+		PORT_HAL_SetMuxMode(PORTB_BASE, 10, kPortMuxAsGpio);
+		PORT_HAL_SetMuxMode(PORTB_BASE, 11, kPortMuxAsGpio);
 
-	// POWER_SYS_SetMode(0, kPowerManagerPolicyAgreement);
+		setTPS62740CommonControlLines(voltageMillivolts);
+		GPIO_DRV_SetPinOutput(kWarpPinTPS62740_REGCTRL);
+	#endif
+}
 
-	/*
-	 *	Initialize the GPIO pins with the appropriate pull-up, etc.,
-	 *	defined in the inputPins and outputPins arrays (gpio_pins.c).
-	 *
-	 *	See also Section 30.3.3 GPIO Initialization of KSDK13APIRM.pdf
-	 */
-	GPIO_DRV_Init(inputPins  /* input pins */, outputPins  /* output pins */);
+void
+setTPS62740CommonControlLines(uint16_t voltageMillivolts)
+{
+	#if (!WARP_BUILD_ENABLE_GLAUX_VARIANT)
+		switch(voltageMillivolts)
+		{
+			case 1800:
+			{
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL1);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL2);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL3);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL4);
 
-	/*
-	 *	Make sure the SWD pins, PTA0/1/2 SWD pins in their ALT3 state (i.e., as SWD).
-	 *
-	 *	See GitHub issue https://github.com/physical-computation/Warp-firmware/issues/54
-	 */
-	PORT_HAL_SetMuxMode(PORTA_BASE, 0, kPortMuxAlt3);
-	PORT_HAL_SetMuxMode(PORTA_BASE, 1, kPortMuxAlt3);
-	PORT_HAL_SetMuxMode(PORTA_BASE, 2, kPortMuxAlt3);
+				break;
+			}
 
-	/*
-	 *	Note that it is lowPowerPinStates() that sets the pin mux mode,
-	 *	so until we call it pins are in their default state.
-	 */
-	lowPowerPinStates();
+			case 1900:
+			{
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL1);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL2);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL3);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL4);
+
+				break;
+			}
+
+			case 2000:
+			{
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL1);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL2);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL3);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL4);
+
+				break;
+			}
+
+			case 2100:
+			{
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL1);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL2);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL3);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL4);
+
+				break;
+			}
+
+			case 2200:
+			{
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL1);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL2);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL3);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL4);
+
+				break;
+			}
+
+			case 2300:
+			{
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL1);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL2);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL3);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL4);
+
+				break;
+			}
+
+			case 2400:
+			{
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL1);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL2);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL3);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL4);
+
+				break;
+			}
+
+			case 2500:
+			{
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL1);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL2);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL3);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL4);
+
+				break;
+			}
+
+			case 2600:
+			{
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL1);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL2);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL3);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL4);
+
+				break;
+			}
+
+			case 2700:
+			{
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL1);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL2);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL3);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL4);
+
+				break;
+			}
+
+			case 2800:
+			{
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL1);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL2);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL3);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL4);
+
+				break;
+			}
+
+			case 2900:
+			{
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL1);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL2);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL3);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL4);
+
+				break;
+			}
+
+			case 3000:
+			{
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL1);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL2);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL3);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL4);
+
+				break;
+			}
+
+			case 3100:
+			{
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL1);
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL2);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL3);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL4);
+
+				break;
+			}
+
+			case 3200:
+			{
+				GPIO_DRV_ClearPinOutput(kWarpPinTPS62740_VSEL1);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL2);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL3);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL4);
+
+				break;
+			}
+
+			case 3300:
+			{
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL1);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL2);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL3);
+				GPIO_DRV_SetPinOutput(kWarpPinTPS62740_VSEL4);
+
+				break;
+			}
+
+			/*
+			 *	Should never happen, due to previous check in warpScaleSupplyVoltage()
+			 */
+			default:
+			{
+				warpPrint(RTT_CTRL_RESET RTT_CTRL_BG_BRIGHT_YELLOW RTT_CTRL_TEXT_BRIGHT_WHITE kWarpConstantStringErrorSanity RTT_CTRL_RESET "\n");
+			}
+		}
+
+		/*
+		 *	Vload ramp time of the TPS62740 is 800us max (datasheet, Table 8.5 / page 6)
+		 */
+		OSA_TimeDelay(gWarpSupplySettlingDelayMilliseconds);
+	#endif
+}
+
+
+
+void
+warpScaleSupplyVoltage(uint16_t voltageMillivolts)
+{
+	if (voltageMillivolts == gWarpCurrentSupplyVoltage)
+	{
+		return;
+	}
+
+	#if (!WARP_BUILD_ENABLE_GLAUX_VARIANT)
+		if (voltageMillivolts >= 1800 && voltageMillivolts <= 3300)
+		{
+			enableTPS62740(voltageMillivolts);
+			gWarpCurrentSupplyVoltage = voltageMillivolts;
+		}
+		else
+		{
+			warpPrint(RTT_CTRL_RESET RTT_CTRL_BG_BRIGHT_RED RTT_CTRL_TEXT_BRIGHT_WHITE kWarpConstantStringErrorInvalidVoltage RTT_CTRL_RESET "\n", voltageMillivolts);
+		}
+	#endif
+}
+
+
+
+void
+warpDisableSupplyVoltage(void)
+{
+	#if (!WARP_BUILD_ENABLE_GLAUX_VARIANT)
+		disableTPS62740();
+
+		/*
+		 *	Vload ramp time of the TPS62740 is 800us max (datasheet, Table 8.5 / page 6)
+		 */
+		OSA_TimeDelay(gWarpSupplySettlingDelayMilliseconds);
+	#endif
+}
+
+
+void
+warpLowPowerSecondsSleep(uint32_t sleepSeconds, bool forceAllPinsIntoLowPowerState)
+{
+	WarpStatus	status = kWarpStatusOK;
 
 	/*
-	 *	At this point, we consider the system "booted" and, e.g., warpPrint()s
-	 *	will also be sent to the BLE if that is compiled in.
+	 *	Set all pins into low-power states. We don't just disable all pins,
+	 *	as the various devices hanging off will be left in higher power draw
+	 *	state. And manuals say set pins to output to reduce power.
 	 */
-	gWarpBooted = true;
+	if (forceAllPinsIntoLowPowerState)
+	{
+		lowPowerPinStates();
+	}
+
+	warpSetLowPowerMode(kWarpPowerModeVLPR, 0 /* Sleep Seconds */);
+	if ((status != kWarpStatusOK) && (status != kWarpStatusPowerTransitionErrorVlpr2Vlpr))
+	{
+		warpPrint("warpSetLowPowerMode(kWarpPowerModeVLPR, 0 /* sleep seconds : irrelevant here */)() failed...\n");
+	}
 
+	status = warpSetLowPowerMode(kWarpPowerModeVLPS, sleepSeconds);
+	if (status != kWarpStatusOK)
+	{
+		warpPrint("warpSetLowPowerMode(kWarpPowerModeVLPS, 0 /* sleep seconds : irrelevant here */)() failed...\n");
+	}
 }
 
-int
-main(void)
+
+/*
+void
+printPinDirections(void)
 {
-	// call function that performs misc warp start-up operations
-	// simply for readablabilit
-	warpStart();
+	warpPrint("I2C0_SDA:%d\n", GPIO_DRV_GetPinDir(kWarpPinI2C0_SDA_UART_RX));
+	OSA_TimeDelay(100);
+	warpPrint("I2C0_SCL:%d\n", GPIO_DRV_GetPinDir(kWarpPinI2C0_SCL_UART_TX));
+	OSA_TimeDelay(100);
+	warpPrint("SPI_MOSI:%d\n", GPIO_DRV_GetPinDir(kWarpPinSPI_MOSI_UART_CTS));
+	OSA_TimeDelay(100);
+	warpPrint("SPI_MISO:%d\n", GPIO_DRV_GetPinDir(kWarpPinSPI_MISO_UART_RTS));
+	OSA_TimeDelay(100);
+	warpPrint("SPI_SCK_I2C_PULLUP_EN:%d\n", GPIO_DRV_GetPinDir(kWarpPinSPI_SCK_I2C_PULLUP_EN));
+	OSA_TimeDelay(100);
+	warpPrint("ADXL362_CS:%d\n", GPIO_DRV_GetPinDir(kWarpPinADXL362_CS));
+	OSA_TimeDelay(100);
+}
+*/
 
-	// intialise variables for FFT
-	float complex fft_output[NUMBER_OF_STORED_READINGS];
-	float frequency_powers[NUMBER_OF_FREQS - IGNORED_FREQS];
 
-	// start ADC continously converting
-    ADCinit();
 
-	// debug routine allowing checking of ADC
-	// e.g. check known voltage and ground give
-	// consisten values
-	#if DEBUG_LOOP
-		int32_t adc_value;
-		while(1){
-			adc_value = read_from_adc();
-			warpPrint("%u\n", adc_value);
-		}
-	#endif
+void
+dumpProcessorState(void)
+{
+	uint32_t	cpuClockFrequency;
 
-	// intialise OLED screen and take intial readings for chart scaling
-	// baseline
-	devSSD1331init();
-	chart_calibration(adc_readings, fft_output, frequency_powers);
+	CLOCK_SYS_GetFreq(kCoreClock, &cpuClockFrequency);
+	warpPrint("\r\n\n\tCPU @ %u KHz\n", (cpuClockFrequency / 1000));
+	warpPrint("\r\tCPU power mode: %u\n", POWER_SYS_GetCurrentMode());
+	warpPrint("\r\tCPU clock manager configuration: %u\n", CLOCK_SYS_GetCurrentConfiguration());
+	warpPrint("\r\tRTC clock: %d\n", CLOCK_SYS_GetRtcGateCmd(0));
+	warpPrint("\r\tSPI clock: %d\n", CLOCK_SYS_GetSpiGateCmd(0));
+	warpPrint("\r\tI2C clock: %d\n", CLOCK_SYS_GetI2cGateCmd(0));
+	warpPrint("\r\tLPUART clock: %d\n", CLOCK_SYS_GetLpuartGateCmd(0));
+	warpPrint("\r\tPORT A clock: %d\n", CLOCK_SYS_GetPortGateCmd(0));
+	warpPrint("\r\tPORT B clock: %d\n", CLOCK_SYS_GetPortGateCmd(1));
+	warpPrint("\r\tFTF clock: %d\n", CLOCK_SYS_GetFtfGateCmd(0));
+	warpPrint("\r\tADC clock: %d\n", CLOCK_SYS_GetAdcGateCmd(0));
+	warpPrint("\r\tCMP clock: %d\n", CLOCK_SYS_GetCmpGateCmd(0));
+	warpPrint("\r\tVREF clock: %d\n", CLOCK_SYS_GetVrefGateCmd(0));
+	warpPrint("\r\tTPM clock: %d\n", CLOCK_SYS_GetTpmGateCmd(0));
+}
 
-	// main program loop
-    while(1){
 
-		// sequentially take
-		ADC_read_set(0);
-		fft(adc_readings, fft_output, NUMBER_OF_STORED_READINGS);
-		process_powers(fft_output, frequency_powers);
-		draw_frequency_chart(frequency_powers);
+void
+printBootSplash(uint16_t gWarpCurrentSupplyVoltage, uint8_t menuRegisterAddress, WarpPowerManagerCallbackStructure *  powerManagerCallbackStructure)
+{
+	/*
+	 *	We break up the prints with small delays to allow us to use small RTT print
+	 *	buffers without overrunning them when at max CPU speed.
+	 */
+	warpPrint("\r\n\n\n\n[ *\t\t\t\tWarp (HW revision C) / Glaux (HW revision B)\t\t\t* ]\n");
+	warpPrint("\r[  \t\t\t\t      Cambridge / Physcomplab   \t\t\t\t  ]\n\n");
+	warpPrint("\r\tSupply=%dmV,\tDefault Target Read Register=0x%02x\n",
+			gWarpCurrentSupplyVoltage, menuRegisterAddress);
+	warpPrint("\r\tI2C=%dkb/s,\tSPI=%dkb/s,\tUART=%db/s,\tI2C Pull-Up=%d\n\n",
+			gWarpI2cBaudRateKbps, gWarpSpiBaudRateKbps, gWarpUartBaudRateBps);
+	warpPrint("\r\tSIM->SCGC6=0x%02x\t\tRTC->SR=0x%02x\t\tRTC->TSR=0x%02x\n", SIM->SCGC6, RTC->SR, RTC->TSR);
+	warpPrint("\r\tMCG_C1=0x%02x\t\t\tMCG_C2=0x%02x\t\tMCG_S=0x%02x\n", MCG_C1, MCG_C2, MCG_S);
+	warpPrint("\r\tMCG_SC=0x%02x\t\t\tMCG_MC=0x%02x\t\tOSC_CR=0x%02x\n", MCG_SC, MCG_MC, OSC_CR);
+	warpPrint("\r\tSMC_PMPROT=0x%02x\t\t\tSMC_PMCTRL=0x%02x\t\tSCB->SCR=0x%02x\n", SMC_PMPROT, SMC_PMCTRL, SCB->SCR);
+	warpPrint("\r\tPMC_REGSC=0x%02x\t\t\tSIM_SCGC4=0x%02x\tRTC->TPR=0x%02x\n\n", PMC_REGSC, SIM_SCGC4, RTC->TPR);
+	warpPrint("\r\t%ds in RTC Handler to-date,\t%d Pmgr Errors\n", gWarpSleeptimeSeconds, powerManagerCallbackStructure->errorCount);
+}
 
-    }
+void
+blinkLED(int pin)
+{
+	GPIO_DRV_SetPinOutput(pin);
+	OSA_TimeDelay(200);
+	GPIO_DRV_ClearPinOutput(pin);
+	OSA_TimeDelay(200);
 
+	return;
 }
 
-// need warp print if in debug mode so can output ADC values
-// including if not in debug causes silent stack overflow
-#if DEBUG
 void
 warpPrint(const char *fmt, ...)
 {
@@ -389,10 +1213,2697 @@ warpPrint(const char *fmt, ...)
 		if (fmtlen < 0)
 		{
 			SEGGER_RTT_WriteString(0, gWarpEfmt);
-			return;
-		}
+
+			#if (WARP_BUILD_ENABLE_DEVBGX)
+				if (gWarpBooted)
+				{
+					WarpStatus	status;
+
+					enableLPUARTpins();
+					initBGX(kWarpDefaultSupplyVoltageMillivoltsBGX);
+					status = sendBytesToUART((uint8_t *)gWarpEfmt, strlen(gWarpEfmt)+1);
+					if (status != kWarpStatusOK)
+					{
+						SEGGER_RTT_WriteString(0, gWarpEuartSendChars);
+					}
+					disableLPUARTpins();
+
+					/*
+					 *	We don't want to deInit() the BGX since that would drop
+					 *	any remote terminal connected to it.
+					 */
+					//deinitBGX();
+				}
+			#endif
+
+			return;
+		}
+
+		/*
+		 *	If WARP_BUILD_ENABLE_DEVBGX, also send the fmt to the UART / BLE.
+		 */
+		#if (WARP_BUILD_ENABLE_DEVBGX)
+			if (gWarpBooted)
+			{
+				WarpStatus	status;
+
+				enableLPUARTpins();
+				initBGX(kWarpDefaultSupplyVoltageMillivoltsBGX);
+
+				status = sendBytesToUART((uint8_t *)gWarpPrintBuffer, max(fmtlen, kWarpDefaultPrintBufferSizeBytes));
+				if (status != kWarpStatusOK)
+				{
+					SEGGER_RTT_WriteString(0, gWarpEuartSendChars);
+				}
+				disableLPUARTpins();
+
+				/*
+				 *	We don't want to deInit() the BGX since that would drop
+				 *	any remote terminal connected to it.
+				 */
+				//deinitBGX();
+			}
+		#endif
+	#else
+		/*
+		 *	If we are not compiling in the SEGGER_RTT_printf,
+		 *	we just send the format string of warpPrint()
+		 */
+		SEGGER_RTT_WriteString(0, fmt);
+
+		/*
+		 *	If WARP_BUILD_ENABLE_DEVBGX, also send the fmt to the UART / BLE.
+		 */
+		#if (WARP_BUILD_ENABLE_DEVBGX)
+			if (gWarpBooted)
+			{
+				WarpStatus	status;
+
+				enableLPUARTpins();
+				initBGX(kWarpDefaultSupplyVoltageMillivoltsBGX);
+				status = sendBytesToUART(fmt, strlen(fmt));
+				if (status != kWarpStatusOK)
+				{
+					SEGGER_RTT_WriteString(0, gWarpEuartSendChars);
+				}
+				disableLPUARTpins();
+
+				/*
+				 *	We don't want to deInit() the BGX since that would drop
+				 *	any remote terminal connected to it.
+				 */
+				//deinitBGX();
+			}
+		#endif
 	#endif
 
 	return;
 }
-#endif
\ No newline at end of file
+
+int
+warpWaitKey(void)
+{
+	/*
+	 *	SEGGER'S implementation assumes the result of result of
+	 *	SEGGER_RTT_GetKey() is an int, so we play along.
+	 */
+	int		rttKey, bleChar = kWarpMiscMarkerForAbsentByte;
+
+	/*
+	 *	Set the UART buffer to 0xFF and then wait until either the
+	 *	UART RX buffer changes or the RTT icoming key changes.
+	 *
+	 *	The check below on rttKey is exactly what SEGGER_RTT_WaitKey()
+	 *	does in SEGGER_RTT.c.
+	 */
+	#if (WARP_BUILD_ENABLE_DEVBGX)
+		deviceBGXState.uartRXBuffer[0] = kWarpMiscMarkerForAbsentByte;
+		enableLPUARTpins();
+		initBGX(kWarpDefaultSupplyVoltageMillivoltsBGX);
+	#endif
+
+	do
+	{
+		rttKey	= SEGGER_RTT_GetKey();
+
+		#if (WARP_BUILD_ENABLE_DEVBGX)
+			bleChar	= deviceBGXState.uartRXBuffer[0];
+		#endif
+
+		/*
+		 *	NOTE: We ignore all chars on BLE except '0'-'9', 'a'-'z'/'A'-Z'
+		 */
+		if (!(bleChar > 'a' && bleChar < 'z') && !(bleChar > 'A' && bleChar < 'Z') && !(bleChar > '0' && bleChar < '9'))
+		{
+			bleChar = kWarpMiscMarkerForAbsentByte;
+		}
+	} while ((rttKey < 0) && (bleChar == kWarpMiscMarkerForAbsentByte));
+
+	#if (WARP_BUILD_ENABLE_DEVBGX)
+		if (bleChar != kWarpMiscMarkerForAbsentByte)
+		{
+			/*
+			 *	Send a copy of incoming BLE chars to RTT
+			 */
+			SEGGER_RTT_PutChar(0, bleChar);
+			disableLPUARTpins();
+
+			/*
+			 *	We don't want to deInit() the BGX since that would drop
+			 *	any remote terminal connected to it.
+			 */
+			//deinitBGX();
+
+			return (int)bleChar;
+		}
+
+		/*
+		 *	Send a copy of incoming RTT chars to BLE
+		 */
+		WarpStatus status = sendBytesToUART((uint8_t *)&rttKey, 1);
+		if (status != kWarpStatusOK)
+		{
+			SEGGER_RTT_WriteString(0, gWarpEuartSendChars);
+		}
+
+		disableLPUARTpins();
+
+		/*
+		 *	We don't want to deInit() the BGX since that would drop
+		 *	any remote terminal connected to it.
+		 */
+		//deinitBGX();
+	#endif
+
+	return rttKey;
+}
+
+int
+main(void)
+{
+	WarpStatus				status;
+	uint8_t					key;
+	WarpSensorDevice			menuTargetSensor		= kWarpSensorBMX055accel;
+	volatile WarpI2CDeviceState *		menuI2cDevice			= NULL;
+	uint8_t					menuRegisterAddress		= 0x00;
+	rtc_datetime_t				warpBootDate;
+	power_manager_user_config_t		warpPowerModeWaitConfig;
+	power_manager_user_config_t		warpPowerModeStopConfig;
+	power_manager_user_config_t		warpPowerModeVlpwConfig;
+	power_manager_user_config_t		warpPowerModeVlpsConfig;
+	power_manager_user_config_t		warpPowerModeVlls0Config;
+	power_manager_user_config_t		warpPowerModeVlls1Config;
+	power_manager_user_config_t		warpPowerModeVlls3Config;
+	power_manager_user_config_t		warpPowerModeRunConfig;
+
+	/*
+	 *	We use this as a template later below and change the .mode fields for the different other modes.
+	 */
+	const power_manager_user_config_t	warpPowerModeVlprConfig = {
+							.mode			= kPowerManagerVlpr,
+							.sleepOnExitValue	= false,
+							.sleepOnExitOption	= false
+						};
+
+	power_manager_user_config_t const *	powerConfigs[] = {
+							/*
+							 *	NOTE: POWER_SYS_SetMode() depends on this order
+							 *
+							 *	See KSDK13APIRM.pdf Section 55.5.3
+							 */
+							&warpPowerModeWaitConfig,
+							&warpPowerModeStopConfig,
+							&warpPowerModeVlprConfig,
+							&warpPowerModeVlpwConfig,
+							&warpPowerModeVlpsConfig,
+							&warpPowerModeVlls0Config,
+							&warpPowerModeVlls1Config,
+							&warpPowerModeVlls3Config,
+							&warpPowerModeRunConfig,
+						};
+
+	WarpPowerManagerCallbackStructure		powerManagerCallbackStructure;
+
+	/*
+	 *	Callback configuration structure for power manager
+	 */
+	const power_manager_callback_user_config_t callbackCfg0 = {
+							callback0,
+							kPowerManagerCallbackBeforeAfter,
+							(power_manager_callback_data_t *) &powerManagerCallbackStructure};
+
+	/*
+	 *	Pointers to power manager callbacks.
+	 */
+	power_manager_callback_user_config_t const *	callbacks[] = {
+								&callbackCfg0
+						};
+
+	/*
+	 *	Enable clock for I/O PORT A and PORT B
+	 */
+	CLOCK_SYS_EnablePortClock(0);
+	CLOCK_SYS_EnablePortClock(1);
+
+	/*
+	 *	Set board crystal value (Warp revB and earlier).
+	 */
+	g_xtal0ClkFreq = 32768U;
+
+	/*
+	 *	Initialize KSDK Operating System Abstraction layer (OSA) layer.
+	 */
+	OSA_Init();
+
+	/*
+	 *	Setup SEGGER RTT to output as much as fits in buffers.
+	 *
+	 *	Using SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL can lead to deadlock, since
+	 *	we might have SWD disabled at time of blockage.
+	 */
+	SEGGER_RTT_ConfigUpBuffer(0, NULL, NULL, 0, SEGGER_RTT_MODE_NO_BLOCK_TRIM);
+
+	/*
+	 *	When booting to CSV stream, we wait to be up and running as soon as possible after
+	 *	a reset (e.g., a reset due to waking from VLLS0)
+	 */
+	if (!WARP_BUILD_BOOT_TO_CSVSTREAM)
+	{
+		warpPrint("\n\n\n\rBooting Warp, in 3... ");
+		OSA_TimeDelay(1000);
+		warpPrint("2... ");
+		OSA_TimeDelay(1000);
+		warpPrint("1...\n\n\n\r");
+		OSA_TimeDelay(1000);
+	}
+
+	/*
+	 *	Configure Clock Manager to default, and set callback for Clock Manager mode transition.
+	 *
+	 *	See "Clocks and Low Power modes with KSDK and Processor Expert" document (Low_Power_KSDK_PEx.pdf)
+	 */
+	CLOCK_SYS_Init(	g_defaultClockConfigurations,
+			CLOCK_CONFIG_NUM, /* The default value of this is defined in fsl_clock_MKL03Z4.h as 2 */
+			&clockCallbackTable,
+			ARRAY_SIZE(clockCallbackTable)
+			);
+	CLOCK_SYS_UpdateConfiguration(CLOCK_CONFIG_INDEX_FOR_RUN, kClockManagerPolicyForcible);
+
+	/*
+	 *	Initialize RTC Driver (not needed on Glaux, but we enable it anyway for now
+	 *	as that lets us use the current sleep routines). NOTE: We also don't seem to
+	 *	be able to go to VLPR mode unless we enable the RTC.
+	 */
+	RTC_DRV_Init(0);
+
+	/*
+	 *	Set initial date to 1st January 2016 00:00, and set date via RTC driver
+	 */
+	warpBootDate.year	= 2016U;
+	warpBootDate.month	= 1U;
+	warpBootDate.day	= 1U;
+	warpBootDate.hour	= 0U;
+	warpBootDate.minute	= 0U;
+	warpBootDate.second	= 0U;
+	RTC_DRV_SetDatetime(0, &warpBootDate);
+
+	/*
+	 *	Setup Power Manager Driver
+	 */
+	memset(&powerManagerCallbackStructure, 0, sizeof(WarpPowerManagerCallbackStructure));
+
+	warpPowerModeVlpwConfig = warpPowerModeVlprConfig;
+	warpPowerModeVlpwConfig.mode = kPowerManagerVlpw;
+
+	warpPowerModeVlpsConfig = warpPowerModeVlprConfig;
+	warpPowerModeVlpsConfig.mode = kPowerManagerVlps;
+
+	warpPowerModeWaitConfig = warpPowerModeVlprConfig;
+	warpPowerModeWaitConfig.mode = kPowerManagerWait;
+
+	warpPowerModeStopConfig = warpPowerModeVlprConfig;
+	warpPowerModeStopConfig.mode = kPowerManagerStop;
+
+	warpPowerModeVlls0Config = warpPowerModeVlprConfig;
+	warpPowerModeVlls0Config.mode = kPowerManagerVlls0;
+
+	warpPowerModeVlls1Config = warpPowerModeVlprConfig;
+	warpPowerModeVlls1Config.mode = kPowerManagerVlls1;
+
+	warpPowerModeVlls3Config = warpPowerModeVlprConfig;
+	warpPowerModeVlls3Config.mode = kPowerManagerVlls3;
+
+	warpPowerModeRunConfig.mode = kPowerManagerRun;
+
+	POWER_SYS_Init(	&powerConfigs,
+			sizeof(powerConfigs)/sizeof(power_manager_user_config_t *),
+			&callbacks,
+			sizeof(callbacks)/sizeof(power_manager_callback_user_config_t *)
+			);
+
+	/*
+	 *	Switch CPU to Very Low Power Run (VLPR) mode
+	 */
+	if (WARP_BUILD_BOOT_TO_VLPR)
+	{
+		warpPrint("About to switch CPU to VLPR mode... ");
+		status = warpSetLowPowerMode(kWarpPowerModeVLPR, 0 /* Sleep Seconds */);
+		if ((status != kWarpStatusOK) && (status != kWarpStatusPowerTransitionErrorVlpr2Vlpr))
+		{
+			warpPrint("warpSetLowPowerMode(kWarpPowerModeVLPR() failed...\n");
+		}
+		warpPrint("done.\n\r");
+	}
+
+	/*
+	 *	Initialize the GPIO pins with the appropriate pull-up, etc.,
+	 *	defined in the inputPins and outputPins arrays (gpio_pins.c).
+	 *
+	 *	See also Section 30.3.3 GPIO Initialization of KSDK13APIRM.pdf
+	 */
+	warpPrint("About to GPIO_DRV_Init()... ");
+	GPIO_DRV_Init(inputPins  /* input pins */, outputPins  /* output pins */);
+	warpPrint("done.\n");
+
+	/*
+	 *	Make sure the SWD pins, PTA0/1/2 SWD pins in their ALT3 state (i.e., as SWD).
+	 *
+	 *	See GitHub issue https://github.com/physical-computation/Warp-firmware/issues/54
+	 */
+	PORT_HAL_SetMuxMode(PORTA_BASE, 0, kPortMuxAlt3);
+	PORT_HAL_SetMuxMode(PORTA_BASE, 1, kPortMuxAlt3);
+	PORT_HAL_SetMuxMode(PORTA_BASE, 2, kPortMuxAlt3);
+
+	/*
+	 *	Note that it is lowPowerPinStates() that sets the pin mux mode,
+	 *	so until we call it pins are in their default state.
+	 */
+	warpPrint("About to lowPowerPinStates()... ");
+	lowPowerPinStates();
+	warpPrint("done.\n");
+
+	/*
+	 *	Toggle LED3 (kWarpPinSI4705_nRST on Warp revB, kGlauxPinLED on Glaux)
+	 */
+	#if (WARP_BUILD_ENABLE_GLAUX_VARIANT)
+		blinkLED(kGlauxPinLED);
+		blinkLED(kGlauxPinLED);
+		blinkLED(kGlauxPinLED);
+
+		USED(disableTPS62740);
+		USED(enableTPS62740);
+		USED(setTPS62740CommonControlLines);
+	#endif
+
+	/*
+	 *	Initialize all the sensors
+	 */
+	#if (WARP_BUILD_ENABLE_DEVBMX055)
+		initBMX055accel(0x18	/* i2cAddress */,	&deviceBMX055accelState,	kWarpDefaultSupplyVoltageMillivoltsBMX055accel	);
+		initBMX055gyro(	0x68	/* i2cAddress */,	&deviceBMX055gyroState,		kWarpDefaultSupplyVoltageMillivoltsBMX055gyro	);
+		initBMX055mag(	0x10	/* i2cAddress */,	&deviceBMX055magState,		kWarpDefaultSupplyVoltageMillivoltsBMX055mag	);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVMMA8451Q)
+//		initMMA8451Q(	0x1C	/* i2cAddress */,	&deviceMMA8451QState,		kWarpDefaultSupplyVoltageMillivoltsMMA8451Q	);
+		initMMA8451Q(	0x1C	/* i2cAddress */,		kWarpDefaultSupplyVoltageMillivoltsMMA8451Q	);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVLPS25H)
+		initLPS25H(	0x5C	/* i2cAddress */,	&deviceLPS25HState,		kWarpDefaultSupplyVoltageMillivoltsLPS25H	);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVHDC1000)
+		initHDC1000(	0x43	/* i2cAddress */,	&deviceHDC1000State,		kWarpDefaultSupplyVoltageMillivoltsHDC1000	);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVMAG3110)
+		initMAG3110(	0x0E	/* i2cAddress */,	&deviceMAG3110State,		kWarpDefaultSupplyVoltageMillivoltsMAG3110	);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVSI7021)
+		initSI7021(	0x40	/* i2cAddress */,	&deviceSI7021State,		kWarpDefaultSupplyVoltageMillivoltsSI7021	);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVL3GD20H)
+		initL3GD20H(	0x6A	/* i2cAddress */,	&deviceL3GD20HState,		kWarpDefaultSupplyVoltageMillivoltsL3GD20H	);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVBME680)
+//		initBME680(	0x77	/* i2cAddress */,	&deviceBME680State,		kWarpDefaultSupplyVoltageMillivoltsBME680	);
+		initBME680(	0x77	/* i2cAddress */,		kWarpDefaultSupplyVoltageMillivoltsBME680	);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVTCS34725)
+		initTCS34725(	0x29	/* i2cAddress */,	&deviceTCS34725State,		kWarpDefaultSupplyVoltageMillivoltsTCS34725	);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVSI4705)
+		initSI4705(	0x11	/* i2cAddress */,	&deviceSI4705State,		kWarpDefaultSupplyVoltageMillivoltsSI4705	);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVCCS811)
+		initCCS811(	0x5A	/* i2cAddress */,	&deviceCCS811State,		kWarpDefaultSupplyVoltageMillivoltsCCS811	);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVAMG8834)
+		initAMG8834(	0x68	/* i2cAddress */,	&deviceAMG8834State,		kWarpDefaultSupplyVoltageMillivoltsAMG8834	);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVAS7262)
+		initAS7262(	0x49	/* i2cAddress */,	&deviceAS7262State,		kWarpDefaultSupplyVoltageMillivoltsAS7262	);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVAS7263)
+		initAS7263(	0x49	/* i2cAddress */,	&deviceAS7263State,		kWarpDefaultSupplyVoltageMillivoltsAS7263	);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVRV8803C7)
+		initRV8803C7(	0x32	/* i2cAddress */,					kWarpDefaultSupplyVoltageMillivoltsRV8803C7	);
+		status = setRTCCountdownRV8803C7(0 /* countdown */, kWarpRV8803ExtTD_1HZ /* frequency */, false /* interupt_enable */);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("setRTCCountdownRV8803C7() failed...\n");
+		}
+		else
+		{
+			warpPrint("setRTCCountdownRV8803C7() succeeded.\n");
+		}
+
+		/*
+		 *	Set the CLKOUT frequency to 1Hz, to reduce CV^2 power on the CLKOUT pin.
+		 *	See RV-8803-C7_App-Manual.pdf section 3.6 (register is 0Dh)
+		 */
+		uint8_t	extReg;
+		status = readRTCRegisterRV8803C7(kWarpRV8803RegExt, &extReg);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("readRTCRegisterRV8803C7() failed...\n");
+		}
+		else
+		{
+			warpPrint("readRTCRegisterRV8803C7() succeeded.\n");
+		}
+
+		/*
+		 *	Set bits 3:2 (FD) to 10 (1Hz CLKOUT)
+		 */
+		extReg &= 0b11110011;
+		extReg |= 0b00001000;
+		status = writeRTCRegisterRV8803C7(kWarpRV8803RegExt, extReg);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("writeRTCRegisterRV8803C7() failed...\n");
+		}
+		else
+		{
+			warpPrint("writeRTCRegisterRV8803C7() succeeded.\n");
+		}
+	#endif
+
+	/*
+	 *	Initialization: Devices hanging off SPI
+	 */
+
+	#if (WARP_BUILD_ENABLE_DEVADXL362)
+		/*
+		 *	Only supported in main Warp variant.
+		 */
+		initADXL362(kWarpPinADXL362_SPI_nCS,						kWarpDefaultSupplyVoltageMillivoltsADXL362	);
+
+		status = readSensorRegisterADXL362(kWarpSensorConfigurationRegisterADXL362DEVID_AD, 1);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("ADXL362: SPI transaction to read DEVID_AD failed...\n");
+		}
+		else
+		{
+			warpPrint("ADXL362: DEVID_AD = [0x%02X].\n", deviceADXL362State.spiSinkBuffer[2]);
+		}
+
+		status = readSensorRegisterADXL362(kWarpSensorConfigurationRegisterADXL362DEVID_MST, 1);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("ADXL362: SPI transaction to read DEVID_MST failed...\n");
+		}
+		else
+		{
+			warpPrint("ADXL362: DEVID_MST = [0x%02X].\n", deviceADXL362State.spiSinkBuffer[2]);
+		}
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVIS25xP && WARP_BUILD_ENABLE_GLAUX_VARIANT)
+		/*
+		 *	Only supported in Glaux.
+		 */
+		initIS25xP(kGlauxPinFlash_SPI_nCS,						kWarpDefaultSupplyVoltageMillivoltsIS25xP	);
+
+		uint8_t	ops1[] = {0x9F /* op0 */,  0x00 /* op1 */,  0x00 /* op2 */, 0x00 /* op3 */, 0x00 /* op4 */};
+		status = spiTransactionIS25xP(ops1, sizeof(ops1)/sizeof(uint8_t) /* opCount */);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("IS25xP: SPI transaction to read JEDEC ID failed...\n");
+		}
+		else
+		{
+			warpPrint("IS25xP JEDEC ID = [0x%X] [0x%X] [0x%X]\n", deviceIS25xPState.spiSinkBuffer[1], deviceIS25xPState.spiSinkBuffer[2], deviceIS25xPState.spiSinkBuffer[3]);
+		}
+
+		uint8_t	ops2[] = {0x90 /* op0 */,  0x00 /* op1 */,  0x00 /* op2 */, 0x00 /* op3 */, 0x00 /* op4 */};
+		status = spiTransactionIS25xP(ops2, sizeof(ops2)/sizeof(uint8_t) /* opCount */);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("IS25xP: SPI transaction to read Manufacturer ID failed...\n");
+		}
+		else
+		{
+			warpPrint("IS25xP Manufacturer ID = [0x%X] [0x%X] [0x%X]\n", deviceIS25xPState.spiSinkBuffer[3], deviceIS25xPState.spiSinkBuffer[4], deviceIS25xPState.spiSinkBuffer[5]);
+		}
+
+		uint8_t	ops3[] = {0xAB /* op0 */,  0x00 /* op1 */,  0x00 /* op2 */, 0x00 /* op3 */, 0x00 /* op4 */};
+		status = spiTransactionIS25xP(ops3, sizeof(ops3)/sizeof(uint8_t) /* opCount */);
+				if (status != kWarpStatusOK)
+		{
+			warpPrint("IS25xP: SPI transaction to read Flash ID failed...\n");
+		}
+		else
+		{
+			warpPrint("IS25xP Flash ID = [0x%X]\n", deviceIS25xPState.spiSinkBuffer[4]);
+		}
+		
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVISL23415)
+		/*
+		 *	Only supported in main Warp variant.
+		 */
+		initISL23415(kWarpPinISL23415_SPI_nCS, kWarpDefaultSupplyVoltageMillivoltsISL23415);
+
+		/*
+		 *	Take the DCPs out of shutdown by setting the SHDN bit in the ACR register
+		 */
+		status = writeDeviceRegisterISL23415(kWarpSensorConfigurationRegisterISL23415ACRwriteInstruction, 0x40);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("ISL23415: SPI transaction to write ACR failed...\n");
+		}
+
+		status = readDeviceRegisterISL23415(kWarpSensorConfigurationRegisterISL23415ACRreadInstruction);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("ISL23415: SPI transaction to read ACR failed...\n");
+		}
+		else
+		{
+			warpPrint("ISL23415 ACR=[0x%02X], ", deviceISL23415State.spiSinkBuffer[3]);
+		}
+
+		status = readDeviceRegisterISL23415(kWarpSensorConfigurationRegisterISL23415WRreadInstruction);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("ISL23415: SPI transaction to read WR failed...\n");
+		}
+		else
+		{
+			warpPrint("WR=[0x%02X]\n", deviceISL23415State.spiSinkBuffer[3]);
+		}
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVAT45DB)
+		/*
+		 *	Only supported in main Warp variant.
+		 */
+		initAT45DB(kWarpPinAT45DB_SPI_nCS,						kWarpDefaultSupplyVoltageMillivoltsAT45DB	);
+
+		status = spiTransactionAT45DB(&deviceAT45DBState, (uint8_t *)"\x9F\x00\x00\x00\x00\x00", 6 /* opCount */);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("AT45DB: SPI transaction to read Manufacturer ID failed...\n");
+		}
+		else
+		{
+			warpPrint("AT45DB Manufacturer ID=[0x%02X], Device ID=[0x%02X 0x%02X], Extended Device Information=[0x%02X 0x%02X]\n",
+						deviceAT45DBState.spiSinkBuffer[1],
+						deviceAT45DBState.spiSinkBuffer[2], deviceAT45DBState.spiSinkBuffer[3],
+						deviceAT45DBState.spiSinkBuffer[4], deviceAT45DBState.spiSinkBuffer[5]);
+		}
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVICE40)
+		/*
+		 *	Only supported in main Warp variant.
+		 */
+		initICE40(kWarpPinFPGA_nCS,							kWarpDefaultSupplyVoltageMillivoltsICE40	);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVBGX)
+		warpPrint("Configuring BGX Bluetooth.\n");
+		warpPrint("Enabling UART... ");
+		enableLPUARTpins();
+		warpPrint("done.\n");
+		warpPrint("initBGX()... ");
+		initBGX(kWarpDefaultSupplyVoltageMillivoltsBGX);
+		warpPrint("done.\n");
+	#endif
+
+	/*
+	 *	If WARP_BUILD_DISABLE_SUPPLIES_BY_DEFAULT, will turn of the supplies
+	 *	below which also means that the console via BLE will be disabled as
+	 *	the BLE module will be turned off by default.
+	 */
+	#if (WARP_BUILD_DISABLE_SUPPLIES_BY_DEFAULT)
+		/*
+		*	Make sure sensor supplies are off.
+		*
+		*	(There's no point in calling activateAllLowPowerSensorModes())
+		*/
+		warpPrint("Disabling sensor supply... \n");
+		warpDisableSupplyVoltage();
+		warpPrint("done.\n");
+	#endif
+
+	/*
+	 *	At this point, we consider the system "booted" and, e.g., warpPrint()s
+	 *	will also be sent to the BLE if that is compiled in.
+	 */
+	gWarpBooted = true;
+	warpPrint("Boot done.\n");
+
+	#if (WARP_BUILD_BOOT_TO_CSVSTREAM)
+		printBootSplash(gWarpCurrentSupplyVoltage, menuRegisterAddress, &powerManagerCallbackStructure);
+
+		/*
+		 *	Force to printAllSensors
+		 */
+		gWarpI2cBaudRateKbps = 300;
+
+		if (!WARP_BUILD_BOOT_TO_VLPR)
+		{
+			status = warpSetLowPowerMode(kWarpPowerModeRUN, 0 /* sleep seconds : irrelevant here */);
+			if (status != kWarpStatusOK)
+			{
+				warpPrint("warpSetLowPowerMode(kWarpPowerModeRUN, 0 /* sleep seconds : irrelevant here */)() failed...\n");
+			}
+		}
+
+		warpScaleSupplyVoltage(3300);
+		printAllSensors(true /* printHeadersAndCalibration */, true /* hexModeFlag */, 0 /* menuDelayBetweenEachRun */, true /* loopForever */);
+		/*
+		 *	Notreached
+		 */
+	#endif
+
+	#if (WARP_BUILD_ENABLE_GLAUX_VARIANT)
+		printBootSplash(gWarpCurrentSupplyVoltage, menuRegisterAddress, &powerManagerCallbackStructure);
+
+		#if (WARP_BUILD_ENABLE_DEVIS25xP)
+			warpPrint("About to read IS25xP JEDEC ID...\n");
+			//spiTransactionIS25xP({0x9F /* op0 */,  0x00 /* op1 */,  0x00 /* op2 */, 0x00 /* op3 */, 0x00 /* op4 */, 0x00 /* op5 */, 0x00 /* op6 */}, 5 /* opCount */);
+			warpPrint("IS25xP JEDEC ID = [0x%X] [0x%X] [0x%X]\n", deviceIS25xPState.spiSinkBuffer[1], deviceIS25xPState.spiSinkBuffer[2], deviceIS25xPState.spiSinkBuffer[3]);
+
+			warpPrint("About to read IS25xP Manufacturer ID...\n");
+			//spiTransactionIS25xP({0x90 /* op0 */,  0x00 /* op1 */,  0x00 /* op2 */, 0x00 /* op3 */, 0x00 /* op4 */, 0x00 /* op5 */, 0x00 /* op6 */}, 5 /* opCount */);
+			warpPrint("IS25xP Manufacturer ID = [0x%X] [0x%X] [0x%X]\n", deviceIS25xPState.spiSinkBuffer[3], deviceIS25xPState.spiSinkBuffer[4], deviceIS25xPState.spiSinkBuffer[5]);
+
+			warpPrint("About to read IS25xP Flash ID (also releases low-power mode)...\n");
+			//spiTransactionIS25xP({0xAB /* op0 */,  0x00 /* op1 */,  0x00 /* op2 */, 0x00 /* op3 */, 0x00 /* op4 */, 0x00 /* op5 */, 0x00 /* op6 */}, 5 /* opCount */);
+			warpPrint("IS25xP Flash ID = [0x%X]\n", deviceIS25xPState.spiSinkBuffer[4]);
+		#endif
+
+		warpPrint("About to activate low-power modes (including IS25xP Flash)...\n");
+		activateAllLowPowerSensorModes(true /* verbose */);
+
+		uint8_t	tmpRV8803RegisterByte;
+		status = readRTCRegisterRV8803C7(kWarpRV8803RegSec, &tmpRV8803RegisterByte);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("readRTCRegisterRV8803C7(kWarpRV8803RegSec, &tmpRV8803RegisterByte) failed\n");
+		}
+		else
+		{
+			warpPrint("kWarpRV8803RegSec = [0x%X]\n", tmpRV8803RegisterByte);
+		}
+
+		status = readRTCRegisterRV8803C7(kWarpRV8803RegMin, &tmpRV8803RegisterByte);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("readRTCRegisterRV8803C7(kWarpRV8803RegMin, &tmpRV8803RegisterByte) failed\n");
+		}
+		else
+		{
+			warpPrint("kWarpRV8803RegMin = [0x%X]\n", tmpRV8803RegisterByte);
+		}
+
+		status = readRTCRegisterRV8803C7(kWarpRV8803RegHour, &tmpRV8803RegisterByte);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("readRTCRegisterRV8803C7(kWarpRV8803RegHour, &tmpRV8803RegisterByte) failed\n");
+		}
+		else
+		{
+			warpPrint("kWarpRV8803RegHour = [0x%X]\n", tmpRV8803RegisterByte);
+		}
+
+		status = readRTCRegisterRV8803C7(kWarpRV8803RegExt, &tmpRV8803RegisterByte);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("readRTCRegisterRV8803C7(kWarpRV8803RegExt, &tmpRV8803RegisterByte) failed\n");
+		}
+		else
+		{
+			warpPrint("kWarpRV8803RegExt = [0x%X]\n", tmpRV8803RegisterByte);
+		}
+
+		status = readRTCRegisterRV8803C7(kWarpRV8803RegFlag, &tmpRV8803RegisterByte);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("readRTCRegisterRV8803C7(kWarpRV8803RegFlag, &tmpRV8803RegisterByte) failed\n");
+		}
+		else
+		{
+			warpPrint("kWarpRV8803RegFlag = [0x%X]\n", tmpRV8803RegisterByte);
+		}
+
+		status = readRTCRegisterRV8803C7(kWarpRV8803RegCtrl, &tmpRV8803RegisterByte);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("readRTCRegisterRV8803C7(kWarpRV8803RegCtrl, &tmpRV8803RegisterByte) failed\n");
+		}
+		else
+		{
+			warpPrint("kWarpRV8803RegCtrl = [0x%X]\n", tmpRV8803RegisterByte);
+		}
+
+		warpPrint("About to configureSensorBME680() for measurement...\n");
+		status = configureSensorBME680(	0b00000001,	/*	payloadCtrl_Hum: Humidity oversampling (OSRS) to 1x				*/
+						0b00100100,	/*	payloadCtrl_Meas: Temperature oversample 1x, pressure overdsample 1x, mode 00	*/
+						0b00001000	/*	payloadGas_0: Turn off heater							*/
+						);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("configureSensorBME680() failed...\n");
+		}
+
+		warpDisableI2Cpins();
+
+		warpPrint("About to loop with printSensorDataBME680()...\n");
+		while (1)
+		{
+			blinkLED(kGlauxPinLED);
+			for (int i = 0; i < kGlauxSensorRepetitionsPerSleepIteration; i++)
+			{
+				printAllSensors(true /* printHeadersAndCalibration */, true /* hexModeFlag */, 0 /* menuDelayBetweenEachRun */, true /* loopForever */);
+			}
+
+			warpPrint("About to configureSensorBME680() for sleep...\n");
+			status = configureSensorBME680(	0b00000000,	/*	payloadCtrl_Hum: Sleep							*/
+							0b00000000,	/*	payloadCtrl_Meas: No temperature samples, no pressure samples, sleep	*/
+							0b00001000	/*	payloadGas_0: Turn off heater						*/
+						);
+			if (status != kWarpStatusOK)
+			{
+				warpPrint("configureSensorBME680() failed...\n");
+			}
+			warpDisableI2Cpins();
+			blinkLED(kGlauxPinLED);
+
+			warpPrint("About to go into VLLS0 for 30 (was 60*60) seconds (will reset afterwords)...\n");
+			status = warpSetLowPowerMode(kWarpPowerModeVLLS0, kGlauxSleepSecondsBetweenSensorRepetitions /* sleep seconds */);
+			if (status != kWarpStatusOK)
+			{
+				warpPrint("warpSetLowPowerMode(kWarpPowerModeVLLS0, 10)() failed...\n");
+			}
+			warpPrint("Should not get here...");
+		}
+	#endif
+
+	while (1)
+	{
+		/*
+		 *	Do not, e.g., lowPowerPinStates() on each iteration, because we actually
+		 *	want to use menu to progressiveley change the machine state with various
+		 *	commands.
+		 */
+		printBootSplash(gWarpCurrentSupplyVoltage, menuRegisterAddress, &powerManagerCallbackStructure);
+
+		warpPrint("\rSelect:\n");
+		warpPrint("\r- 'a': set default sensor.\n");
+		warpPrint("\r- 'b': set I2C baud rate.\n");
+		warpPrint("\r- 'c': set SPI baud rate.\n");
+		warpPrint("\r- 'd': set UART baud rate.\n");
+		warpPrint("\r- 'e': set default register address.\n");
+		warpPrint("\r- 'f': write byte to sensor.\n");
+		warpPrint("\r- 'g': set default sensor supply voltage.\n");
+		warpPrint("\r- 'h': powerdown command to all sensors.\n");
+		warpPrint("\r- 'i': set pull-up enable value.\n");
+		warpPrint("\r- 'j': repeat read reg 0x%02x on sensor #%d.\n", menuRegisterAddress, menuTargetSensor);
+		warpPrint("\r- 'k': sleep until reset.\n");
+		warpPrint("\r- 'l': send repeated byte on I2C.\n");
+		warpPrint("\r- 'm': send repeated byte on SPI.\n");
+		warpPrint("\r- 'n': enable sensor supply voltage.\n");
+		warpPrint("\r- 'o': disable sensor supply voltage.\n");
+		warpPrint("\r- 'p': switch to VLPR mode.\n");
+		warpPrint("\r- 'r': switch to RUN mode.\n");
+		warpPrint("\r- 's': power up all sensors.\n");
+		warpPrint("\r- 't': dump processor state.\n");
+		warpPrint("\r- 'u': set I2C address.\n");
+
+		#if (WARP_BUILD_ENABLE_DEVAT45DB)
+			warpPrint("\r- 'R': read bytes from Flash.\n");
+			warpPrint("\r- 'F': write bytes to Flash.\n");
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVICE40)
+			warpPrint("\r- 'P': write bytes to FPGA configuration.\n");
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVRV8803C7)
+			warpPrint("\r- 'v': Enter VLLS0 low-power mode for 3s, then reset\n");
+		#endif
+
+		warpPrint("\r- 'x': disable SWD and spin for 10 secs.\n");
+		warpPrint("\r- 'z': perpetually dump all sensor data.\n");
+
+		warpPrint("\rEnter selection> ");
+		key = warpWaitKey();
+
+		switch (key)
+		{
+			/*
+			 *		Select sensor
+			 */
+			case 'a':
+			{
+				warpPrint("\r\tSelect:\n");
+
+				#if (WARP_BUILD_ENABLE_DEVADXL362)
+					warpPrint("\r\t- '1' ADXL362			(0x00--0x2D): 1.6V -- 3.5V\n");
+				#else
+					warpPrint("\r\t- '1' ADXL362			(0x00--0x2D): 1.6V -- 3.5V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVBMX055)
+					warpPrint("\r\t- '2' BMX055accel		(0x00--0x3F): 2.4V -- 3.6V\n");
+					warpPrint("\r\t- '3' BMX055gyro		(0x00--0x3F): 2.4V -- 3.6V\n");
+					warpPrint("\r\t- '4' BMX055mag			(0x40--0x52): 2.4V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- '2' BMX055accel 		(0x00--0x3F): 2.4V -- 3.6V (compiled out) \n");
+					warpPrint("\r\t- '3' BMX055gyro			(0x00--0x3F): 2.4V -- 3.6V (compiled out) \n");
+					warpPrint("\r\t- '4' BMX055mag			(0x40--0x52): 2.4V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVMMA8451Q)
+					warpPrint("\r\t- '5' MMA8451Q			(0x00--0x31): 1.95V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- '5' MMA8451Q			(0x00--0x31): 1.95V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVLPS25H)
+					warpPrint("\r\t- '6' LPS25H			(0x08--0x24): 1.7V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- '6' LPS25H			(0x08--0x24): 1.7V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVMAG3110)
+					warpPrint("\r\t- '7' MAG3110			(0x00--0x11): 1.95V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- '7' MAG3110			(0x00--0x11): 1.95V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVHDC1000)
+					warpPrint("\r\t- '8' HDC1000			(0x00--0x1F): 3.0V -- 5.0V\n");
+				#else
+					warpPrint("\r\t- '8' HDC1000			(0x00--0x1F): 3.0V -- 5.0V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVSI7021)
+					warpPrint("\r\t- '9' SI7021			(0x00--0x0F): 1.9V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- '9' SI7021			(0x00--0x0F): 1.9V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVL3GD20H)
+					warpPrint("\r\t- 'a' L3GD20H			(0x0F--0x39): 2.2V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- 'a' L3GD20H			(0x0F--0x39): 2.2V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVBME680)
+					warpPrint("\r\t- 'b' BME680			(0xAA--0xF8): 1.6V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- 'b' BME680			(0xAA--0xF8): 1.6V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVTCS34725)
+					warpPrint("\r\t- 'd' TCS34725			(0x00--0x1D): 2.7V -- 3.3V\n");
+				#else
+					warpPrint("\r\t- 'd' TCS34725			(0x00--0x1D): 2.7V -- 3.3V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVSI4705)
+					warpPrint("\r\t- 'e' SI4705			(n/a):        2.7V -- 5.5V\n");
+				#else
+					warpPrint("\r\t- 'e' SI4705			(n/a):        2.7V -- 5.5V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVCCS811)
+					warpPrint("\r\t- 'g' CCS811			(0x00--0xFF): 1.8V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- 'g' CCS811			(0x00--0xFF): 1.8V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVAMG8834)
+					warpPrint("\r\t- 'h' AMG8834			(0x00--?): 3.3V -- 3.3V\n");
+				#else
+					warpPrint("\r\t- 'h' AMG8834			(0x00--?): 3.3V -- 3.3V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVAS7262)
+					warpPrint("\r\t- 'j' AS7262			(0x00--0x2B): 2.7V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- 'j' AS7262			(0x00--0x2B): 2.7V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVAS7263)
+					warpPrint("\r\t- 'k' AS7263			(0x00--0x2B): 2.7V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- 'k' AS7263			(0x00--0x2B): 2.7V -- 3.6V (compiled out) \n");
+				#endif
+
+				warpPrint("\r\tEnter selection> ");
+				key = warpWaitKey();
+
+				switch(key)
+				{
+					#if (WARP_BUILD_ENABLE_DEVADXL362)
+						case '1':
+						{
+							menuTargetSensor = kWarpSensorADXL362;
+
+							break;
+						}
+					#endif
+
+					#if (WARP_BUILD_ENABLE_DEVBMX055)
+						case '2':
+						{
+							menuTargetSensor = kWarpSensorBMX055accel;
+							menuI2cDevice = &deviceBMX055accelState;
+							break;
+						}
+					#endif
+
+					#if (WARP_BUILD_ENABLE_DEVBMX055)
+						case '3':
+						{
+							menuTargetSensor = kWarpSensorBMX055gyro;
+							menuI2cDevice = &deviceBMX055gyroState;
+							break;
+						}
+					#endif
+
+					#if (WARP_BUILD_ENABLE_DEVBMX055)
+						case '4':
+						{
+							menuTargetSensor = kWarpSensorBMX055mag;
+							menuI2cDevice = &deviceBMX055magState;
+							break;
+						}
+					#endif
+
+					#if (WARP_BUILD_ENABLE_DEVMMA8451Q)
+						case '5':
+						{
+							menuTargetSensor = kWarpSensorMMA8451Q;
+							menuI2cDevice = &deviceMMA8451QState;
+							break;
+						}
+					#endif
+
+					#if (WARP_BUILD_ENABLE_DEVLPS25H)
+						case '6':
+						{
+							menuTargetSensor = kWarpSensorLPS25H;
+							menuI2cDevice = &deviceLPS25HState;
+							break;
+						}
+					#endif
+
+					#if (WARP_BUILD_ENABLE_DEVMAG3110)
+						case '7':
+						{
+							menuTargetSensor = kWarpSensorMAG3110;
+							menuI2cDevice = &deviceMAG3110State;
+							break;
+						}
+					#endif
+
+					#if (WARP_BUILD_ENABLE_DEVHDC1000)
+						case '8':
+						{
+							menuTargetSensor = kWarpSensorHDC1000;
+							menuI2cDevice = &deviceHDC1000State;
+							break;
+						}
+					#endif
+
+#if (WARP_BUILD_ENABLE_DEVSI7021)
+					case '9':
+					{
+						menuTargetSensor = kWarpSensorSI7021;
+						menuI2cDevice = &deviceSI7021State;
+						break;
+					}
+#endif
+#if (WARP_BUILD_ENABLE_DEVL3GD20H)
+					case 'a':
+					{
+						menuTargetSensor = kWarpSensorL3GD20H;
+						menuI2cDevice = &deviceL3GD20HState;
+						break;
+					}
+#endif
+#if (WARP_BUILD_ENABLE_DEVBME680)
+					case 'b':
+					{
+						menuTargetSensor = kWarpSensorBME680;
+						menuI2cDevice = &deviceBME680State;
+						break;
+					}
+#endif
+#if (WARP_BUILD_ENABLE_DEVTCS34725)
+					case 'd':
+					{
+						menuTargetSensor = kWarpSensorTCS34725;
+						menuI2cDevice = &deviceTCS34725State;
+						break;
+					}
+#endif
+#if (WARP_BUILD_ENABLE_DEVSI4705)
+					case 'e':
+					{
+						menuTargetSensor = kWarpSensorSI4705;
+						menuI2cDevice = &deviceSI4705State;
+						break;
+					}
+#endif
+#if (WARP_BUILD_ENABLE_DEVCCS811)
+					case 'g':
+					{
+						menuTargetSensor = kWarpSensorCCS811;
+						menuI2cDevice = &deviceCCS811State;
+						break;
+					}
+#endif
+#if (WARP_BUILD_ENABLE_DEVAMG8834)
+					case 'h':
+					{
+						menuTargetSensor = kWarpSensorAMG8834;
+						menuI2cDevice = &deviceAMG8834State;
+						break;
+					}
+#endif
+#if (WARP_BUILD_ENABLE_DEVAS7262)
+					case 'j':
+					{
+						menuTargetSensor = kWarpSensorAS7262;
+						menuI2cDevice = &deviceAS7262State;
+						break;
+					}
+#endif
+#if (WARP_BUILD_ENABLE_DEVAS7263)
+					case 'k':
+					{
+						menuTargetSensor = kWarpSensorAS7263;
+						menuI2cDevice = &deviceAS7263State;
+						break;
+					}
+#endif
+					default:
+					{
+						warpPrint("\r\tInvalid selection '%c' !\n", key);
+					}
+				}
+
+				break;
+			}
+
+			/*
+			 *	Change default I2C baud rate
+			 */
+			case 'b':
+			{
+				warpPrint("\r\n\tSet I2C baud rate in kbps (e.g., '0001')> ");
+				gWarpI2cBaudRateKbps = read4digits();
+
+				/*
+				 *	Round 9999kbps to 10Mbps
+				 */
+				if (gWarpI2cBaudRateKbps == 9999)
+				{
+					gWarpI2cBaudRateKbps = 10000;
+				}
+
+				warpPrint("\r\n\tI2C baud rate set to %d kb/s", gWarpI2cBaudRateKbps);
+
+				break;
+			}
+
+			/*
+			 *	Change default SPI baud rate
+			 */
+			case 'c':
+			{
+				warpPrint("\r\n\tSet SPI baud rate in kbps (e.g., '0001')> ");
+				gWarpSpiBaudRateKbps = read4digits();
+
+				/*
+				 *	Round 9999kbps to 10Mbps
+				 */
+				if (gWarpSpiBaudRateKbps == 9999)
+				{
+					gWarpSpiBaudRateKbps = 10000;
+				}
+
+				warpPrint("\r\n\tSPI baud rate: %d kb/s", gWarpSpiBaudRateKbps);
+
+				break;
+			}
+
+			/*
+			 *	Change default UART baud rate
+			 */
+			case 'd':
+			{
+				warpPrint("\r\n\tSet UART baud rate in kbps (e.g., '0001')> ");
+				gWarpUartBaudRateBps = read4digits();
+				warpPrint("\r\n\tUART baud rate: %d kb/s", gWarpUartBaudRateBps);
+
+				break;
+			}
+
+			/*
+			 *	Set register address for subsequent operations
+			 */
+			case 'e':
+			{
+				warpPrint("\r\n\tEnter 2-nybble register hex address (e.g., '3e')> ");
+				menuRegisterAddress = readHexByte();
+				warpPrint("\r\n\tEntered [0x%02x].\n\n", menuRegisterAddress);
+
+				break;
+			}
+
+			/*
+			 *	Write byte to sensor
+			 */
+			case 'f':
+			{
+				uint8_t		i2cAddress, payloadByte[1], commandByte[1];
+				i2c_status_t	i2cStatus;
+				WarpStatus	status;
+
+
+				USED(status);
+				warpPrint("\r\n\tEnter I2C addr. (e.g., '0f') or '99' for SPI > ");
+				i2cAddress = readHexByte();
+				warpPrint("\r\n\tEntered [0x%02x].\n", i2cAddress);
+
+				warpPrint("\r\n\tEnter hex byte to send (e.g., '0f')> ");
+				payloadByte[0] = readHexByte();
+				warpPrint("\r\n\tEntered [0x%02x].\n", payloadByte[0]);
+
+				if (i2cAddress == 0x99)
+				{
+#if (WARP_BUILD_ENABLE_DEVADXL362)
+					warpPrint("\r\n\tWriting [0x%02x] to SPI register [0x%02x]...\n", payloadByte[0], menuRegisterAddress);
+					status = writeSensorRegisterADXL362(	0x0A			/*	command == write register	*/,
+										menuRegisterAddress,
+										payloadByte[0]		/*	writeValue			*/,
+										1			/*	numberOfBytes			*/
+									);
+					if (status != kWarpStatusOK)
+					{
+						warpPrint("\r\n\tSPI write failed, error %d.\n\n", status);
+					}
+					#else
+					warpPrint("\r\n\tSPI write failed. ADXL362 Disabled");
+#endif
+				}
+				else
+				{
+					i2c_device_t slave =
+					{
+						.address = i2cAddress,
+						.baudRate_kbps = gWarpI2cBaudRateKbps
+					};
+
+					warpScaleSupplyVoltage(gWarpCurrentSupplyVoltage);
+					warpEnableI2Cpins();
+
+					commandByte[0] = menuRegisterAddress;
+					i2cStatus = I2C_DRV_MasterSendDataBlocking(
+											0 /* I2C instance */,
+											&slave,
+											commandByte,
+											1,
+											payloadByte,
+											1,
+											gWarpI2cTimeoutMilliseconds);
+					if (i2cStatus != kStatus_I2C_Success)
+					{
+						warpPrint("\r\n\tI2C write failed, error %d.\n\n", i2cStatus);
+					}
+					warpDisableI2Cpins();
+				}
+
+				/*
+				 *	NOTE: do not disable the supply here, because we typically want to build on the effect of this register write command.
+				 */
+
+				break;
+			}
+
+			/*
+			 *	Configure default TPS62740 voltage
+			 */
+			case 'g':
+			{
+				warpPrint("\r\n\tOverride sensor supply voltage in mV (e.g., '1800')> ");
+				gWarpCurrentSupplyVoltage = read4digits();
+				warpPrint("\r\n\tOverride sensor supply voltage set to %d mV", gWarpCurrentSupplyVoltage);
+
+				break;
+			}
+
+			/*
+			 *	Activate low-power modes in all sensors.
+			 */
+			case 'h':
+			{
+				warpPrint("\r\n\tNOTE: First power sensors and enable I2C\n\n");
+				activateAllLowPowerSensorModes(true /* verbose */);
+
+				break;
+			}
+
+			/*
+			 *	Start repeated read
+			 */
+			case 'j':
+			{
+				bool		autoIncrement, chatty;
+				int		spinDelay, repetitionsPerAddress, chunkReadsPerAddress;
+				int		adaptiveSssupplyMaxMillivolts;
+				uint8_t		referenceByte;
+
+				warpPrint("\r\n\tAuto-increment from base address 0x%02x? ['0' | '1']> ", menuRegisterAddress);
+				autoIncrement = warpWaitKey() - '0';
+
+				warpPrint("\r\n\tChunk reads per address (e.g., '1')> ");
+				chunkReadsPerAddress = warpWaitKey() - '0';
+
+				warpPrint("\r\n\tChatty? ['0' | '1']> ");
+				chatty = warpWaitKey() - '0';
+
+				warpPrint("\r\n\tInter-operation spin delay in milliseconds (e.g., '0000')> ");
+				spinDelay = read4digits();
+
+				warpPrint("\r\n\tRepetitions per address (e.g., '0000')> ");
+				repetitionsPerAddress = read4digits();
+
+				warpPrint("\r\n\tMaximum voltage for adaptive supply (e.g., '0000')> ");
+				adaptiveSssupplyMaxMillivolts = read4digits();
+
+				warpPrint("\r\n\tReference byte for comparisons (e.g., '3e')> ");
+				referenceByte = readHexByte();
+
+				warpPrint("\r\n\tRepeating dev%d @ 0x%02x, reps=%d, pull=%d, delay=%dms:\n\n",
+					menuTargetSensor, menuRegisterAddress, repetitionsPerAddress, spinDelay);
+
+				repeatRegisterReadForDeviceAndAddress(	menuTargetSensor /*warpSensorDevice*/,
+									menuRegisterAddress /*baseAddress */,
+									autoIncrement /*autoIncrement*/,
+									chunkReadsPerAddress,
+									chatty,
+									spinDelay,
+									repetitionsPerAddress,
+									gWarpCurrentSupplyVoltage,
+									adaptiveSssupplyMaxMillivolts,
+									referenceByte
+								);
+
+				break;
+			}
+
+			/*
+			 *	Sleep for 30 seconds.
+			 */
+			case 'k':
+			{
+				warpPrint("\r\n\tSleeping until system reset...\n");
+				sleepUntilReset();
+
+				break;
+			}
+
+			/*
+			 *	Send repeated byte on I2C or SPI
+			 */
+			case 'l':
+			case 'm':
+			{
+				uint8_t		outBuffer[1];
+				int		repetitions;
+
+				warpPrint("\r\n\tNOTE: First power sensors and enable I2C\n\n");
+				warpPrint("\r\n\tByte to send (e.g., 'F0')> ");
+				outBuffer[0] = readHexByte();
+
+				warpPrint("\r\n\tRepetitions (e.g., '0000')> ");
+				repetitions = read4digits();
+
+				if (key == 'l')
+				{
+					warpPrint("\r\n\tSending %d repetitions of [0x%02x] on I2C, sensor supply voltage=%dmV\n\n",
+						repetitions, outBuffer[0], gWarpCurrentSupplyVoltage);
+					for (int i = 0; i < repetitions; i++)
+					{
+						writeByteToI2cDeviceRegister(0xFF, true /* sedCommandByte */, outBuffer[0] /* commandByte */, false /* sendPayloadByte */, 0 /* payloadByte */);
+					}
+				}
+				else
+				{
+					warpPrint("\r\n\tSending %d repetitions of [0x%02x] on SPI, sensor supply voltage=%dmV\n\n",
+						repetitions, outBuffer[0], gWarpCurrentSupplyVoltage);
+					for (int i = 0; i < repetitions; i++)
+					{
+						writeBytesToSpi(outBuffer /* payloadByte */, 1 /* payloadLength */);
+					}
+				}
+
+				break;
+			}
+
+
+			/*
+			 *	enable sensor supply voltage
+			 */
+			case 'n':
+			{
+				warpScaleSupplyVoltage(gWarpCurrentSupplyVoltage);
+				break;
+			}
+
+			/*
+			 *	disable SSSUPPLY
+			 */
+			case 'o':
+			{
+				warpDisableSupplyVoltage();
+				break;
+			}
+
+			/*
+			 *	Switch to VLPR
+			 */
+			case 'p':
+			{
+				status = warpSetLowPowerMode(kWarpPowerModeVLPR, 0 /* sleep seconds : irrelevant here */);
+				if ((status != kWarpStatusOK) && (status != kWarpStatusPowerTransitionErrorVlpr2Vlpr))
+				{
+					warpPrint("warpSetLowPowerMode(kWarpPowerModeVLPR, 0 /* sleep seconds : irrelevant here */)() failed...\n");
+				}
+
+				break;
+			}
+
+			/*
+			 *	Switch to RUN
+			 */
+			case 'r':
+			{
+				warpSetLowPowerMode(kWarpPowerModeRUN, 0 /* sleep seconds : irrelevant here */);
+				if (status != kWarpStatusOK)
+				{
+					warpPrint("warpSetLowPowerMode(kWarpPowerModeRUN, 0 /* sleep seconds : irrelevant here */)() failed...\n");
+				}
+
+				break;
+			}
+
+			/*
+			 *	Power up all sensors
+			 */
+			case 's':
+			{
+				warpPrint("\r\n\tNOTE: First power sensors and enable I2C\n\n");
+				powerupAllSensors();
+				break;
+			}
+
+			/*
+			 *	Dump processor state
+			 */
+			case 't':
+			{
+				dumpProcessorState();
+				break;
+			}
+
+			case 'u':
+			{
+				if (menuI2cDevice == NULL)
+				{
+					warpPrint("\r\n\tCannot set I2C address: First set the default I2C device.\n");
+				}
+				else
+				{
+					warpPrint("\r\n\tSet I2C address of the selected sensor(e.g., '1C')> ");
+					uint8_t address = readHexByte();
+					menuI2cDevice->i2cAddress = address;
+				}
+
+				break;
+			}
+#if (WARP_BUILD_ENABLE_DEVRV8803C7)
+			case 'v':
+			{
+				warpPrint("\r\n\tSleeping for 3 seconds, then resetting\n");
+				warpSetLowPowerMode(kWarpPowerModeVLLS0, 3 /* sleep seconds */);
+				if (status != kWarpStatusOK)
+				{
+					warpPrint("warpSetLowPowerMode(kWarpPowerModeVLLS0, 3 /* sleep seconds : irrelevant here */)() failed...\n");
+				}
+
+				warpPrint("\r\n\tThis should never happen...\n");
+
+				break;
+			}
+#endif
+			/*
+			 *	Simply spin for 10 seconds. Since the SWD pins should only be enabled when we are waiting for key at top of loop (or toggling after printf), during this time there should be no interference from the SWD.
+			 */
+			case 'x':
+			{
+				warpPrint("\r\n\tSpinning for 10 seconds...\n");
+				OSA_TimeDelay(10000);
+				warpPrint("\r\tDone.\n\n");
+
+				break;
+			}
+
+			/*
+			 *	Dump all the sensor data in one go
+			 */
+			case 'z':
+			{
+				bool		hexModeFlag;
+
+				warpPrint("\r\n\tHex or converted mode? ('h' or 'c')> ");
+				key = warpWaitKey();
+				hexModeFlag = (key == 'h' ? 1 : 0);
+
+				warpPrint("\r\n\tSet the time delay between each run in milliseconds (e.g., '1234')> ");
+				uint16_t	menuDelayBetweenEachRun = read4digits();
+				warpPrint("\r\n\tDelay between read batches set to %d milliseconds.\n\n", menuDelayBetweenEachRun);
+				printAllSensors(true /* printHeadersAndCalibration */, hexModeFlag, menuDelayBetweenEachRun, true /* loopForever */);
+
+				/*
+				 *	Not reached (printAllSensors() does not return)
+				 */
+				warpDisableI2Cpins();
+
+				break;
+			}
+
+			/*
+			 *	Read bytes from Flash and print as hex
+			 */
+			case 'R':
+			{
+				warpPrint("\r\n\tStart address (e.g., '0000')> ");
+				//xx = read4digits();
+
+				warpPrint("\r\n\tEnd address (e.g., '0000')> ");
+				//xx = read4digits();
+
+				break;
+			}
+
+			/*
+			 *	Write raw bytes read from console to Flash
+			 */
+			case 'F':
+			{
+				warpPrint("\r\n\tStart address (e.g., '0000')> ");
+				//xx = read4digits();
+
+				warpPrint("\r\n\tNumber of bytes to read from console (e.g., '0000')> ");
+				//xx = read4digits();
+
+				warpPrint("\r\n\tEnter [%d] raw bytes > ");
+
+				break;
+			}
+
+			/*
+			 *	Use data from Flash to program FPGA
+			 */
+			case 'P':
+			{
+				warpPrint("\r\n\tStart address (e.g., '0000')> ");
+				//xx = read4digits();
+
+				warpPrint("\r\n\tNumber of bytes to use (e.g., '0000')> ");
+				//xx = read4digits();
+
+				break;
+			}
+
+
+			/*
+			 *	Ignore naked returns.
+			 */
+			case '\n':
+			{
+				warpPrint("\r\tPayloads make rockets more than just fireworks.");
+				break;
+			}
+
+			default:
+			{
+				warpPrint("\r\tInvalid selection '%c' !\n", key);
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+
+void
+printAllSensors(bool printHeadersAndCalibration, bool hexModeFlag, int menuDelayBetweenEachRun, bool loopForever)
+{
+	/*
+	 *	A 32-bit counter gives us > 2 years of before it wraps, even if sampling at 60fps
+	 */
+	uint32_t	readingCount = 0;
+	uint32_t	numberOfConfigErrors = 0;
+
+
+	#if (WARP_BUILD_ENABLE_DEVAMG8834)
+	numberOfConfigErrors += configureSensorAMG8834(	0x3F,/* Initial reset */
+					0x01,/* Frame rate 1 FPS */
+					);
+	#endif
+	#if (WARP_BUILD_ENABLE_DEVMMA8451Q)
+	numberOfConfigErrors += configureSensorMMA8451Q(0x00,/* Payload: Disable FIFO */
+					0x01/* Normal read 8bit, 800Hz, normal, active mode */
+					);
+	#endif
+	#if (WARP_BUILD_ENABLE_DEVMAG3110)
+	numberOfConfigErrors += configureSensorMAG3110(	0x00,/*	Payload: DR 000, OS 00, 80Hz, ADC 1280, Full 16bit, standby mode to set up register*/
+					0xA0,/*	Payload: AUTO_MRST_EN enable, RAW value without offset */
+					);
+	#endif
+	#if (WARP_BUILD_ENABLE_DEVL3GD20H)
+	numberOfConfigErrors += configureSensorL3GD20H(	0b11111111,/* ODR 800Hz, Cut-off 100Hz, see table 21, normal mode, x,y,z enable */
+					0b00100000,
+					0b00000000/* normal mode, disable FIFO, disable high pass filter */
+					);
+	#endif
+	#if (WARP_BUILD_ENABLE_DEVBME680)
+	numberOfConfigErrors += configureSensorBME680(	0b00000001,	/*	payloadCtrl_Hum: Humidity oversampling (OSRS) to 1x				*/
+							0b00100100,	/*	payloadCtrl_Meas: Temperature oversample 1x, pressure overdsample 1x, mode 00	*/
+							0b00001000	/*	payloadGas_0: Turn off heater							*/
+					);
+
+	if (printHeadersAndCalibration)
+	{
+		warpPrint("\r\n\nBME680 Calibration Data: ");
+		for (uint8_t i = 0; i < kWarpSizesBME680CalibrationValuesCount; i++)
+		{
+			warpPrint("0x%02x", deviceBME680CalibrationValues[i]);
+			if (i < kWarpSizesBME680CalibrationValuesCount - 1)
+			{
+				warpPrint(", ");
+			}
+			else
+			{
+				warpPrint("\n\n");
+			}
+		}
+	}
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVHDC1000)
+	numberOfConfigErrors += writeSensorRegisterHDC1000(kWarpSensorConfigurationRegisterHDC1000Configuration,/* Configuration register	*/
+					(0b1010000<<8),
+					);
+	#endif
+
+	#if (WARP_BUILD_ENABLE_DEVCCS811)
+	uint8_t		payloadCCS811[1];
+	payloadCCS811[0] = 0b01000000;/* Constant power, measurement every 250ms */
+	numberOfConfigErrors += configureSensorCCS811(payloadCCS811,
+					);
+	#endif
+	#if (WARP_BUILD_ENABLE_DEVBMX055)
+	numberOfConfigErrors += configureSensorBMX055accel(0b00000011,/* Payload:+-2g range */
+					0b10000000,/* Payload:unfiltered data, shadowing enabled */
+					);
+	numberOfConfigErrors += configureSensorBMX055mag(0b00000001,/* Payload:from suspend mode to sleep mode*/
+					0b00000001,/* Default 10Hz data rate, forced mode*/
+					);
+	numberOfConfigErrors += configureSensorBMX055gyro(0b00000100,/* +- 125degrees/s */
+					0b00000000,/* ODR 2000 Hz, unfiltered */
+					0b00000000,/* normal mode */
+					0b10000000,/* unfiltered data, shadowing enabled */
+					);
+	#endif
+
+	if (printHeadersAndCalibration)
+	{
+		warpPrint("Measurement number, RTC->TSR, RTC->TPR,\t\t");
+
+		#if (WARP_BUILD_ENABLE_DEVADXL362)
+			warpPrint(" ADXL362 x, ADXL362 y, ADXL362 z,");
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVAMG8834)
+		for (uint8_t i = 0; i < 64; i++)
+		{
+			warpPrint(" AMG8834 %d,", i);
+		}
+		warpPrint(" AMG8834 Temp,");
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVMMA8451Q)
+			warpPrint(" MMA8451 x, MMA8451 y, MMA8451 z,");
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVMAG3110)
+			warpPrint(" MAG3110 x, MAG3110 y, MAG3110 z, MAG3110 Temp,");
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVL3GD20H)
+			warpPrint(" L3GD20H x, L3GD20H y, L3GD20H z, L3GD20H Temp,");
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVBME680)
+			warpPrint(" BME680 Press, BME680 Temp, BME680 Hum,");
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVBMX055)
+			warpPrint(" BMX055acc x, BMX055acc y, BMX055acc z, BMX055acc Temp,");
+			warpPrint(" BMX055mag x, BMX055mag y, BMX055mag z, BMX055mag RHALL,");
+			warpPrint(" BMX055gyro x, BMX055gyro y, BMX055gyro z,");
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVCCS811)
+			warpPrint(" CCS811 ECO2, CCS811 TVOC, CCS811 RAW ADC value,");
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVHDC1000)
+			warpPrint(" HDC1000 Temp, HDC1000 Hum,");
+		#endif
+
+		warpPrint(" RTC->TSR, RTC->TPR, # Config Errors");
+		warpPrint("\n\n");
+	}
+
+	do
+	{
+		warpPrint("%12u, %12d, %6d,\t\t", readingCount, RTC->TSR, RTC->TPR);
+
+		#if (WARP_BUILD_ENABLE_DEVADXL362)
+			printSensorDataADXL362(hexModeFlag);
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVAMG8834)
+			printSensorDataAMG8834(hexModeFlag);
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVMMA8451Q)
+			printSensorDataMMA8451Q(hexModeFlag);
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVMAG3110)
+			printSensorDataMAG3110(hexModeFlag);
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVL3GD20H)
+			printSensorDataL3GD20H(hexModeFlag);
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVBME680)
+			printSensorDataBME680(hexModeFlag);
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVBMX055)
+			printSensorDataBMX055accel(hexModeFlag);
+			printSensorDataBMX055mag(hexModeFlag);
+			printSensorDataBMX055gyro(hexModeFlag);
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVCCS811)
+			printSensorDataCCS811(hexModeFlag);
+		#endif
+
+		#if (WARP_BUILD_ENABLE_DEVHDC1000)
+			printSensorDataHDC1000(hexModeFlag);
+		#endif
+
+		warpPrint(" %12d, %6d, %2u\n", RTC->TSR, RTC->TPR, numberOfConfigErrors);
+
+		if (menuDelayBetweenEachRun > 0)
+		{
+			OSA_TimeDelay(menuDelayBetweenEachRun);
+		}
+
+		readingCount++;
+	} while (loopForever);
+}
+
+
+void
+loopForSensor(	const char *  tagString,
+		WarpStatus  (* readSensorRegisterFunction)(uint8_t deviceRegister, int numberOfBytes),
+		volatile WarpI2CDeviceState *  i2cDeviceState,
+		volatile WarpSPIDeviceState *  spiDeviceState,
+		uint8_t  baseAddress,
+		uint8_t  minAddress,
+		uint8_t  maxAddress,
+		int  repetitionsPerAddress,
+		int  chunkReadsPerAddress,
+		int  spinDelay,
+		bool  autoIncrement,
+		uint16_t  sssupplyMillivolts,
+		uint8_t  referenceByte,
+		uint16_t adaptiveSssupplyMaxMillivolts,
+		bool  chatty
+		)
+{
+	WarpStatus		status;
+	uint8_t			address = min(minAddress, baseAddress);
+	int			readCount = repetitionsPerAddress + 1;
+	int			nSuccesses = 0;
+	int			nFailures = 0;
+	int			nCorrects = 0;
+	int			nBadCommands = 0;
+	uint16_t		actualSssupplyMillivolts = sssupplyMillivolts;
+
+
+	if (	(!spiDeviceState && !i2cDeviceState) ||
+		(spiDeviceState && i2cDeviceState) )
+	{
+		warpPrint(RTT_CTRL_RESET RTT_CTRL_BG_BRIGHT_YELLOW RTT_CTRL_TEXT_BRIGHT_WHITE kWarpConstantStringErrorSanity RTT_CTRL_RESET "\n");
+	}
+
+	warpScaleSupplyVoltage(actualSssupplyMillivolts);
+	warpPrint(tagString);
+
+	/*
+	 *	Keep on repeating until we are above the maxAddress, or just once if not autoIncrement-ing
+	 *	This is checked for at the tail end of the loop.
+	 */
+	while (true)
+	{
+		for (int i = 0; i < readCount; i++) for (int j = 0; j < chunkReadsPerAddress; j++)
+		{
+			status = readSensorRegisterFunction(address+j, 1 /* numberOfBytes */);
+			if (status == kWarpStatusOK)
+			{
+				nSuccesses++;
+				if (actualSssupplyMillivolts > sssupplyMillivolts)
+				{
+					actualSssupplyMillivolts -= 100;
+					warpScaleSupplyVoltage(actualSssupplyMillivolts);
+				}
+
+				if (spiDeviceState)
+				{
+					if (referenceByte == spiDeviceState->spiSinkBuffer[2])
+					{
+						nCorrects++;
+					}
+
+					if (chatty)
+					{
+						warpPrint("\r\t0x%02x --> [0x%02x 0x%02x 0x%02x]\n",
+							address+j,
+							spiDeviceState->spiSinkBuffer[0],
+							spiDeviceState->spiSinkBuffer[1],
+							spiDeviceState->spiSinkBuffer[2]);
+					}
+				}
+				else
+				{
+					if (referenceByte == i2cDeviceState->i2cBuffer[0])
+					{
+						nCorrects++;
+					}
+
+					if (chatty)
+					{
+						warpPrint("\r\t0x%02x --> 0x%02x\n",
+							address+j,
+							i2cDeviceState->i2cBuffer[0]);
+					}
+				}
+			}
+			else if (status == kWarpStatusDeviceCommunicationFailed)
+			{
+				warpPrint("\r\t0x%02x --> ----\n",
+					address+j);
+
+				nFailures++;
+				if (actualSssupplyMillivolts < adaptiveSssupplyMaxMillivolts)
+				{
+					actualSssupplyMillivolts += 100;
+					warpScaleSupplyVoltage(actualSssupplyMillivolts);
+				}
+			}
+			else if (status == kWarpStatusBadDeviceCommand)
+			{
+				nBadCommands++;
+			}
+
+			if (spinDelay > 0)
+			{
+				OSA_TimeDelay(spinDelay);
+			}
+		}
+
+		if (autoIncrement)
+		{
+			address++;
+		}
+
+		if (address > maxAddress || !autoIncrement)
+		{
+			/*
+			 *	We either iterated over all possible addresses, or were asked to do only
+			 *	one address anyway (i.e. don't increment), so we're done.
+			 */
+			break;
+		}
+	}
+
+	/*
+	 *	We intersperse RTT_printfs with forced delays to allow us to use small
+	 *	print buffers even in RUN mode.
+	 */
+	warpPrint("\r\n\t%d/%d success rate.\n", nSuccesses, (nSuccesses + nFailures));
+	OSA_TimeDelay(50);
+	warpPrint("\r\t%d/%d successes matched ref. value of 0x%02x.\n", nCorrects, nSuccesses, referenceByte);
+	OSA_TimeDelay(50);
+	warpPrint("\r\t%d bad commands.\n\n", nBadCommands);
+	OSA_TimeDelay(50);
+
+
+	return;
+}
+
+
+
+void
+repeatRegisterReadForDeviceAndAddress(WarpSensorDevice warpSensorDevice, uint8_t baseAddress, bool autoIncrement, int chunkReadsPerAddress, bool chatty, int spinDelay, int repetitionsPerAddress, uint16_t sssupplyMillivolts, uint16_t adaptiveSssupplyMaxMillivolts, uint8_t referenceByte)
+{
+	switch (warpSensorDevice)
+	{
+		case kWarpSensorADXL362:
+		{
+			/*
+			 *	ADXL362: VDD 1.6--3.5
+			 */
+			#if (WARP_BUILD_ENABLE_DEVADXL362)
+				loopForSensor(	"\r\nADXL362:\n\r",		/*	tagString			*/
+						&readSensorRegisterADXL362,	/*	readSensorRegisterFunction	*/
+						NULL,				/*	i2cDeviceState			*/
+						&deviceADXL362State,		/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x00,				/*	minAddress			*/
+						0x2E,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\tADXL362 Read Aborted. Device Disabled :(");
+			#endif
+
+			break;
+		}
+
+		case kWarpSensorMMA8451Q:
+		{
+			/*
+			 *	MMA8451Q: VDD 1.95--3.6
+			 */
+			#if (WARP_BUILD_ENABLE_DEVMMA8451Q)
+				loopForSensor(	"\r\nMMA8451Q:\n\r",		/*	tagString			*/
+						&readSensorRegisterMMA8451Q,	/*	readSensorRegisterFunction	*/
+						&deviceMMA8451QState,		/*	i2cDeviceState			*/
+						NULL,				/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x00,				/*	minAddress			*/
+						0x31,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\tMMA8451Q Read Aborted. Device Disabled :(");
+			#endif
+
+			break;
+		}
+
+		case kWarpSensorBME680:
+		{
+			/*
+			 *	BME680: VDD 1.7--3.6
+			 */
+			#if (WARP_BUILD_ENABLE_DEVBME680)
+				loopForSensor(	"\r\nBME680:\n\r",		/*	tagString			*/
+						&readSensorRegisterBME680,	/*	readSensorRegisterFunction	*/
+						&deviceBME680State,		/*	i2cDeviceState			*/
+						NULL,				/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x1D,				/*	minAddress			*/
+						0x75,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\nBME680 Read Aborted. Device Disabled :(");
+			#endif
+
+			break;
+		}
+
+		case kWarpSensorBMX055accel:
+		{
+			/*
+			 *	BMX055accel: VDD 2.4V -- 3.6V
+			 */
+			#if (WARP_BUILD_ENABLE_DEVBMX055)
+				loopForSensor(	"\r\nBMX055accel:\n\r",		/*	tagString			*/
+						&readSensorRegisterBMX055accel,	/*	readSensorRegisterFunction	*/
+						&deviceBMX055accelState,	/*	i2cDeviceState			*/
+						NULL,				/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x00,				/*	minAddress			*/
+						0x39,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\tBMX055accel Read Aborted. Device Disabled :( ");
+			#endif
+
+			break;
+		}
+
+		case kWarpSensorBMX055gyro:
+		{
+			/*
+			 *	BMX055gyro: VDD 2.4V -- 3.6V
+			 */
+			#if (WARP_BUILD_ENABLE_DEVBMX055)
+				loopForSensor(	"\r\nBMX055gyro:\n\r",		/*	tagString			*/
+						&readSensorRegisterBMX055gyro,	/*	readSensorRegisterFunction	*/
+						&deviceBMX055gyroState,		/*	i2cDeviceState			*/
+						NULL,				/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x00,				/*	minAddress			*/
+						0x39,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\tBMX055gyro Read Aborted. Device Disabled :( ");
+			#endif
+
+			break;
+		}
+
+		case kWarpSensorBMX055mag:
+		{
+			/*
+			 *	BMX055mag: VDD 2.4V -- 3.6V
+			 */
+			#if WARP_BUILD_ENABLE_DEVBMX055
+				loopForSensor(	"\r\nBMX055mag:\n\r",		/*	tagString			*/
+						&readSensorRegisterBMX055mag,	/*	readSensorRegisterFunction	*/
+						&deviceBMX055magState,		/*	i2cDeviceState			*/
+						NULL,				/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x40,				/*	minAddress			*/
+						0x52,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\t BMX055mag Read Aborted. Device Disabled :( ");
+			#endif
+
+			break;
+		}
+
+		case kWarpSensorMAG3110:
+		{
+			/*
+			 *	MAG3110: VDD 1.95 -- 3.6
+			 */
+			#if (WARP_BUILD_ENABLE_DEVMAG3110)
+				loopForSensor(	"\r\nMAG3110:\n\r",		/*	tagString			*/
+						&readSensorRegisterMAG3110,	/*	readSensorRegisterFunction	*/
+						&deviceMAG3110State,		/*	i2cDeviceState			*/
+						NULL,				/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x00,				/*	minAddress			*/
+						0x11,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\tMAG3110 Read Aborted. Device Disabled :( ");
+			#endif
+
+			break;
+		}
+
+		case kWarpSensorL3GD20H:
+		{
+			/*
+			 *	L3GD20H: VDD 2.2V -- 3.6V
+			 */
+			#if (WARP_BUILD_ENABLE_DEVL3GD20H)
+				loopForSensor(	"\r\nL3GD20H:\n\r",		/*	tagString			*/
+						&readSensorRegisterL3GD20H,	/*	readSensorRegisterFunction	*/
+						&deviceL3GD20HState,		/*	i2cDeviceState			*/
+						NULL,				/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x0F,				/*	minAddress			*/
+						0x39,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\tL3GD20H Read Aborted. Device Disabled :( ");
+			#endif
+
+			break;
+		}
+
+		case kWarpSensorLPS25H:
+		{
+			/*
+			 *	LPS25H: VDD 1.7V -- 3.6V
+			 */
+			#if (WARP_BUILD_ENABLE_DEVLPS25H)
+				loopForSensor(	"\r\nLPS25H:\n\r",		/*	tagString			*/
+						&readSensorRegisterLPS25H,	/*	readSensorRegisterFunction	*/
+						&deviceLPS25HState,		/*	i2cDeviceState			*/
+						NULL,				/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x08,				/*	minAddress			*/
+						0x24,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\tLPS25H Read Aborted. Device Disabled :( ");
+			#endif
+
+			break;
+		}
+
+		case kWarpSensorTCS34725:
+		{
+			/*
+			 *	TCS34725: VDD 2.7V -- 3.3V
+			 */
+			#if WARP_BUILD_ENABLE_DEVTCS34725
+				loopForSensor(	"\r\nTCS34725:\n\r",		/*	tagString			*/
+						&readSensorRegisterTCS34725,	/*	readSensorRegisterFunction	*/
+						&deviceTCS34725State,		/*	i2cDeviceState			*/
+						NULL,				/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x00,				/*	minAddress			*/
+						0x1D,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\tTCS34725 Read Aborted. Device Disabled :( ");
+			#endif
+
+			break;
+		}
+
+		case kWarpSensorSI4705:
+		{
+			/*
+			 *	SI4705: VDD 2.7V -- 5.5V
+			 */
+			#if (WARP_BUILD_ENABLE_DEVSI4705)
+				loopForSensor(	"\r\nSI4705:\n\r",		/*	tagString			*/
+						&readSensorRegisterSI4705,	/*	readSensorRegisterFunction	*/
+						&deviceSI4705State,		/*	i2cDeviceState			*/
+						NULL,				/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x00,				/*	minAddress			*/
+						0x09,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\tSI4705 Read Aborted. Device Disabled :( ");
+			#endif
+
+			break;
+		}
+
+		case kWarpSensorHDC1000:
+		{
+			/*
+			 *	HDC1000: VDD 3V--5V
+			 */
+			#if (WARP_BUILD_ENABLE_DEVHDC1000)
+				loopForSensor(	"\r\nHDC1000:\n\r",		/*	tagString			*/
+						&readSensorRegisterHDC1000,	/*	readSensorRegisterFunction	*/
+						&deviceHDC1000State,		/*	i2cDeviceState			*/
+						NULL,				/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x00,				/*	minAddress			*/
+						0x1F,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\tHDC1000 Read Aborted. Device Disabled :( ");
+			#endif
+
+			break;
+		}
+
+		case kWarpSensorSI7021:
+		{
+			/*
+			 *	SI7021: VDD 1.9V -- 3.6V
+			 */
+			#if (WARP_BUILD_ENABLE_DEVSI7021)
+				loopForSensor(	"\r\nSI7021:\n\r",		/*	tagString			*/
+						&readSensorRegisterSI7021,	/*	readSensorRegisterFunction	*/
+						&deviceSI7021State,		/*	i2cDeviceState			*/
+						NULL,				/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x00,				/*	minAddress			*/
+						0x09,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\tSI7021 Read Aborted. Device Disabled :( ");
+			#endif
+
+			break;
+		}
+
+		case kWarpSensorCCS811:
+		{
+			/*
+			 *	CCS811: VDD 1.8V -- 3.6V
+			 */
+			#if (WARP_BUILD_ENABLE_DEVCCS811)
+				loopForSensor(	"\r\nCCS811:\n\r",		/*	tagString			*/
+						&readSensorRegisterCCS811,	/*	readSensorRegisterFunction	*/
+						&deviceCCS811State,		/*	i2cDeviceState			*/
+						NULL,				/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x00,				/*	minAddress			*/
+						0xFF,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\tCCS811 Read Aborted. Device Disabled :( ");
+			#endif
+
+			break;
+		}
+
+		case kWarpSensorAMG8834:
+		{
+			/*
+			 *	AMG8834: VDD 3.3V -- 3.3V
+			 */
+			#if WARP_BUILD_ENABLE_DEVAMG8834
+				loopForSensor(	"\r\nAMG8834:\n\r",		/*	tagString			*/
+						&readSensorRegisterAMG8834,	/*	readSensorRegisterFunction	*/
+						&deviceAMG8834State,		/*	i2cDeviceState			*/
+						NULL,				/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x00,				/*	minAddress			*/
+						0xFF,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\tAMG8834 Read Aborted. Device Disabled :( ");
+			#endif
+
+			break;
+		}
+
+		case kWarpSensorAS7262:
+		{
+			/*
+			 *	AS7262: VDD 2.7--3.6
+			 */
+			#if (WARP_BUILD_ENABLE_DEVAS7262)
+				loopForSensor(	"\r\nAS7262:\n\r",		/*	tagString			*/
+						&readSensorRegisterAS7262,	/*	readSensorRegisterFunction	*/
+						&deviceAS7262State,		/*	i2cDeviceState			*/
+						NULL,				/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x00,				/*	minAddress			*/
+						0x2B,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\tAS7262 Read Aborted. Device Disabled :( ");
+			#endif
+
+			break;
+		}
+
+		case kWarpSensorAS7263:
+		{
+			/*
+			 *	AS7263: VDD 2.7--3.6
+			 */
+			#if WARP_BUILD_ENABLE_DEVAS7263
+				loopForSensor(	"\r\nAS7263:\n\r",		/*	tagString			*/
+						&readSensorRegisterAS7263,	/*	readSensorRegisterFunction	*/
+						&deviceAS7263State,		/*	i2cDeviceState			*/
+						NULL,				/*	spiDeviceState			*/
+						baseAddress,			/*	baseAddress			*/
+						0x00,				/*	minAddress			*/
+						0x2B,				/*	maxAddress			*/
+						repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+						chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+						spinDelay,			/*	spinDelay			*/
+						autoIncrement,			/*	autoIncrement			*/
+						sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+						referenceByte,			/*	referenceByte			*/
+						adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+						chatty				/*	chatty				*/
+						);
+			#else
+				warpPrint("\r\n\tAS7263 Read Aborted. Device Disabled :( ");
+			#endif
+
+			break;
+		}
+
+		default:
+		{
+			warpPrint("\r\tInvalid warpSensorDevice [%d] passed to repeatRegisterReadForDeviceAndAddress.\n", warpSensorDevice);
+		}
+	}
+
+	if (warpSensorDevice != kWarpSensorADXL362)
+	{
+		warpDisableI2Cpins();
+	}
+}
+
+
+
+int
+char2int(int character)
+{
+	if (character >= '0' && character <= '9')
+	{
+		return character - '0';
+	}
+
+	if (character >= 'a' && character <= 'f')
+	{
+		return character - 'a' + 10;
+	}
+
+	if (character >= 'A' && character <= 'F')
+	{
+		return character - 'A' + 10;
+	}
+
+	return 0;
+}
+
+
+
+uint8_t
+readHexByte(void)
+{
+	uint8_t		topNybble, bottomNybble;
+
+	topNybble = warpWaitKey();
+	bottomNybble = warpWaitKey();
+
+	return (char2int(topNybble) << 4) + char2int(bottomNybble);
+}
+
+
+
+int
+read4digits(void)
+{
+	uint8_t		digit1, digit2, digit3, digit4;
+
+	digit1 = warpWaitKey();
+	digit2 = warpWaitKey();
+	digit3 = warpWaitKey();
+	digit4 = warpWaitKey();
+
+	return (digit1 - '0')*1000 + (digit2 - '0')*100 + (digit3 - '0')*10 + (digit4 - '0');
+}
+
+
+
+WarpStatus
+writeByteToI2cDeviceRegister(uint8_t i2cAddress, bool sendCommandByte, uint8_t commandByte, bool sendPayloadByte, uint8_t payloadByte)
+{
+	i2c_status_t	status;
+	uint8_t		commandBuffer[1];
+	uint8_t		payloadBuffer[1];
+	i2c_device_t	i2cSlaveConfig =
+			{
+				.address = i2cAddress,
+				.baudRate_kbps = gWarpI2cBaudRateKbps
+			};
+
+	commandBuffer[0] = commandByte;
+	payloadBuffer[0] = payloadByte;
+
+	status = I2C_DRV_MasterSendDataBlocking(
+						0	/* instance */,
+						&i2cSlaveConfig,
+						commandBuffer,
+						(sendCommandByte ? 1 : 0),
+						payloadBuffer,
+						(sendPayloadByte ? 1 : 0),
+						gWarpI2cTimeoutMilliseconds);
+
+	return (status == kStatus_I2C_Success ? kWarpStatusOK : kWarpStatusDeviceCommunicationFailed);
+}
+
+
+
+WarpStatus
+writeBytesToSpi(uint8_t *  payloadBytes, int payloadLength)
+{
+	uint8_t		inBuffer[payloadLength];
+	spi_status_t	status;
+
+	warpEnableSPIpins();
+	status = SPI_DRV_MasterTransferBlocking(0					/* master instance */,
+						NULL					/* spi_master_user_config_t */,
+						payloadBytes,
+						inBuffer,
+						payloadLength				/* transfer size */,
+						gWarpSpiTimeoutMicroseconds		/* timeout in microseconds (unlike I2C which is ms) */);
+	warpDisableSPIpins();
+
+	return (status == kStatus_SPI_Success ? kWarpStatusOK : kWarpStatusCommsError);
+}
+
+
+
+void
+powerupAllSensors(void)
+{
+	/*
+	 *	BMX055mag
+	 *
+	 *	Write '1' to power control bit of register 0x4B. See page 134.
+	 */
+	#if (WARP_BUILD_ENABLE_DEVBMX055)
+		WarpStatus	status = writeByteToI2cDeviceRegister(	deviceBMX055magState.i2cAddress		/*	i2cAddress		*/,
+							true					/*	sendCommandByte		*/,
+							0x4B					/*	commandByte		*/,
+							true					/*	sendPayloadByte		*/,
+							(1 << 0)				/*	payloadByte		*/);
+		if (status != kWarpStatusOK)
+		{
+			warpPrint("\r\tPowerup command failed, code=%d, for BMX055mag @ 0x%02x.\n", status, deviceBMX055magState.i2cAddress);
+		}
+	#else
+		warpPrint("\r\tPowerup command failed. BMX055 disabled \n");
+	#endif
+}
+
+
+
+void
+activateAllLowPowerSensorModes(bool verbose)
+{
+	/*
+	 *	ADXL362:	See Power Control Register (Address: 0x2D, Reset: 0x00).
+	 *
+	 *	POR values are OK.
+	 */
+
+	/*
+	 *	IS25XP:	Put in powerdown momde
+	 */
+	#if (WARP_BUILD_ENABLE_DEVIS25xP)
+		/*
+		 *	Put the Flash in deep power-down
+		 */
+		//TODO: move 0xB9 into a named constant
+		//spiTransactionIS25xP({0xB9 /* op0 */,  0x00 /* op1 */,  0x00 /* op2 */, 0x00 /* op3 */, 0x00 /* op4 */, 0x00 /* op5 */, 0x00 /* op6 */}, 1 /* opCount */);
+	#endif
+
+	/*
+	 *	BMX055accel: At POR, device is in Normal mode. Move it to Deep Suspend mode.
+	 *
+	 *	Write '1' to deep suspend bit of register 0x11, and write '0' to suspend bit of register 0x11. See page 23.
+	 */
+	#if WARP_BUILD_ENABLE_DEVBMX055
+		WarpStatus	status = writeByteToI2cDeviceRegister(	deviceBMX055accelState.i2cAddress	/*	i2cAddress		*/,
+							true					/*	sendCommandByte		*/,
+							0x11					/*	commandByte		*/,
+							true					/*	sendPayloadByte		*/,
+							(1 << 5)				/*	payloadByte		*/);
+		if ((status != kWarpStatusOK) && verbose)
+		{
+			warpPrint("\r\tPowerdown command failed, code=%d, for BMX055accel @ 0x%02x.\n", status, deviceBMX055accelState.i2cAddress);
+		}
+	#else
+		warpPrint("\r\tPowerdown command abandoned. BMX055 disabled\n");
+	#endif
+
+	/*
+	 *	BMX055gyro: At POR, device is in Normal mode. Move it to Deep Suspend mode.
+	 *
+	 *	Write '1' to deep suspend bit of register 0x11. See page 81.
+	 */
+	#if (WARP_BUILD_ENABLE_DEVBMX055)
+		status = writeByteToI2cDeviceRegister(	deviceBMX055gyroState.i2cAddress	/*	i2cAddress		*/,
+							true					/*	sendCommandByte		*/,
+							0x11					/*	commandByte		*/,
+							true					/*	sendPayloadByte		*/,
+							(1 << 5)				/*	payloadByte		*/);
+		if ((status != kWarpStatusOK) && verbose)
+		{
+			warpPrint("\r\tPowerdown command failed, code=%d, for BMX055gyro @ 0x%02x.\n", status, deviceBMX055gyroState.i2cAddress);
+		}
+	#else
+		warpPrint("\r\tPowerdown command abandoned. BMX055 disabled\n");
+	#endif
+
+
+
+	/*
+	 *	BMX055mag: At POR, device is in Suspend mode. See page 121.
+	 *
+	 *	POR state seems to be powered down.
+	 */
+
+
+
+	/*
+	 *	MMA8451Q: See 0x2B: CTRL_REG2 System Control 2 Register (page 43).
+	 *
+	 *	POR state seems to be not too bad.
+	 */
+
+
+
+	/*
+	 *	LPS25H: See Register CTRL_REG1, at address 0x20 (page 26).
+	 *
+	 *	POR state seems to be powered down.
+	 */
+
+
+
+	/*
+	 *	MAG3110: See Register CTRL_REG1 at 0x10. (page 19).
+	 *
+	 *	POR state seems to be powered down.
+	 */
+
+
+
+	/*
+	 *	HDC1000: currently can't turn it on (3V)
+	 */
+
+
+
+	/*
+	 *	SI7021: Can't talk to it correctly yet.
+	 */
+
+
+
+	/*
+	 *	L3GD20H: See CTRL1 at 0x20 (page 36).
+	 *
+	 *	POR state seems to be powered down.
+	 */
+	#if (WARP_BUILD_ENABLE_DEVL3GD20H)
+		status = writeByteToI2cDeviceRegister(	deviceL3GD20HState.i2cAddress	/*	i2cAddress		*/,
+							true				/*	sendCommandByte		*/,
+							0x20				/*	commandByte		*/,
+							true				/*	sendPayloadByte		*/,
+							0x00				/*	payloadByte		*/);
+		if ((status != kWarpStatusOK) && verbose)
+		{
+			warpPrint("\r\tPowerdown command failed, code=%d, for L3GD20H @ 0x%02x.\n", status, deviceL3GD20HState.i2cAddress);
+		}
+	#else
+		warpPrint("\r\tPowerdown command abandoned. L3GD20H disabled\n");
+	#endif
+
+
+
+	/*
+	 *	BME680: TODO
+	 */
+
+
+
+	/*
+	 *	TCS34725: By default, is in the "start" state (see page 9).
+	 *
+	 *	Make it go to sleep state. See page 17, 18, and 19.
+	 */
+	#if (WARP_BUILD_ENABLE_DEVTCS34725)
+		status = writeByteToI2cDeviceRegister(	deviceTCS34725State.i2cAddress	/*	i2cAddress		*/,
+							true				/*	sendCommandByte		*/,
+							0x00				/*	commandByte		*/,
+							true				/*	sendPayloadByte		*/,
+							0x00				/*	payloadByte		*/);
+		if ((status != kWarpStatusOK) && verbose)
+		{
+			warpPrint("\r\tPowerdown command failed, code=%d, for TCS34725 @ 0x%02x.\n", status, deviceTCS34725State.i2cAddress);
+		}
+	#else
+		warpPrint("\r\tPowerdown command abandoned. TCS34725 disabled\n");
+	#endif
+
+
+
+	/*
+	 *	SI4705: Send a POWER_DOWN command (byte 0x17). See AN332 page 124 and page 132.
+	 *
+	 *	For now, simply hold its reset line low.
+	 */
+	#if (WARP_BUILD_ENABLE_DEVSI4705)
+		GPIO_DRV_ClearPinOutput(kWarpPinSI4705_nRST);
+	#endif
+}
diff --git a/src/boot/ksdk1.1.0/config.h b/src/boot/ksdk1.1.0/config.h
index edfe189..d76be6d 100644
--- a/src/boot/ksdk1.1.0/config.h
+++ b/src/boot/ksdk1.1.0/config.h
@@ -52,9 +52,81 @@
  *	build variant above, we currently require users wanting to build for the
  *	KL03 to manually set this here.
  */
-#define		WARP_BUILD_ENABLE_FRDMKL03			1
-#define		WARP_BUILD_ENABLE_DEVSSD1331	1
-#define		WARP_BUILD_ENABLE_DEVADC		1
+#define		WARP_BUILD_ENABLE_FRDMKL03			0
+
+/*
+ *	Force the required configuration if WARP_BUILD_ENABLE_GLAUX_VARIANT is set
+ */
+#if (WARP_BUILD_ENABLE_GLAUX_VARIANT)
+	#define		WARP_BUILD_ENABLE_DEVADXL362		0
+	#define		WARP_BUILD_ENABLE_DEVAMG8834		0
+	#define		WARP_BUILD_ENABLE_DEVAS7262		0
+	#define		WARP_BUILD_ENABLE_DEVAS7263		0
+	#define		WARP_BUILD_ENABLE_DEVBGX		0
+	#define		WARP_BUILD_ENABLE_DEVBME680		1
+	#define		WARP_BUILD_ENABLE_DEVBMX055		0
+	#define		WARP_BUILD_ENABLE_DEVCCS811		0
+	#define		WARP_BUILD_ENABLE_DEVHDC1000		0
+	#define		WARP_BUILD_ENABLE_DEVIS25xP		0
+	#define		WARP_BUILD_ENABLE_DEVISL23415		0
+	#define		WARP_BUILD_ENABLE_DEVAT45DB		0
+	#define		WARP_BUILD_ENABLE_DEVICE40		0
+	#define		WARP_BUILD_ENABLE_DEVL3GD20H		0
+	#define		WARP_BUILD_ENABLE_DEVLPS25H		0
+	#define		WARP_BUILD_ENABLE_DEVMAG3110		0
+	#define		WARP_BUILD_ENABLE_DEVMMA8451Q		0
+	#define		WARP_BUILD_ENABLE_DEVRV8803C7		1
+	#define		WARP_BUILD_ENABLE_DEVSI4705		0
+	#define		WARP_BUILD_ENABLE_DEVSI7021		0
+	#define		WARP_BUILD_ENABLE_DEVTCS34725		0
+#elif (WARP_BUILD_ENABLE_FRDMKL03)
+	#define		WARP_BUILD_ENABLE_DEVADXL362		0
+	#define		WARP_BUILD_ENABLE_DEVAMG8834		0
+	#define		WARP_BUILD_ENABLE_DEVAS7262		0
+	#define		WARP_BUILD_ENABLE_DEVAS7263		0
+	#define		WARP_BUILD_ENABLE_DEVBGX		0
+	#define		WARP_BUILD_ENABLE_DEVBME680		0
+	#define		WARP_BUILD_ENABLE_DEVBMX055		0
+	#define		WARP_BUILD_ENABLE_DEVCCS811		0
+	#define		WARP_BUILD_ENABLE_DEVHDC1000		0
+	#define		WARP_BUILD_ENABLE_DEVIS25xP		0
+	#define		WARP_BUILD_ENABLE_DEVISL23415		0
+	#define		WARP_BUILD_ENABLE_DEVAT45DB		0
+	#define		WARP_BUILD_ENABLE_DEVICE40		0
+	#define		WARP_BUILD_ENABLE_DEVL3GD20H		0
+	#define		WARP_BUILD_ENABLE_DEVLPS25H		0
+	#define		WARP_BUILD_ENABLE_DEVMAG3110		0
+	#define		WARP_BUILD_ENABLE_DEVMMA8451Q		1
+	#define		WARP_BUILD_ENABLE_DEVRV8803C7		0
+	#define		WARP_BUILD_ENABLE_DEVSI4705		0
+	#define		WARP_BUILD_ENABLE_DEVSI7021		0
+	#define		WARP_BUILD_ENABLE_DEVTCS34725		0
+#else
+	/*
+	 *	Otherwise: Edit these to set which code paths are activated in the firmware compilation
+	 */
+	#define		WARP_BUILD_ENABLE_DEVADXL362		1
+	#define		WARP_BUILD_ENABLE_DEVAMG8834		0
+	#define		WARP_BUILD_ENABLE_DEVAS7262		0
+	#define		WARP_BUILD_ENABLE_DEVAS7263		0
+	#define		WARP_BUILD_ENABLE_DEVBGX		1
+	#define		WARP_BUILD_ENABLE_DEVBME680		0
+	#define		WARP_BUILD_ENABLE_DEVBMX055		0
+	#define		WARP_BUILD_ENABLE_DEVCCS811		0
+	#define		WARP_BUILD_ENABLE_DEVHDC1000		0
+	#define		WARP_BUILD_ENABLE_DEVIS25xP		0
+	#define		WARP_BUILD_ENABLE_DEVISL23415		0
+	#define		WARP_BUILD_ENABLE_DEVAT45DB		1
+	#define		WARP_BUILD_ENABLE_DEVICE40		0
+	#define		WARP_BUILD_ENABLE_DEVL3GD20H		0
+	#define		WARP_BUILD_ENABLE_DEVLPS25H		0
+	#define		WARP_BUILD_ENABLE_DEVMAG3110		0
+	#define		WARP_BUILD_ENABLE_DEVMMA8451Q		0
+	#define		WARP_BUILD_ENABLE_DEVRV8803C7		0
+	#define		WARP_BUILD_ENABLE_DEVSI4705		0
+	#define		WARP_BUILD_ENABLE_DEVSI7021		0
+	#define		WARP_BUILD_ENABLE_DEVTCS34725		0
+#endif
 
 typedef enum
 {
@@ -94,7 +166,6 @@ typedef enum
 	kWarpDefaultSupplyVoltageMillivoltsBMX055gyro		= 1800,
 	kWarpDefaultSupplyVoltageMillivoltsBMX055mag		= 1800,
 	kWarpDefaultSupplyVoltageMillivoltsMMA8451Q		= 1800,
-	kWarpDefaultSupplyVoltageMillivoltsINA219		= 1800,
 	kWarpDefaultSupplyVoltageMillivoltsLPS25H		= 1800,
 	kWarpDefaultSupplyVoltageMillivoltsHDC1000		= 1800,
 	kWarpDefaultSupplyVoltageMillivoltsMAG3110		= 1800,
diff --git a/src/boot/ksdk1.1.0/devADC.c b/src/boot/ksdk1.1.0/devADC.c
deleted file mode 100644
index 3ff489c..0000000
--- a/src/boot/ksdk1.1.0/devADC.c
+++ /dev/null
@@ -1,96 +0,0 @@
-#include <stdio.h>
-#include <stdbool.h>
-#include <stdint.h>
-/*
- *	config.h needs to come first
- */
-#include "config.h"
-#include "fsl_port_hal.h"
-
-#include "SEGGER_RTT.h"
-#include "gpio_pins.h"
-#include "warp.h"
-#include "devADC.h"
-
-// #include "board.h"
-#include "fsl_os_abstraction.h"
-#include "fsl_debug_console.h"
-#include "fsl_adc16_driver.h"
-#include "fsl_adc16_hal.h"
-
-//#include "/home/students/fwa20/Warp-firmware/tools/sdk/ksdk1.1.0/platform/CMSIS/Include/device/MKL03Z4/MKL03Z4_features.h"
-
-const uint32_t instance = 0U;
-const uint32_t chnGroup = 0U;
-const uint8_t chn = 8U;
-
-int adc_readings[NUMBER_OF_STORED_READINGS];
-
-/*
- * Intialise the ADC as defined in SDK, and set
- * set running in continous conversion mode
- * so can access new reading when desired.
- */
-void ADCinit(void)
-{
-
-    #if FSL_FEATURE_ADC16_HAS_CALIBRATION
-        adc16_calibration_param_t MyAdcCalibraitionParam;
-    #endif
-
-    adc16_user_config_t MyAdcUserConfig;
-    adc16_chn_config_t MyChnConfig;
-
-    #if FSL_FEATURE_ADC16_HAS_CALIBRATION
-        // Auto calibraion. //
-        ADC16_DRV_GetAutoCalibrationParam(instance, &MyAdcCalibraitionParam);
-        ADC16_DRV_SetCalibrationParam(instance, &MyAdcCalibraitionParam);
-    #endif
-
-    // Initialize the ADC converter. //
-    ADC16_DRV_StructInitUserConfigDefault(&MyAdcUserConfig);
-    MyAdcUserConfig.continuousConvEnable = true; // Enable continuous conversion. //
-    ADC16_DRV_Init(instance, &MyAdcUserConfig);
-
-    // Configure the ADC channel and take an initial trigger. //
-    MyChnConfig.chnNum = chn;
-    MyChnConfig.diffEnable= false;
-    MyChnConfig.intEnable = false;
-    MyChnConfig.chnMux = kAdcChnMuxOfA;
-    ADC16_DRV_ConfigConvChn(instance, chnGroup, &MyChnConfig);
-
-
-    ADC_read_set(0);
-}
-
-/*
- * Wrapper function to allow reading from ADC using only
- * one line downstream.
- */
-int32_t read_from_adc(void){
-    ADC16_DRV_WaitConvDone(instance, chnGroup);
-    uint16_t MyAdcValue = ADC16_DRV_GetConvValueRAW(instance, chnGroup);
-    int32_t converted_adc_read = ADC16_DRV_ConvRAWData(MyAdcValue, false, kAdcResolutionBitOfSingleEndAs12);
-    return converted_adc_read;
-}
-
-/*
- * Populate the ADC data array with a full set of readings.
- * Option to add in a delay between readings if desired so
- * sampling frequency isn't based on ADC speed.
- */
-
-void ADC_read_set(bool delay){
-
-    for(int i = 0; i < NUMBER_OF_STORED_READINGS; i++){
-        // wait for and fetch conversion - int conversion for explicitness
-        // only since this board uses int = int32_t
-        adc_readings[i] = (int)read_from_adc();
-
-        // if want more control over sampling period, necessary
-        // for explicit frequency bin calculations
-        if (delay){
-            OSA_TimeDelay(SAMPLING_PERIOD);
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devADC.h b/src/boot/ksdk1.1.0/devADC.h
deleted file mode 100644
index ec5497c..0000000
--- a/src/boot/ksdk1.1.0/devADC.h
+++ /dev/null
@@ -1,13 +0,0 @@
-#include <stdbool.h>
-
-#define NUMBER_OF_STORED_READINGS 16
-#define NUMBER_OF_FREQS 8
-#define IGNORED_FREQS 2
-#define SHUNT IGNORED_FREQS / 2
-#define SAMPLING_PERIOD 0.5
-
-void ADCinit(void);
-int32_t read_from_adc(void);
-void ADC_read_set(bool delay);
-
-extern int adc_readings[NUMBER_OF_STORED_READINGS];
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devADXL362.c b/src/boot/ksdk1.1.0/devADXL362.c
new file mode 100644
index 0000000..126168c
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devADXL362.c
@@ -0,0 +1,536 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "errstrs.h"
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+#include "devADXL362.h"
+
+extern volatile WarpSPIDeviceState	deviceADXL362State;
+extern volatile uint32_t		gWarpSpiTimeoutMicroseconds;
+extern uint8_t				gWarpSpiCommonSourceBuffer[];
+extern uint8_t				gWarpSpiCommonSinkBuffer[];
+
+
+/*
+ *	Analog Devices ADXL362.
+ *
+ *	From device manual, Rev. B, Page 19 of 44:
+ *
+ *		"
+ *		The SPI port uses a multibyte structure 
+ *		wherein the first byte is a command. The 
+ *		ADXL362 command set is:
+ *
+ *		-	0x0A: write register
+ *		-	0x0B: read register
+ *		-	0x0D: read FIFO
+ *		"
+ */
+#define	ADXL362_FIFO_ENTRIES	(min(kWarpMemoryCommonSpiBufferBytes - 1, 0xFF) & 0xFE)
+
+void
+initADXL362(int chipSelectIoPinID, uint16_t operatingVoltageMillivolts)
+{
+	WarpStatus	status;
+
+	deviceADXL362State.chipSelectIoPinID		= chipSelectIoPinID;
+	deviceADXL362State.spiSourceBuffer		= gWarpSpiCommonSourceBuffer;
+	deviceADXL362State.spiSinkBuffer		= gWarpSpiCommonSinkBuffer;
+	deviceADXL362State.spiBufferLength		= kWarpMemoryCommonSpiBufferBytes;
+	deviceADXL362State.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	/*
+	 *	Soft reset
+	 */
+
+	status = writeSensorRegisterADXL362(	kWarpSensorConfigConstADXL362registerWriteCommand	/*	command == write register		*/,
+						kWarpSensorConfigurationRegisterADXL362RESET		/*	The register to write			*/,
+						kWarpSensorConfigConstADXL362resetCode			/*	writeValue				*/,
+						0							/*	number of additional dummy bytes	*/
+					);
+	if (status != kWarpStatusOK)
+	{
+		warpPrint(gWarpEsensorConfig);
+	}
+	OSA_TimeDelay(10);
+
+	/*
+	 *	Set MEASURE mode with AUTOSLEEP
+	 */
+	status = writeSensorRegisterADXL362(	kWarpSensorConfigConstADXL362registerWriteCommand	/*	command == write register		*/,
+						kWarpSensorOutputRegisterADXL362POWER_CTL		/*	The register to write			*/,
+						0x06							/*	writeValue				*/,
+						0							/*	number of additional dummy bytes	*/
+					);
+	if (status != kWarpStatusOK)
+	{
+		warpPrint(gWarpEsensorConfig);
+	}
+
+	/*
+	 *	Set ODR mode to 400Hz
+	 */
+	status = writeSensorRegisterADXL362(	kWarpSensorConfigConstADXL362registerWriteCommand	/*	command == write register		*/,
+						kWarpSensorOutputRegisterADXL362FILTER_CTL		/*	The register to write			*/,
+						0x07							/*	writeValue				*/,
+						0							/*	number of additional dummy bytes	*/
+					);
+	if (status != kWarpStatusOK)
+	{
+		warpPrint(gWarpEsensorConfig);
+	}
+
+	/*
+	 *	Set FIFO mode to STREAM and AH bit to 0, also read temperature to FIFO
+	 */
+	status = writeSensorRegisterADXL362(	kWarpSensorConfigConstADXL362registerWriteCommand	/*	command == write register		*/,
+						kWarpSensorOutputRegisterADXL362FIFO_CONTROL		/*	The register to write			*/,
+						0x06							/*	writeValue				*/,
+						0							/*	number of additional dummy bytes	*/
+					);
+	if (status != kWarpStatusOK)
+	{
+		warpPrint(gWarpEsensorConfig);
+	}
+
+	/*
+	 *	Set FIFO SAMPLES to match (kWarpMemoryCommonSpiBufferBytes - 1) since that is
+	 *	maximum we can receive in a single FIFO READ transaction due to our configured
+	 *	buffer size. AH bit to 0 previously (so value we write doesn't get 0x01FF added
+	 *	by default). Since the entries put into the FIFO by the sensor are 2-byte records
+	 *	we  will Therefore, the maximum FIFO entries is min(kWarpMemoryCommonSpiBufferBytes - 1, 0xFF)
+	 */
+	status = writeSensorRegisterADXL362(	kWarpSensorConfigConstADXL362registerWriteCommand	/*	command == write register		*/,
+						kWarpSensorOutputRegisterADXL362FIFO_SAMPLES		/*	The register to write			*/,
+						ADXL362_FIFO_ENTRIES					/*	writeValue				*/,
+						0							/*	number of additional dummy bytes	*/
+					);
+	if (status != kWarpStatusOK)
+	{
+		warpPrint(gWarpEsensorConfig);
+	}
+
+	/*
+	 *	Put the sensor in LOOP mode with ACT_EN and INACT_EN enabled
+	 */
+	status = writeSensorRegisterADXL362(	kWarpSensorConfigConstADXL362registerWriteCommand	/*	command == write register		*/,
+						kWarpSensorOutputRegisterADXL362ACT_INACT_CTL		/*	ACT_INACT_CTL register			*/,
+						0x35							/*	writeValue				*/,
+						0							/*	numberOfAdditionalDummyBytes		*/
+					);
+	if (status != kWarpStatusOK)
+	{
+		warpPrint(gWarpEsensorConfig);
+	}
+
+	return;
+}
+
+WarpStatus
+writeSensorRegisterADXL362(uint8_t command, uint8_t deviceRegister, uint8_t writeValue, int numberOfAdditionalDummyBytes)
+{
+	spi_status_t	status;
+
+
+	warpScaleSupplyVoltage(deviceADXL362State.operatingVoltageMillivolts);
+
+	/*
+	 *	Appropriately restrict the total number of bytes shifted out
+	 *	(and hence shifted in) to the size of the sink buffer.
+	 */
+	int	totalTransactionBytes = min(numberOfAdditionalDummyBytes + 3, kWarpMemoryCommonSpiBufferBytes);
+
+	/*
+	 *	First, configure chip select pins of the various SPI slave devices
+	 *	as GPIO and drive all of them high.
+	 */
+	warpDeasserAllSPIchipSelects();
+
+	/*
+	 *	Populate the shift-out register with the read-register command,
+	 *	followed by the register to be read, followed by the single byte
+	 *	to be written.
+	 */
+	deviceADXL362State.spiSourceBuffer[0] = command;
+	deviceADXL362State.spiSourceBuffer[1] = deviceRegister;
+	deviceADXL362State.spiSourceBuffer[2] = writeValue;
+
+	/*
+	 *	First, create a falling edge on chip-select.
+	 */
+	GPIO_DRV_ClearPinOutput(deviceADXL362State.chipSelectIoPinID);
+
+	/*
+	 *	The result of the SPI transaction will be stored in deviceADXL362State.spiSinkBuffer.
+	 *
+	 *	Providing a spi_master_user_config_t is optional since it is already provided when we did
+	 *	SPI_DRV_MasterConfigureBus(), so we pass in NULL. The "master instance" is always 0 for
+	 *	the KL03 since there is only one SPI peripheral.
+	 */
+	warpEnableSPIpins();
+	status = SPI_DRV_MasterTransferBlocking(0							/*	master instance */,
+					NULL								/* spi_master_user_config_t */,
+					(const uint8_t * restrict)deviceADXL362State.spiSourceBuffer,
+					(uint8_t * restrict)deviceADXL362State.spiSinkBuffer,
+					totalTransactionBytes						/* transfer size */,
+					gWarpSpiTimeoutMicroseconds);
+	warpDisableSPIpins();
+
+	/*
+	 *	Disengage the ADXL362
+	 */
+	GPIO_DRV_SetPinOutput(deviceADXL362State.chipSelectIoPinID);
+
+	if (status != kStatus_SPI_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+WarpStatus
+readSensorRegisterADXL362(uint8_t deviceRegister, int numberOfBytes)
+{
+	/*
+	 *	Since writeSensorRegisterADXL362() will already write one additional byte
+	 *	after the R/W command designator and the register designator, only need
+	 *	to ask it to do numberOfBytes - 1 additional dummy shifts out.
+	 *
+	 *	NOTE: writeSensorRegisterADXL362() will appropriately restrict the total
+	 *	number of bytes shifted out (and hence shifted in) to the size of the
+	 *	sink buffer.
+	 */
+	return writeSensorRegisterADXL362(kWarpSensorConfigConstADXL362registerReadRegister /* command == read register */, deviceRegister, 0x00 /* writeValue */, numberOfBytes - 1);
+}
+
+WarpStatus
+readFIFObytesADXL362(void)
+{
+	WarpStatus	status;
+	int		transferSize;
+
+
+	warpPrint("\n\n");
+
+	/*
+	 *	Read and print the FIFO_CONTROL
+	 */
+	status = readSensorRegisterADXL362(kWarpSensorOutputRegisterADXL362FIFO_CONTROL, 1 /* numberOfBytes */);
+	if (status != kWarpStatusOK)
+	{
+		warpPrint("FIFO_CONTROL	--> ----\n");
+	}
+	else
+	{
+		warpPrint("FIFO_CONTROL	--> [0x%02x]\n",
+				deviceADXL362State.spiSinkBuffer[2]);
+	}
+
+	/*
+	 *	Read and print the STATUS
+	 */
+	status = readSensorRegisterADXL362(kWarpSensorOutputRegisterADXL362STATUS, 1 /* numberOfBytes */);
+	if (status != kWarpStatusOK)
+	{
+		warpPrint("Status		--> ----\n");
+	}
+	else
+	{
+		warpPrint("Status		--> [0x%02x]\n",
+				deviceADXL362State.spiSinkBuffer[2]);
+	}
+
+	/*
+	 *	Read and print the FIFO_SAMPLES
+	 */
+	status = readSensorRegisterADXL362(kWarpSensorOutputRegisterADXL362FIFO_SAMPLES, 1 /* numberOfBytes */);
+	if (status != kWarpStatusOK)
+	{
+		warpPrint("FIFO_SAMPLES	--> ----\n");
+	}
+	else
+	{
+		warpPrint("FIFO_SAMPLES	--> [0x%02x]\n",
+				deviceADXL362State.spiSinkBuffer[2]);
+	}
+
+	/*
+	 *	Read and print FIFO_ENTRIES_L
+	 */
+	status = readSensorRegisterADXL362(kWarpSensorOutputRegisterADXL362FIFO_ENTRIES_L, 1 /* numberOfBytes */);
+	if (status != kWarpStatusOK)
+	{
+		warpPrint("FIFO_ENTRIES_L	--> ----\n");
+	}
+	else
+	{
+		warpPrint("FIFO_ENTRIES_L	--> [0x%02x]\n",
+				deviceADXL362State.spiSinkBuffer[2]);
+	}
+
+	/*
+	 *	Read and print FIFO_ENTRIES_H
+	 */
+	status = readSensorRegisterADXL362(kWarpSensorOutputRegisterADXL362FIFO_ENTRIES_H, 1 /* numberOfBytes */);
+	if (status != kWarpStatusOK)
+	{
+		warpPrint("FIFO_ENTRIES_H	--> ----\n");
+	}
+	else
+	{
+		warpPrint("FIFO_ENTRIES_H	--> [0x%02x]\n",
+				deviceADXL362State.spiSinkBuffer[2]);
+	}
+
+
+	/*
+	 *	For the FIFO read operation, we can't easil;y repurpose the register
+	 *	read operation as it currently is, so we do the whole SPI process
+	 *	in a self-contained way here.
+	 */
+
+
+	warpScaleSupplyVoltage(deviceADXL362State.operatingVoltageMillivolts);
+
+	/*
+	 *	First, configure chip select pins of the various SPI slave devices
+	 *	as GPIO and drive all of them high.
+	 */
+	warpDeasserAllSPIchipSelects();
+
+	/*
+	 *	Populate the shift-out register with the read-FIFO command.
+	 */
+	deviceADXL362State.spiSourceBuffer[0] = kWarpSensorConfigConstADXL362registerFIFORead;
+
+	/*
+	 *	Number of bytes read in FIFO read oepration (after the command byte)
+	 *	must be an even number, according to datasheet page 38.
+	 *
+	 *	In configuring the sensor, we already made sure that the number of entries
+	 *	we set was even and also that it was less than kWarpMemoryCommonSpiBufferBytes
+	 *	finally, here, we issue an SPI transaction with a transfer size which is one
+	 *	more than ADXL362_FIFO_ENTRIES to account for the leading command byte and its
+	 *	associated dummy receive byte.
+	 *	
+	 */
+	transferSize = ADXL362_FIFO_ENTRIES + 1;
+	GPIO_DRV_ClearPinOutput(deviceADXL362State.chipSelectIoPinID);
+	warpEnableSPIpins();
+	spi_status_t ksdkStatus = SPI_DRV_MasterTransferBlocking(0 /* master instance */,
+						NULL /* spi_master_user_config_t */,
+						(const uint8_t *restrict)deviceADXL362State.spiSourceBuffer,
+						(uint8_t * restrict) deviceADXL362State.spiSinkBuffer,
+						transferSize /* transfer size */,
+						gWarpSpiTimeoutMicroseconds /* timeout in microseconds (unlike I2C which is ms) */);
+	warpDisableSPIpins();
+	GPIO_DRV_SetPinOutput(deviceADXL362State.chipSelectIoPinID);
+
+	if (ksdkStatus != kStatus_SPI_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	warpPrint("\n");
+	for (int i = 1; i < kWarpMemoryCommonSpiBufferBytes - 8; i += 8)
+	{
+		warpPrint("0x%02x 0x%02x\t0x%02x 0x%02x\t0x%02x 0x%02x\t0x%02x 0x%02x\n",
+				deviceADXL362State.spiSinkBuffer[i + 0],
+				deviceADXL362State.spiSinkBuffer[i + 1],
+				deviceADXL362State.spiSinkBuffer[i + 2],
+				deviceADXL362State.spiSinkBuffer[i + 3],
+				deviceADXL362State.spiSinkBuffer[i + 4],
+				deviceADXL362State.spiSinkBuffer[i + 5],
+				deviceADXL362State.spiSinkBuffer[i + 6],
+				deviceADXL362State.spiSinkBuffer[i + 7]
+			);
+	}
+	warpPrint("\n");
+
+	return kWarpStatusOK;
+}
+
+void
+printSensorDataADXL362(bool hexModeFlag)
+{
+	uint8_t		readSensorRegisterValueLSB;
+	uint8_t		readSensorRegisterValueMSB;
+	int16_t		readSensorRegisterValueCombined;
+	WarpStatus	status;
+
+//readFIFObytesADXL362();
+
+	/*
+	 *			Read X, Y, Z, TEMP
+	 */
+	status = readSensorRegisterADXL362(kWarpSensorOutputRegisterADXL362XDATA_L, 8 /* numberOfBytes */);
+
+
+	/*
+	 *			Print X
+	 */
+	if (status != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		/*
+		 *	Recall that the index [0] and [1] of the spiSinkBuffer are
+		 *	bytes that were shifted in when sending out the instruction
+		 *	and address bytes. We therefore look in indices [2] and [3].
+		 */
+		readSensorRegisterValueLSB = deviceADXL362State.spiSinkBuffer[2];
+		readSensorRegisterValueMSB = deviceADXL362State.spiSinkBuffer[3];
+		readSensorRegisterValueCombined = (readSensorRegisterValueMSB << 8) | readSensorRegisterValueLSB;
+
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+
+	/*
+	 *			Print Y
+	 */
+	if (status != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		/*
+		 *	Recall that the index [0] and [1] of the spiSinkBuffer are
+		 *	bytes that were shifted in when sending out the instruction
+		 *	and address bytes. We therefore look in indices [2] and [3].
+		 */
+		readSensorRegisterValueLSB = deviceADXL362State.spiSinkBuffer[4];
+		readSensorRegisterValueMSB = deviceADXL362State.spiSinkBuffer[5];
+		readSensorRegisterValueCombined = (readSensorRegisterValueMSB << 8) | readSensorRegisterValueLSB;
+
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+
+	/*
+	 *			Print Z
+	 */
+	if (status != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		/*
+		 *	Recall that the index [0] and [1] of the spiSinkBuffer are
+		 *	bytes that were shifted in when sending out the instruction
+		 *	and address bytes. We therefore look in indices [2] and [3].
+		 */
+		readSensorRegisterValueLSB = deviceADXL362State.spiSinkBuffer[6];
+		readSensorRegisterValueMSB = deviceADXL362State.spiSinkBuffer[7];
+		readSensorRegisterValueCombined = (readSensorRegisterValueMSB << 8) | readSensorRegisterValueLSB;
+
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+
+	/*
+	 *			Print TEMP
+	 */
+	if (status != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		/*
+		 *	Recall that the index [0] and [1] of the spiSinkBuffer are
+		 *	bytes that were shifted in when sending out the instruction
+		 *	and address bytes. We therefore look in indices [2] and [3].
+		 */
+		readSensorRegisterValueLSB = deviceADXL362State.spiSinkBuffer[8];
+		readSensorRegisterValueMSB = deviceADXL362State.spiSinkBuffer[9];
+		readSensorRegisterValueCombined = (readSensorRegisterValueMSB << 8) | readSensorRegisterValueLSB;
+
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devADXL362.h b/src/boot/ksdk1.1.0/devADXL362.h
new file mode 100644
index 0000000..427f5d6
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devADXL362.h
@@ -0,0 +1,42 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+void		initADXL362(int chipSelectIoPinID, uint16_t operatingVoltageMillivolts);
+WarpStatus	readSensorRegisterADXL362(uint8_t deviceRegister, int numberOfBytes);
+WarpStatus	readFIFObytesADXL362(void);
+WarpStatus	writeSensorRegisterADXL362(uint8_t command, uint8_t deviceRegister, uint8_t writeValue, int numberOfBytes);
+void		printSensorDataADXL362(bool hexModeFlag);
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devAMG8834.c b/src/boot/ksdk1.1.0/devAMG8834.c
new file mode 100644
index 0000000..13be91f
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devAMG8834.c
@@ -0,0 +1,266 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell. Additional contributors,
+	2018-onwards. See git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+
+
+
+extern volatile WarpI2CDeviceState	deviceAMG8834State;
+extern volatile uint32_t		gWarpI2cBaudRateKbps;
+extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
+extern volatile uint32_t		gWarpSupplySettlingDelayMilliseconds;
+
+
+/*
+ *	AMG8834.
+ */
+void
+initAMG8834(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceAMG8834State.i2cAddress			= i2cAddress;
+	deviceAMG8834State.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+writeSensorRegisterAMG8834(uint8_t deviceRegister, uint8_t payload, uint16_t menuI2cPullupValue)
+{
+	uint8_t		payloadByte[1], commandByte[1];
+	i2c_status_t	returnValue;
+
+
+	warpScaleSupplyVoltage(deviceAMG8834State.operatingVoltageMillivolts);
+
+	switch (deviceRegister)
+	{
+		case 0x00: case 0x01: case 0x02: case 0x03:
+		case 0x05: case 0x07: case 0x08: case 0x09:
+		case 0x0A: case 0x0B: case 0x0C: case 0x0D:
+		{
+			/* OK */
+			break;
+		}
+		
+		default:
+		{
+			return kWarpStatusBadDeviceCommand;
+		}
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceAMG8834State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	commandByte[0] = deviceRegister;
+	payloadByte[0] = payload;
+	warpEnableI2Cpins();
+	returnValue = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C instance */,
+							&slave,
+							commandByte,
+							1,
+							payloadByte,
+							1,
+							gWarpI2cTimeoutMilliseconds);
+	if (returnValue != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+WarpStatus
+configureSensorAMG8834(uint8_t payloadConfigReg, uint8_t payloadFrameRateReg, uint16_t menuI2cPullupValue)
+{
+	WarpStatus	i2cWriteStatus1, i2cWriteStatus2;
+
+
+	warpScaleSupplyVoltage(deviceAMG8834State.operatingVoltageMillivolts);
+
+	i2cWriteStatus1 = writeSensorRegisterAMG8834(kWarpSensorConfigurationRegisterAMG8834RST /* register address configuration register */,
+							payloadConfigReg,
+							menuI2cPullupValue);
+
+	i2cWriteStatus2 = writeSensorRegisterAMG8834(kWarpSensorConfigurationRegisterAMG8834FPSC /* register address frame rate register */,
+							payloadFrameRateReg,
+							menuI2cPullupValue);
+
+	return (i2cWriteStatus1 | i2cWriteStatus2);
+}
+
+WarpStatus
+readSensorRegisterAMG8834(uint8_t deviceRegister, int numberOfBytes)
+{
+	uint8_t 	cmdBuf[1]	= {0xFF};
+	i2c_status_t	status;
+
+
+	USED(numberOfBytes);
+
+
+	warpScaleSupplyVoltage(deviceAMG8834State.operatingVoltageMillivolts);
+
+	if (deviceRegister > 0xFF)
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceAMG8834State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	cmdBuf[0] = deviceRegister;
+
+	warpEnableI2Cpins();
+	status = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							cmdBuf,
+							1,
+							(uint8_t *)deviceAMG8834State.i2cBuffer,
+							numberOfBytes,
+							gWarpI2cTimeoutMilliseconds);
+
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+void
+printSensorDataAMG8834(bool hexModeFlag)
+{
+	uint16_t	readSensorRegisterValueLSB;
+	uint16_t	readSensorRegisterValueMSB;
+	int16_t		readSensorRegisterValueCombined;
+	WarpStatus	i2cReadStatus;
+
+
+	warpScaleSupplyVoltage(deviceAMG8834State.operatingVoltageMillivolts);
+
+	for (uint16_t bufAddress = kWarpSensorOutputRegisterAMG8834T01L; bufAddress <= kWarpSensorOutputRegisterAMG8834T64H; bufAddress = bufAddress + 2)
+	{
+		i2cReadStatus			= readSensorRegisterAMG8834(bufAddress, 2 /* numberOfBytes */);
+		readSensorRegisterValueLSB	= deviceAMG8834State.i2cBuffer[0];
+		readSensorRegisterValueMSB	= deviceAMG8834State.i2cBuffer[1];
+
+		/*
+		 *	Format is 12 bits with the highest-order bit being a sign (0 +ve, 1 -ve)
+		 */
+		readSensorRegisterValueCombined	= ((readSensorRegisterValueMSB & 0x07) << 8) | (readSensorRegisterValueLSB & 0xFF);
+		readSensorRegisterValueCombined *= ((readSensorRegisterValueMSB & (1 << 3)) == 0 ? 1 : -1);
+
+		/*
+		 *	Specification, page 14/26, says LSB counts for 0.25 C (1/4 C)
+		 */
+		readSensorRegisterValueCombined >>= 2;
+
+		if (i2cReadStatus != kWarpStatusOK)
+		{
+			warpPrint(" ----,");
+		}
+		else
+		{
+			if (hexModeFlag)
+			{
+				warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+			}
+			else
+			{
+				warpPrint(" %d,", readSensorRegisterValueCombined);
+			}
+		}
+	}
+
+	i2cReadStatus			= readSensorRegisterAMG8834(kWarpSensorOutputRegisterAMG8834TTHL, 2 /* numberOfBytes */);
+	readSensorRegisterValueLSB	= deviceAMG8834State.i2cBuffer[0];
+	readSensorRegisterValueMSB	= deviceAMG8834State.i2cBuffer[1];
+
+	/*
+	 *	Format is 12 bits with the highest-order bit being a sign (0 +ve, 1 -ve)
+	 */
+	readSensorRegisterValueCombined	= ((readSensorRegisterValueMSB & 0x07) << 8) | (readSensorRegisterValueLSB & 0xFF);
+	readSensorRegisterValueCombined *= ((readSensorRegisterValueMSB & (1 << 3)) == 0 ? 1 : -1);
+
+	/*
+	 *	Specification, page 13/26, says LSB of the 12-bit thermistor value counts for 0.0625 C (1 / 16 C)
+	 */
+	readSensorRegisterValueCombined >>= 4;
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devAMG8834.h b/src/boot/ksdk1.1.0/devAMG8834.h
new file mode 100644
index 0000000..ef80916
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devAMG8834.h
@@ -0,0 +1,42 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell. Additional contributors,
+	2018-onwards. See git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+void		initAMG8834(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts);
+WarpStatus	readSensorRegisterAMG8834(uint8_t deviceRegister, int numberOfBytes);
+WarpStatus	writeSensorRegisterAMG8834(uint8_t deviceRegister, uint8_t payload, uint16_t menuI2cPullupValue);
+WarpStatus	configureSensorAMG8834(uint8_t payloadConfigReg, uint8_t payloadFrameRateReg, uint16_t menuI2cPullupValue);
+void		printSensorDataAMG8834(bool hexModeFlag);
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devAS7262.c b/src/boot/ksdk1.1.0/devAS7262.c
new file mode 100644
index 0000000..babf779
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devAS7262.c
@@ -0,0 +1,152 @@
+/*
+	Authored 2018. Rae Zhao. Additional contributors 2018-onwards,
+	see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+#include "devAS726x.h"
+
+extern volatile WarpI2CDeviceState	deviceAS7262State;
+extern volatile uint32_t		gWarpI2cBaudRateKbps;
+extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
+
+
+void
+initAS7262(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceAS7262State.i2cAddress			= i2cAddress;
+	deviceAS7262State.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+readSensorRegisterAS7262(uint8_t deviceRegister, int numberOfBytes)
+{
+	/*
+	 *	The sensor has only 3 real registers: STATUS Register 0x00, WRITE Register 0x01 and READ register 0x02.
+	 */
+	uint8_t		cmdBuf_write[2]		= {kWarpI2C_AS726x_SLAVE_WRITE_REG, 0xFF};
+	uint8_t		cmdBuf_read[1]		= {kWarpI2C_AS726x_SLAVE_READ_REG};
+	i2c_status_t	returnValue;
+
+	USED(numberOfBytes);
+	if (deviceRegister > 0x2B)
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave =
+	{ 
+		.address = deviceAS7262State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	warpScaleSupplyVoltage(deviceAS7262State.operatingVoltageMillivolts);
+
+	cmdBuf_write[1] = deviceRegister;
+	warpEnableI2Cpins();
+
+	/*
+	 *	See Page 8 to Page 11 of AS726X Design Considerations for writing to and reading from virtual registers.
+	 *	Write transaction writes the value of the virtual register one wants to read from to the WRITE register 0x01.
+	 */
+
+	returnValue = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave /* The pointer to the I2C device information structure */,
+							cmdBuf_write /* The pointer to the commands to be transferred */,
+							2 /* The length in bytes of the commands to be transferred */,
+							NULL /* The pointer to the data to be transferred */,
+							0 /* The length in bytes of the data to be transferred */,
+							gWarpI2cTimeoutMilliseconds);
+	if (returnValue != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	/*
+	 *	Read transaction which reads from the READ register 0x02.
+	 *	The read transaction requires one to first write to the register address one wants to focus on and then read from that address.
+	 */
+
+	returnValue = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave /* The pointer to the I2C device information structure */,
+							cmdBuf_read /* The pointer to the commands to be transferred */,
+							1 /* The length in bytes of the commands to be transferred */,
+							NULL /* The pointer to the data to be transferred */,
+							0 /* The length in bytes of the data to be transferred */,
+							gWarpI2cTimeoutMilliseconds);
+	if (returnValue != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	returnValue = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave /* The pointer to the I2C device information structure */,
+							cmdBuf_read /* The pointer to the commands to be transferred */,
+							1 /* The length in bytes of the commands to be transferred */,
+							(uint8_t *)deviceAS7262State.i2cBuffer /* The pointer to the data to be transferred */,
+							numberOfBytes /* The length in bytes of the data to be transferred and data is transferred from the sensor to master via bus */,
+							gWarpI2cTimeoutMilliseconds);
+	if (returnValue != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
diff --git a/src/boot/ksdk1.1.0/devAS7262.h b/src/boot/ksdk1.1.0/devAS7262.h
new file mode 100644
index 0000000..8d8e75d
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devAS7262.h
@@ -0,0 +1,39 @@
+/*
+	Authored 2018. Rae Zhao. Additional contributors 2018-onwards,
+	see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+void		initAS7262(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts);
+WarpStatus	readSensorRegisterAS7262(uint8_t deviceRegister, int numberOfBytes);
diff --git a/src/boot/ksdk1.1.0/devAS7263.c b/src/boot/ksdk1.1.0/devAS7263.c
new file mode 100644
index 0000000..3aa6a07
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devAS7263.c
@@ -0,0 +1,214 @@
+/*
+	Authored 2018. Rae Zhao. Additional contributors 2018-onwards,
+	see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+#include "devAS726x.h"
+
+extern volatile WarpI2CDeviceState	deviceAS7263State;
+extern volatile uint32_t		gWarpI2cBaudRateKbps;
+extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
+
+
+void
+initAS7263(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceAS7263State.i2cAddress			= i2cAddress;
+	deviceAS7263State.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+readSensorRegisterAS7263(uint8_t deviceRegister, int numberOfBytes)
+{
+	/*
+	 *	The sensor has only 3 real registers: STATUS Register 0x00, WRITE Register 0x01 and READ register 0x02.
+	 */
+	uint8_t		cmdBuf_write[2]		= {kWarpI2C_AS726x_SLAVE_WRITE_REG, 0xFF};
+	uint8_t		cmdBuf_LEDCTRL[2]	= {kWarpI2C_AS726x_SLAVE_WRITE_REG, 0x87};
+	uint8_t		cmdBuf_LEDON[2]		= {kWarpI2C_AS726x_SLAVE_WRITE_REG, 0x1B};
+	uint8_t		cmdBuf_LEDOFF[2]	= {kWarpI2C_AS726x_SLAVE_WRITE_REG, 0x00};
+	uint8_t		cmdBuf_read[1]		= {kWarpI2C_AS726x_SLAVE_READ_REG};
+	i2c_status_t	returnValue;
+
+
+	USED(numberOfBytes);
+	if (deviceRegister > 0x2B)
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave =
+	{ 
+		.address = deviceAS7263State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	warpScaleSupplyVoltage(deviceAS7263State.operatingVoltageMillivolts);
+
+	cmdBuf_write[1] = deviceRegister;
+	warpEnableI2Cpins();
+
+	/*
+	 *	The LED control register details can be found in Figure 27 of AS7263 detailed descriptions on page 24.
+	 */
+	returnValue = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave /* The pointer to the I2C device information structure */,
+							cmdBuf_LEDCTRL /* The pointer to the commands to be transferred */,
+							2 /* The length in bytes of the commands to be transferred */,
+							NULL /* The pointer to the data to be transferred */,
+							0 /* The length in bytes of the data to be transferred */,
+							gWarpI2cTimeoutMilliseconds);
+	if (returnValue != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	/*
+	 *	This turns on the LED before reading the data
+	 */
+	returnValue = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave /* The pointer to the I2C device information structure */,
+							cmdBuf_LEDON /* The pointer to the commands to be transferred */,
+							2 /* The length in bytes of the commands to be transferred */,
+							NULL /* The pointer to the data to be transferred */,
+							0 /* The length in bytes of the data to be transferred */,
+							gWarpI2cTimeoutMilliseconds);
+	if (returnValue != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	/*
+	 *	See Page 8 to Page 11 of AS726X Design Considerations for writing to and reading from virtual registers.
+	 *	Write transaction writes the value of the virtual register one wants to read from to the WRITE register 0x01.
+	 */
+	returnValue = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave /* The pointer to the I2C device information structure */,
+							cmdBuf_write /* The pointer to the commands to be transferred */,
+							2 /* The length in bytes of the commands to be transferred */,
+							NULL /* The pointer to the data to be transferred */,
+							0 /* The length in bytes of the data to be transferred */,
+							gWarpI2cTimeoutMilliseconds);		
+	if (returnValue != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	/*
+	 *	Read transaction which reads from the READ register 0x02.
+	 *	The read transaction requires one to first write to the register address one wants to focus on and then read from that address.
+	 */
+	returnValue = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave /* The pointer to the I2C device information structure */,
+							cmdBuf_read /* The pointer to the commands to be transferred */,
+							1 /* The length in bytes of the commands to be transferred */,
+							NULL /* The pointer to the data to be transferred */,
+							0 /* The length in bytes of the data to be transferred */,
+							gWarpI2cTimeoutMilliseconds);			
+	if (returnValue != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	returnValue = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave /* The pointer to the I2C device information structure */,
+							cmdBuf_read /* The pointer to the commands to be transferred */,
+							1 /* The length in bytes of the commands to be transferred */,
+							(uint8_t *)deviceAS7263State.i2cBuffer /* The pointer to the data to be transferred */,
+							1 /* The length in bytes of the data to be transferred and data is transferred from the sensor to master via bus */,
+							gWarpI2cTimeoutMilliseconds);
+	if (returnValue != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	returnValue = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave /* The pointer to the I2C device information structure */,
+							cmdBuf_LEDCTRL /* The pointer to the commands to be transferred */,
+							2 /* The length in bytes of the commands to be transferred */,
+							NULL /* The pointer to the data to be transferred */,
+							0 /* The length in bytes of the data to be transferred */,
+							gWarpI2cTimeoutMilliseconds);
+	if (returnValue != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	/*
+	 *	This turns off the LED after finish reading the data
+	 */
+	returnValue = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave /* The pointer to the I2C device information structure */,
+							cmdBuf_LEDOFF /* The pointer to the commands to be transferred */,
+							2 /* The length in bytes of the commands to be transferred */,
+							NULL /* The pointer to the data to be transferred */,
+							0 /* The length in bytes of the data to be transferred */,
+							gWarpI2cTimeoutMilliseconds);
+	if (returnValue != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
diff --git a/src/boot/ksdk1.1.0/devAS7263.h b/src/boot/ksdk1.1.0/devAS7263.h
new file mode 100644
index 0000000..dbf25f7
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devAS7263.h
@@ -0,0 +1,39 @@
+/*
+	Authored 2018. Rae Zhao. Additional contributors 2018-onwards,
+	see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+void		initAS7263(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts);
+WarpStatus	readSensorRegisterAS7263(uint8_t deviceRegister, int numberOfBytes);
diff --git a/src/boot/ksdk1.1.0/devAS726x.c b/src/boot/ksdk1.1.0/devAS726x.c
new file mode 100644
index 0000000..6bcaa71
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devAS726x.c
@@ -0,0 +1,142 @@
+/*
+	Authored 2018. Rae Zhao. Additional contributors 2018-onwards,
+	see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+#include "devAS726x.h"
+
+
+WarpStatus
+ledOnAS726x(uint8_t i2cAddress)
+{
+	i2c_status_t	status1, status2;
+	uint8_t		cmdBuf_LEDCTRL[2]	= {kWarpI2C_AS726x_SLAVE_WRITE_REG, 0x87};
+	uint8_t		cmdBuf_LEDON[2]		= {kWarpI2C_AS726x_SLAVE_WRITE_REG, 0x1B};
+	
+	i2c_device_t slave =
+	{ 
+		.address = i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	warpEnableI2Cpins();
+
+	status1 = I2C_DRV_MasterSendDataBlocking(
+							0				/*	I2C peripheral instance					*/,
+							&slave				/*	The pointer to the I2C device information structure	*/,
+							cmdBuf_LEDCTRL			/*	The pointer to the commands to be transferred		*/,
+							2				/*	The length in bytes of the commands to be transferred	*/,
+							NULL				/*	The pointer to the data to be transferred		*/,
+							0				/*	The length in bytes of the data to be transferred	*/,
+							gWarpI2cTimeoutMilliseconds);
+
+	status2 = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave /* The pointer to the I2C device information structure */,
+							cmdBuf_LEDON /* The pointer to the commands to be transferred */,
+							2 /* The length in bytes of the commands to be transferred */,
+							NULL /* The pointer to the data to be transferred */,
+							0 /* The length in bytes of the data to be transferred */,
+							gWarpI2cTimeoutMilliseconds);
+
+	if ((status1 != kStatus_I2C_Success) || (status1 != kStatus_I2C_Success))
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+WarpStatus
+ledOffAS726x(uint8_t i2cAddress)
+{
+	i2c_status_t	status1, status2;
+	uint8_t		cmdBuf_LEDCTRL[2]	= {kWarpI2C_AS726x_SLAVE_WRITE_REG, 0x87};
+	uint8_t		cmdBuf_LEDOFF[2]	= {kWarpI2C_AS726x_SLAVE_WRITE_REG, 0x00};
+
+	i2c_device_t slave =
+	{ 
+		.address = i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	warpEnableI2Cpins();
+
+	status1 = I2C_DRV_MasterSendDataBlocking(
+					0 /* I2C peripheral instance */,
+					&slave /* The pointer to the I2C device information structure */,
+					cmdBuf_LEDCTRL /* The pointer to the commands to be transferred */,
+					2 /* The length in bytes of the commands to be transferred */,
+					NULL /* The pointer to the data to be transferred */,
+					0 /* The length in bytes of the data to be transferred */,
+					gWarpI2cTimeoutMilliseconds);
+
+	status2 = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave /* The pointer to the I2C device information structure */,
+							cmdBuf_LEDOFF /* The pointer to the commands to be transferred */,
+							2 /* The length in bytes of the commands to be transferred */,
+							NULL /* The pointer to the data to be transferred */,
+							0 /* The length in bytes of the data to be transferred */,
+							gWarpI2cTimeoutMilliseconds);
+
+	if ((status1 != kStatus_I2C_Success) || (status1 != kStatus_I2C_Success))
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
diff --git a/src/boot/ksdk1.1.0/devAS726x.h b/src/boot/ksdk1.1.0/devAS726x.h
new file mode 100644
index 0000000..2999037
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devAS726x.h
@@ -0,0 +1,45 @@
+/*
+	Authored 2018. Rae Zhao. Additional contributors 2018-onwards,
+	see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+enum {
+	kWarpI2C_AS726x_SLAVE_WRITE_REG	= 0x01,
+	kWarpI2C_AS726x_SLAVE_READ_REG	= 0x02
+};
+
+WarpStatus	ledOnAS726x(uint8_t i2cAddress);
+WarpStatus	ledOffAS726x(uint8_t i2cAddress);
diff --git a/src/boot/ksdk1.1.0/devAT45DB.c b/src/boot/ksdk1.1.0/devAT45DB.c
new file mode 100644
index 0000000..d3b2c42
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devAT45DB.c
@@ -0,0 +1,145 @@
+/*
+	Authored 2021. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "errstrs.h"
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+#include "devAT45DB.h"
+
+extern volatile WarpSPIDeviceState	deviceAT45DBState;
+extern volatile uint32_t		gWarpSpiTimeoutMicroseconds;
+extern uint8_t				gWarpSpiCommonSourceBuffer[];
+extern uint8_t				gWarpSpiCommonSinkBuffer[];
+
+void
+initAT45DB(int chipSelectIoPinID, uint16_t operatingVoltageMillivolts)
+{
+	deviceAT45DBState.chipSelectIoPinID		= chipSelectIoPinID;
+	deviceAT45DBState.spiSourceBuffer		= gWarpSpiCommonSourceBuffer;
+	deviceAT45DBState.spiSinkBuffer		= gWarpSpiCommonSinkBuffer;
+	deviceAT45DBState.spiBufferLength		= kWarpMemoryCommonSpiBufferBytes;
+	deviceAT45DBState.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+spiTransactionAT45DB(WarpSPIDeviceState volatile *  deviceStatePointer, uint8_t ops[], size_t opCount)
+{
+	spi_status_t	status;
+
+
+	warpScaleSupplyVoltage(deviceAT45DBState.operatingVoltageMillivolts);
+
+	/*
+	 *	First, configure chip select pins of the various SPI slave devices
+	 *	as GPIO and drive all of them high.
+	 */
+	warpDeasserAllSPIchipSelects();
+
+	for (int i = 0; (i < opCount) && (i < deviceAT45DBState.spiBufferLength); i++)
+	{
+		deviceAT45DBState.spiSourceBuffer[i] = ops[i];
+		deviceAT45DBState.spiSinkBuffer[i] = 0xFF;
+	}
+
+	/*
+	 *	First, pulse the /CS to wake up device in case it is in Ultra-Deep Power-Down mode.
+	 *	(See Section 10.2.1 of manual). The 50 milliseconds we use here is conservative:
+	 *	the manual says the minimum time needed is 20ns. However, the datasheet also says:
+	 *
+	 *		"After the CS pin has been deasserted, the device will exit from the 
+	 *		Ultra-Deep Power-Down mode and return to the standby mode within a 
+	 *		maximum time of tXUDPD."
+	 *
+	 *	Since txudpd is 100us, we wait another millisecond before proceeding to assert /CS
+	 *	again below.
+	 */
+	GPIO_DRV_ClearPinOutput(deviceAT45DBState.chipSelectIoPinID);
+	OSA_TimeDelay(1);
+	GPIO_DRV_SetPinOutput(deviceAT45DBState.chipSelectIoPinID);
+	OSA_TimeDelay(1);
+
+	/*
+	 *	Next, create a falling edge on chip-select.
+	 */
+	GPIO_DRV_ClearPinOutput(deviceAT45DBState.chipSelectIoPinID);
+
+	/*
+	 *	The result of the SPI transaction will be stored in deviceADXL362State.spiSinkBuffer.
+	 *	Providing a spi_master_user_config_t is optional since it is already provided when we did
+	 *	SPI_DRV_MasterConfigureBus(), so we pass in NULL. The "master instance" is always 0 for
+	 *	the KL03 since there is only one SPI peripheral.
+	 */
+	warpEnableSPIpins();
+	status = SPI_DRV_MasterTransferBlocking(0							/*	master instance			*/,
+					NULL								/*	spi_master_user_config_t	*/,
+					(const uint8_t * restrict)deviceAT45DBState.spiSourceBuffer	/*	source buffer			*/,
+					(uint8_t * restrict)deviceAT45DBState.spiSinkBuffer		/*	receive buffer			*/,
+					opCount								/*	transfer size			*/,
+					gWarpSpiTimeoutMicroseconds);
+	warpDisableSPIpins();
+
+	/*
+	 *	Deassert the AT45DB
+	 */
+	GPIO_DRV_SetPinOutput(deviceAT45DBState.chipSelectIoPinID);
+
+	if (status != kStatus_SPI_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
diff --git a/src/boot/ksdk1.1.0/devAT45DB.h b/src/boot/ksdk1.1.0/devAT45DB.h
new file mode 100644
index 0000000..cd76a2e
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devAT45DB.h
@@ -0,0 +1,39 @@
+/*
+	Authored 2021. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+void		initAT45DB(int chipSelectIoPinID, uint16_t operatingVoltageMillivolts);
+WarpStatus	spiTransactionAT45DB(WarpSPIDeviceState volatile *  deviceStatePointer, uint8_t ops[], size_t opCount);
diff --git a/src/boot/ksdk1.1.0/devBGX.c b/src/boot/ksdk1.1.0/devBGX.c
new file mode 100644
index 0000000..cb644f0
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devBGX.c
@@ -0,0 +1,151 @@
+/*
+	Authored 2021, Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_lpuart_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+
+extern volatile lpuart_state_t		lpuartState;
+extern volatile lpuart_user_config_t	lpuartUserConfig;
+extern volatile WarpUARTDeviceState	deviceBGXState;
+
+static void				uartRxCallback(uint32_t instance, void * uartState);
+static void				powerUpBGX(void);
+static void				powerDownBGX(void);
+
+void
+initBGX(uint16_t operatingVoltageMillivolts)
+{
+	/*
+	 *	Initialize UART and setup callback function.
+	 */
+	lpuartState.txBuff = (uint8_t *)deviceBGXState.uartTXBuffer;
+	lpuartState.rxBuff = (uint8_t *)deviceBGXState.uartRXBuffer;
+
+	LPUART_DRV_InstallRxCallback(	0,						/*	uint32_t instance		*/
+					&uartRxCallback,				/*	lpuart_rx_callback_t function	*/
+					(uint8_t *)deviceBGXState.uartRXBuffer,	/*	uint8_t  rxBuff		*/
+					(void *)0, 					/*	void callbackParam		*/
+					1						/*	bool alwaysEnableRxIrq		*/);
+
+	/*
+	 *	powerUpBGX() depends on the operating voltage configuration,
+	 *	so need to make sure to do that first.
+	 */
+	deviceBGXState.operatingVoltageMillivolts = operatingVoltageMillivolts;
+	powerUpBGX();
+	deviceBGXState.isInitialized = true;
+}
+
+void
+deinitBGX(WarpUARTDeviceState volatile *  deviceStatePointer)
+{
+	powerDownBGX();
+	deviceBGXState.isInitialized = false;
+}
+
+void
+powerUpBGX(void)
+{
+	/*
+	 *	By default, assusme pins are currently disabled (e.g., by a recent lowPowerPinStates())
+	 *
+	 *	Setup:
+	 *		PTA5/kWarpPinBGX_nRST for GPIO
+	 */
+	PORT_HAL_SetMuxMode(PORTA_BASE, 5, kPortMuxAsGpio);
+
+	warpScaleSupplyVoltage(deviceBGXState.operatingVoltageMillivolts);
+
+	/*
+	 *	The BGX datasheet says
+	 *
+	 *		"Reset input, active low. To apply an external reset source to this pin,
+	 *		it is required to only drive this pin low during reset, and let the
+	 *		internal pull-up ensure that reset is released."
+	 *
+	 *	Drive /RST on the BGX high
+	 */
+	GPIO_DRV_SetPinOutput(kWarpPinBGX_nRST);
+}
+
+void
+powerDownBGX()
+{
+	/*
+	 *	The BGX datasheet says
+	 *
+	 *		"Reset input, active low. To apply an external reset source to this pin,
+	 *		it is required to only drive this pin low during reset, and let the
+	 *		internal pull-up ensure that reset is released."
+	 *
+	 *	Since it is not connected to an open-drain input in Warp revC
+	 *	do nothing special with kWarpPinBGX_nRST on powerdown.
+	 */
+
+	return;
+}
+
+void
+uartRxCallback(uint32_t instance, void *  uartState)
+{
+	/*
+	 *	We don't do anything special upon receipt of UART bytes.
+	 *	If we wanted to, that code would go here.
+	 */
+	//warpPrint("In uartRxCallback(), deviceBGXState.uartRXBuffer [%s]\n", deviceBGXState.uartRXBuffer);
+	//SEGGER_RTT_WriteString(0, "In uartRxCallback()...\n");
+
+	return;
+}
diff --git a/src/boot/ksdk1.1.0/devBGX.h b/src/boot/ksdk1.1.0/devBGX.h
new file mode 100644
index 0000000..14065f5
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devBGX.h
@@ -0,0 +1,38 @@
+/*
+	Authored 2021, Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+void		initBGX(uint16_t operatingVoltageMillivolts);
+void		deinitBGX(void);
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devBME680.c b/src/boot/ksdk1.1.0/devBME680.c
new file mode 100644
index 0000000..c332e1b
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devBME680.c
@@ -0,0 +1,294 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell. Additional contributors,
+	2018-onwards, see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+
+
+extern volatile WarpI2CDeviceState	deviceBME680State;
+extern volatile uint8_t			deviceBME680CalibrationValues[];
+extern volatile uint32_t		gWarpI2cBaudRateKbps;
+extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
+extern volatile uint32_t		gWarpSupplySettlingDelayMilliseconds;
+
+
+void
+initBME680(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceBME680State.i2cAddress			= i2cAddress;
+	deviceBME680State.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+writeSensorRegisterBME680(uint8_t deviceRegister, uint8_t payload)
+{
+	uint8_t		payloadByte[1], commandByte[1];
+	i2c_status_t	status;
+
+	if (deviceRegister > 0xFF)
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceBME680State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	commandByte[0] = deviceRegister;
+	payloadByte[0] = payload;
+
+
+	warpScaleSupplyVoltage(deviceBME680State.operatingVoltageMillivolts);
+	warpEnableI2Cpins();
+	status = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C instance */,
+							&slave,
+							commandByte,
+							1,
+							payloadByte,
+							1,
+							gWarpI2cTimeoutMilliseconds);
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+WarpStatus
+readSensorRegisterBME680(uint8_t deviceRegister, int numberOfBytes)
+{
+	uint8_t		cmdBuf[1] = {0xFF};
+	i2c_status_t	status;
+
+
+	USED(numberOfBytes);
+
+	/*
+	 *	We only check to see if it is past the config registers.
+	 *
+	 *	TODO: We should eventually numerate all the valid register addresses
+	 *	(configuration, control, and calibration) here.
+	 */
+	if (deviceRegister > kWarpSensorConfigurationRegisterBME680CalibrationRegion2End)
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceBME680State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	cmdBuf[0] = deviceRegister;
+
+	warpScaleSupplyVoltage(deviceBME680State.operatingVoltageMillivolts);
+	warpEnableI2Cpins();
+	status = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							cmdBuf,
+							1,
+							(uint8_t *)deviceBME680State.i2cBuffer,
+							1,
+							gWarpI2cTimeoutMilliseconds);
+
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+
+WarpStatus
+configureSensorBME680(uint8_t payloadCtrl_Hum, uint8_t payloadCtrl_Meas, uint8_t payloadGas_0)
+{
+	uint8_t		reg, index = 0;
+	WarpStatus	status1, status2, status3, status4 = 0;
+
+
+	warpScaleSupplyVoltage(deviceBME680State.operatingVoltageMillivolts);
+	status1 = writeSensorRegisterBME680(kWarpSensorConfigurationRegisterBME680Ctrl_Hum,
+							payloadCtrl_Hum);
+
+	status2 = writeSensorRegisterBME680(kWarpSensorConfigurationRegisterBME680Ctrl_Meas,
+							payloadCtrl_Meas);
+
+	status3 = writeSensorRegisterBME680(kWarpSensorConfigurationRegisterBME680Ctrl_Gas_0,
+							payloadGas_0);
+
+	/*
+	 *	Read the calibration registers
+	 */
+	for (	reg = kWarpSensorConfigurationRegisterBME680CalibrationRegion1Start;
+		reg < kWarpSensorConfigurationRegisterBME680CalibrationRegion1End;
+		reg++)
+	{
+		status4 |= readSensorRegisterBME680(reg, 1 /* numberOfBytes */);
+		deviceBME680CalibrationValues[index++] = deviceBME680State.i2cBuffer[0];
+	}
+
+	for (	reg = kWarpSensorConfigurationRegisterBME680CalibrationRegion2Start;
+		reg < kWarpSensorConfigurationRegisterBME680CalibrationRegion2End;
+		reg++)
+	{
+		status4 |= readSensorRegisterBME680(reg, 1 /* numberOfBytes */);
+		deviceBME680CalibrationValues[index++] = deviceBME680State.i2cBuffer[0];
+	}
+
+	return (status1 | status2 | status3 | status4);
+}
+
+
+void
+printSensorDataBME680(bool hexModeFlag)
+{
+	uint16_t	readSensorRegisterValueLSB;
+	uint16_t	readSensorRegisterValueMSB;
+	uint16_t	readSensorRegisterValueXLSB;
+	uint32_t	unsignedRawAdcValue;
+	WarpStatus	triggerStatus, i2cReadStatusMSB, i2cReadStatusLSB, i2cReadStatusXLSB;
+
+
+	warpScaleSupplyVoltage(deviceBME680State.operatingVoltageMillivolts);
+
+	/*
+	 *	First, trigger a measurement
+	 */
+	triggerStatus = writeSensorRegisterBME680(kWarpSensorConfigurationRegisterBME680Ctrl_Meas,
+							0b00100101);
+
+	i2cReadStatusMSB = readSensorRegisterBME680(kWarpSensorOutputRegisterBME680press_msb, 1);
+	readSensorRegisterValueMSB = deviceBME680State.i2cBuffer[0];
+	i2cReadStatusLSB = readSensorRegisterBME680(kWarpSensorOutputRegisterBME680press_lsb, 1);
+	readSensorRegisterValueLSB = deviceBME680State.i2cBuffer[0];
+	i2cReadStatusXLSB = readSensorRegisterBME680(kWarpSensorOutputRegisterBME680press_xlsb, 1);
+	readSensorRegisterValueXLSB = deviceBME680State.i2cBuffer[0];
+	unsignedRawAdcValue =
+			((readSensorRegisterValueMSB & 0xFF)  << 12) |
+			((readSensorRegisterValueLSB & 0xFF)  << 4)  |
+			((readSensorRegisterValueXLSB & 0xF0) >> 4);
+
+	if ((triggerStatus != kWarpStatusOK) || (i2cReadStatusMSB != kWarpStatusOK) || (i2cReadStatusLSB != kWarpStatusOK) || (i2cReadStatusXLSB != kWarpStatusOK))
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB, readSensorRegisterValueXLSB);
+		}
+		else
+		{
+			warpPrint(" %u,", unsignedRawAdcValue);
+		}
+	}
+
+	i2cReadStatusMSB = readSensorRegisterBME680(kWarpSensorOutputRegisterBME680temp_msb, 1);
+	readSensorRegisterValueMSB = deviceBME680State.i2cBuffer[0];
+	i2cReadStatusLSB = readSensorRegisterBME680(kWarpSensorOutputRegisterBME680temp_lsb, 1);
+	readSensorRegisterValueLSB = deviceBME680State.i2cBuffer[0];
+	i2cReadStatusXLSB = readSensorRegisterBME680(kWarpSensorOutputRegisterBME680temp_xlsb, 1);
+	readSensorRegisterValueXLSB = deviceBME680State.i2cBuffer[0];
+	unsignedRawAdcValue =
+			((readSensorRegisterValueMSB & 0xFF)  << 12) |
+			((readSensorRegisterValueLSB & 0xFF)  << 4)  |
+			((readSensorRegisterValueXLSB & 0xF0) >> 4);
+	if ((triggerStatus != kWarpStatusOK) || (i2cReadStatusMSB != kWarpStatusOK) || (i2cReadStatusLSB != kWarpStatusOK) || (i2cReadStatusXLSB != kWarpStatusOK))
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB, readSensorRegisterValueXLSB);
+		}
+		else
+		{
+			warpPrint(" %u,", unsignedRawAdcValue);
+		}
+	}
+
+	i2cReadStatusMSB = readSensorRegisterBME680(kWarpSensorOutputRegisterBME680hum_msb, 1);
+	readSensorRegisterValueMSB = deviceBME680State.i2cBuffer[0];
+	i2cReadStatusLSB = readSensorRegisterBME680(kWarpSensorOutputRegisterBME680hum_lsb, 1);
+	readSensorRegisterValueLSB = deviceBME680State.i2cBuffer[0];
+	unsignedRawAdcValue = ((readSensorRegisterValueMSB & 0xFF) << 8) | (readSensorRegisterValueLSB & 0xFF);
+	if ((triggerStatus != kWarpStatusOK) || (i2cReadStatusMSB != kWarpStatusOK) || (i2cReadStatusLSB != kWarpStatusOK))
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %u,", unsignedRawAdcValue);
+		}
+	}
+}
diff --git a/src/boot/ksdk1.1.0/devBME680.h b/src/boot/ksdk1.1.0/devBME680.h
new file mode 100644
index 0000000..9c8cbbe
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devBME680.h
@@ -0,0 +1,44 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell. Additional contributors,
+	2018-onwards, see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+void		initBME680(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts);
+WarpStatus	writeSensorRegisterBME680(uint8_t deviceRegister, uint8_t payload);
+WarpStatus	configureSensorBME680(	uint8_t payloadCtrl_Hum,
+					uint8_t payloadCtrl_Meas,
+					uint8_t payloadGas_0);
+WarpStatus	readSensorRegisterBME680(uint8_t deviceRegister, int numberOfBytes);
+void		printSensorDataBME680(bool hexModeFlag);
diff --git a/src/boot/ksdk1.1.0/devBMX055.c b/src/boot/ksdk1.1.0/devBMX055.c
new file mode 100644
index 0000000..df73f1d
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devBMX055.c
@@ -0,0 +1,707 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell. Additional contributors,
+	2018-onwards, see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+
+
+extern volatile WarpI2CDeviceState	deviceBMX055accelState;
+extern volatile WarpI2CDeviceState	deviceBMX055gyroState;
+extern volatile WarpI2CDeviceState	deviceBMX055magState;
+extern volatile uint32_t		gWarpI2cBaudRateKbps;
+extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
+extern volatile uint32_t		gWarpSupplySettlingDelayMilliseconds;
+
+
+
+/*
+ *	Bosch Sensortec BMX055.
+ */
+void
+initBMX055accel(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceBMX055accelState.i2cAddress			= i2cAddress;
+	deviceBMX055accelState.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+writeSensorRegisterBMX055accel(uint8_t deviceRegister, uint8_t payload, uint16_t menuI2cPullupValue)
+{
+	uint8_t		payloadByte[1], commandByte[1];
+	i2c_status_t	status;
+
+	if (deviceRegister > 0x3F)
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceBMX055accelState.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	commandByte[0] = deviceRegister;
+	payloadByte[0] = payload;
+
+	warpScaleSupplyVoltage(deviceBMX055accelState.operatingVoltageMillivolts);
+	warpEnableI2Cpins();
+	status = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C instance */,
+							&slave,
+							commandByte,
+							1,
+							payloadByte,
+							1,
+							gWarpI2cTimeoutMilliseconds);
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+WarpStatus
+configureSensorBMX055accel(uint8_t payloadPMU_RANGE, uint8_t payloadACCD_HBW, uint16_t menuI2cPullupValue)
+{
+	WarpStatus	status1, status2;
+
+	warpScaleSupplyVoltage(deviceBMX055accelState.operatingVoltageMillivolts);
+	status1 = writeSensorRegisterBMX055accel(kWarpSensorConfigurationRegisterBMX055accelPMU_RANGE /* register address PMU_RANGE */,
+							payloadPMU_RANGE /* payload */,
+							menuI2cPullupValue);
+
+	status2 = writeSensorRegisterBMX055accel(kWarpSensorConfigurationRegisterBMX055accelACCD_HBW /* register address ACCD_HBW */,
+							payloadACCD_HBW /* payload */,
+							menuI2cPullupValue);
+
+	return (status1 | status2);
+}
+
+WarpStatus
+readSensorRegisterBMX055accel(uint8_t deviceRegister, int numberOfBytes)
+{
+	uint8_t		cmdBuf[1] = {0xFF};
+	i2c_status_t	status;
+
+
+	if (deviceRegister > 0x3F)
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceBMX055accelState.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	cmdBuf[0] = deviceRegister;
+
+	warpScaleSupplyVoltage(deviceBMX055accelState.operatingVoltageMillivolts);
+	warpEnableI2Cpins();
+	status = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							cmdBuf,
+							1,
+							(uint8_t *)deviceBMX055accelState.i2cBuffer,
+							numberOfBytes,
+							gWarpI2cTimeoutMilliseconds);
+
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+void
+initBMX055mag(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceBMX055magState.i2cAddress				= i2cAddress;
+	deviceBMX055magState.operatingVoltageMillivolts		= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+writeSensorRegisterBMX055mag(uint8_t deviceRegister, uint8_t payload, uint16_t menuI2cPullupValue)
+{
+	uint8_t		payloadByte[1], commandByte[1];
+	i2c_status_t	status;
+
+	if (deviceRegister > 0x52 || deviceRegister < 0x40)
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceBMX055magState.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	commandByte[0] = deviceRegister;
+	payloadByte[0] = payload;
+
+	warpScaleSupplyVoltage(deviceBMX055magState.operatingVoltageMillivolts);
+	warpEnableI2Cpins();
+	status = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C instance */,
+							&slave,
+							commandByte,
+							1,
+							payloadByte,
+							1,
+							gWarpI2cTimeoutMilliseconds);
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+WarpStatus
+configureSensorBMX055mag(uint8_t payloadPowerCtrl, uint8_t payloadOpMode, uint16_t menuI2cPullupValue)
+{
+	WarpStatus	status1, status2;
+
+	warpScaleSupplyVoltage(deviceBMX055magState.operatingVoltageMillivolts);
+	status1 = writeSensorRegisterBMX055mag(
+							kWarpSensorConfigurationRegisterBMX055magPowerCtrl /* Power and operation modes, self-test, data output rate control registers */,
+							payloadPowerCtrl /* payload */,
+							menuI2cPullupValue);
+
+	status2 = writeSensorRegisterBMX055mag(
+							kWarpSensorConfigurationRegisterBMX055magOpMode /* Operation mode, output data rate and self-test control register */,
+							payloadOpMode /* payload */,
+							menuI2cPullupValue);
+
+	return (status1 | status2);
+}
+
+WarpStatus
+readSensorRegisterBMX055mag(uint8_t deviceRegister, int numberOfBytes)
+{
+	uint8_t		cmdBuf[1] = {0xFF};
+	i2c_status_t	status;
+
+
+	if (deviceRegister > 0x52 || deviceRegister < 0x40)
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceBMX055magState.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	cmdBuf[0] = deviceRegister;
+
+	warpScaleSupplyVoltage(deviceBMX055magState.operatingVoltageMillivolts);
+	warpEnableI2Cpins();
+	status = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							cmdBuf,
+							1,
+							(uint8_t *)deviceBMX055magState.i2cBuffer,
+							numberOfBytes,
+							gWarpI2cTimeoutMilliseconds);
+
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+void
+initBMX055gyro(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceBMX055gyroState.i2cAddress			= i2cAddress;
+	deviceBMX055gyroState.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+writeSensorRegisterBMX055gyro(uint8_t deviceRegister, uint8_t payload, uint16_t menuI2cPullupValue)
+{
+	uint8_t		payloadByte[1], commandByte[1];
+	i2c_status_t	status;
+
+	if (deviceRegister > 0x3F)
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceBMX055gyroState.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	commandByte[0] = deviceRegister;
+	payloadByte[0] = payload;
+
+	warpScaleSupplyVoltage(deviceBMX055gyroState.operatingVoltageMillivolts);
+	warpEnableI2Cpins();
+	status = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C instance */,
+							&slave,
+							commandByte,
+							1,
+							payloadByte,
+							1,
+							gWarpI2cTimeoutMilliseconds);
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+WarpStatus
+configureSensorBMX055gyro(uint8_t payloadRANGE, uint8_t payloadBW, uint8_t payloadLPM1, uint8_t payloadRATE_HBW, uint16_t menuI2cPullupValue)
+{
+	WarpStatus	status1, status2, status3, status4;
+
+
+	warpScaleSupplyVoltage(deviceBMX055gyroState.operatingVoltageMillivolts);
+
+	status1 = writeSensorRegisterBMX055gyro(kWarpSensorConfigurationRegisterBMX055gyroRANGE /* register address RANGE */,
+							payloadRANGE /* payload */, 
+							menuI2cPullupValue);
+
+	status2 = writeSensorRegisterBMX055gyro(kWarpSensorConfigurationRegisterBMX055gyroBW/* register address filter bandwidth */,
+							payloadBW /* payload */,
+							menuI2cPullupValue);
+
+	status3 = writeSensorRegisterBMX055gyro(kWarpSensorConfigurationRegisterBMX055gyroLPM1/* register address LPM1 */,
+							payloadLPM1 /* payload */,
+							menuI2cPullupValue);
+
+	status4 = writeSensorRegisterBMX055gyro(kWarpSensorConfigurationRegisterBMX055gyroRATE_HBW/* register address RATE_HBW */,
+							payloadLPM1 /* payload */,
+							menuI2cPullupValue);
+
+	return (status1 | status2 | status3 | status4);
+}
+
+WarpStatus
+readSensorRegisterBMX055gyro(uint8_t deviceRegister, int numberOfBytes)
+{
+	uint8_t		cmdBuf[1] = {0xFF};
+	i2c_status_t	status;
+
+
+	USED(numberOfBytes);
+	if (deviceRegister > 0x3F)
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceBMX055gyroState.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	cmdBuf[0] = deviceRegister;
+
+	warpScaleSupplyVoltage(deviceBMX055gyroState.operatingVoltageMillivolts);
+	warpEnableI2Cpins();
+	status = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							cmdBuf,
+							1,
+							(uint8_t *)deviceBMX055gyroState.i2cBuffer,
+							numberOfBytes,
+							gWarpI2cTimeoutMilliseconds);
+
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+void
+printSensorDataBMX055accel(bool hexModeFlag)
+{
+	uint16_t	readSensorRegisterValueLSB;
+	uint16_t	readSensorRegisterValueMSB;
+	int16_t		readSensorRegisterValueCombined;
+	WarpStatus	i2cReadStatus;
+
+
+	warpScaleSupplyVoltage(deviceBMX055accelState.operatingVoltageMillivolts);
+	i2cReadStatus = readSensorRegisterBMX055accel(kWarpSensorOutputRegisterBMX055accelACCD_X_LSB, 2 /* numberOfBytes */);
+	readSensorRegisterValueLSB = deviceBMX055accelState.i2cBuffer[0];
+	readSensorRegisterValueMSB = deviceBMX055accelState.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 4) | (readSensorRegisterValueLSB >> 4);
+
+	/*
+	 *	Sign extend the 12-bit value based on knowledge that upper 4 bit are 0:
+	 */
+	readSensorRegisterValueCombined = (readSensorRegisterValueCombined ^ (1 << 11)) - (1 << 11);
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+	i2cReadStatus = readSensorRegisterBMX055accel(kWarpSensorOutputRegisterBMX055accelACCD_Y_LSB, 2 /* numberOfBytes */);
+	readSensorRegisterValueLSB = deviceBMX055accelState.i2cBuffer[0];
+	readSensorRegisterValueMSB = deviceBMX055accelState.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 4) | (readSensorRegisterValueLSB >> 4);
+
+	/*
+	 *	Sign extend the 12-bit value based on knowledge that upper 4 bit are 0:
+	 */
+	readSensorRegisterValueCombined = (readSensorRegisterValueCombined ^ (1 << 11)) - (1 << 11);
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+	i2cReadStatus = readSensorRegisterBMX055accel(kWarpSensorOutputRegisterBMX055accelACCD_Z_LSB, 2 /* numberOfBytes */);
+	readSensorRegisterValueLSB = deviceBMX055accelState.i2cBuffer[0];
+	readSensorRegisterValueMSB = deviceBMX055accelState.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 4) | (readSensorRegisterValueLSB >> 4);
+
+	/*
+	 *	Sign extend the 12-bit value based on knowledge that upper 4 bit are 0:
+	 */
+	readSensorRegisterValueCombined = (readSensorRegisterValueCombined ^ (1 << 11)) - (1 << 11);
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+	i2cReadStatus = readSensorRegisterBMX055accel(kWarpSensorOutputRegisterBMX055accelACCD_TEMP, 1 /* numberOfBytes */);
+	readSensorRegisterValueCombined = deviceBMX055accelState.i2cBuffer[0];
+
+	/*
+	 *	Sign extend the 8-bit value based on knowledge that upper 8 bit are 0:
+	 */
+	readSensorRegisterValueCombined = (readSensorRegisterValueCombined ^ (1 << 7)) - (1 << 7);
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x,", readSensorRegisterValueCombined);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+}
+
+void
+printSensorDataBMX055gyro(bool hexModeFlag)
+{
+	uint16_t	readSensorRegisterValueLSB;
+	uint16_t	readSensorRegisterValueMSB;
+	int16_t		readSensorRegisterValueCombined;
+	WarpStatus	i2cReadStatus;
+
+
+	warpScaleSupplyVoltage(deviceBMX055gyroState.operatingVoltageMillivolts);
+	i2cReadStatus = readSensorRegisterBMX055gyro(kWarpSensorOutputRegisterBMX055gyroRATE_X_LSB, 2 /* numberOfBytes */);
+	readSensorRegisterValueLSB = deviceBMX055gyroState.i2cBuffer[0];
+	readSensorRegisterValueMSB = deviceBMX055gyroState.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 8) | (readSensorRegisterValueLSB & 0xFF);
+
+	/*
+	 *	NOTE: Here, we don't need to manually sign extend since we are packing directly into an int16_t
+	 */
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+	i2cReadStatus = readSensorRegisterBMX055gyro(kWarpSensorOutputRegisterBMX055gyroRATE_Y_LSB, 2 /* numberOfBytes */);
+	readSensorRegisterValueLSB = deviceBMX055gyroState.i2cBuffer[0];
+	readSensorRegisterValueMSB = deviceBMX055gyroState.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 8) | (readSensorRegisterValueLSB & 0xFF);
+
+	/*
+	 *	NOTE: Here, we don't need to manually sign extend since we are packing directly into an int16_t
+	 */
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+	i2cReadStatus = readSensorRegisterBMX055gyro(kWarpSensorOutputRegisterBMX055gyroRATE_Z_LSB, 2 /* numberOfBytes */);
+	readSensorRegisterValueLSB = deviceBMX055gyroState.i2cBuffer[0];
+	readSensorRegisterValueMSB = deviceBMX055gyroState.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 8) | (readSensorRegisterValueLSB & 0xFF);
+
+	/*
+	 *	NOTE: Here, we don't need to manually sign extend since we are packing directly into an int16_t
+	 */
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+}
+
+void
+printSensorDataBMX055mag(bool hexModeFlag)
+{
+	uint16_t	readSensorRegisterValueLSB;
+	uint16_t	readSensorRegisterValueMSB;
+	int16_t		readSensorRegisterValueCombined;
+	WarpStatus	i2cReadStatus;
+
+
+	warpScaleSupplyVoltage(deviceBMX055magState.operatingVoltageMillivolts);
+	i2cReadStatus = readSensorRegisterBMX055mag(kWarpSensorOutputRegisterBMX055magX_LSB, 2 /* numberOfBytes */);
+	readSensorRegisterValueLSB = deviceBMX055magState.i2cBuffer[0];
+	readSensorRegisterValueMSB = deviceBMX055magState.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 5) | (readSensorRegisterValueLSB >> 3);
+
+	/*
+	 *	Sign extend the 13-bit value based on knowledge that upper 3 bit are 0:
+	 */
+	readSensorRegisterValueCombined = (readSensorRegisterValueCombined ^ (1 << 12)) - (1 << 12);
+
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+	i2cReadStatus = readSensorRegisterBMX055mag(kWarpSensorOutputRegisterBMX055magY_LSB, 2 /* numberOfBytes */);
+	readSensorRegisterValueLSB = deviceBMX055magState.i2cBuffer[0];
+	readSensorRegisterValueMSB = deviceBMX055magState.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 5) | (readSensorRegisterValueLSB >> 3);
+
+	/*
+	 *	Sign extend the 13-bit value based on knowledge that upper 4 bit are 0:
+	 */
+	readSensorRegisterValueCombined = (readSensorRegisterValueCombined ^ (1 << 12)) - (1 << 12);
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+	i2cReadStatus = readSensorRegisterBMX055mag(kWarpSensorOutputRegisterBMX055magZ_LSB, 2 /* numberOfBytes */);
+	readSensorRegisterValueLSB = deviceBMX055magState.i2cBuffer[0];
+	readSensorRegisterValueMSB = deviceBMX055magState.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 7) | (readSensorRegisterValueLSB >> 1);
+
+	/*
+	 *	Sign extend the 15-bit value based on knowledge that upper 1 bit are 0:
+	 */
+	readSensorRegisterValueCombined = (readSensorRegisterValueCombined ^ (1 << 14)) - (1 << 14);
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+	i2cReadStatus = readSensorRegisterBMX055mag(kWarpSensorOutputRegisterBMX055magRHALL_LSB, 2 /* numberOfBytes */);
+	readSensorRegisterValueLSB = deviceBMX055magState.i2cBuffer[0];
+	readSensorRegisterValueMSB = deviceBMX055magState.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 6) | (readSensorRegisterValueLSB >> 2);
+
+	/*
+	 *	Sign extend the 14-bit value based on knowledge that upper 2 bit are 0:
+	 */
+	readSensorRegisterValueCombined = (readSensorRegisterValueCombined ^ (1 << 13)) - (1 << 13);
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+}
diff --git a/src/boot/ksdk1.1.0/devBMX055.h b/src/boot/ksdk1.1.0/devBMX055.h
new file mode 100644
index 0000000..72173bc
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devBMX055.h
@@ -0,0 +1,64 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell. Additional contributors,
+	2018-onwards, see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+void		initBMX055accel(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts);
+void		initBMX055gyro(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts);
+void		initBMX055mag(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts);
+
+WarpStatus	writeSensorRegisterBMX055accel(uint8_t deviceRegister, uint8_t payload, uint16_t menuI2cPullupValue);
+WarpStatus	writeSensorRegisterBMX055gyro(uint8_t deviceRegister, uint8_t payload, uint16_t menuI2cPullupValue);
+WarpStatus	writeSensorRegisterBMX055mag(uint8_t deviceRegister, uint8_t payload, uint16_t menuI2cPullupValue);
+
+WarpStatus	configureSensorBMX055accel(uint8_t payloadPMU_RANGE,
+					uint8_t payloadACCD_HBW,
+					uint16_t menuI2cPullupValue);
+WarpStatus	configureSensorBMX055gyro(uint8_t payloadRANGE,
+					uint8_t payloadBW,
+					uint8_t payloadLPM1,
+					uint8_t payloadRATE_HBW,
+					uint16_t menuI2cPullupValue);
+WarpStatus	configureSensorBMX055mag(uint8_t payloadPowerCtrl,
+					uint8_t payloadOpMode,
+					uint16_t menuI2cPullupValue);
+
+WarpStatus	readSensorRegisterBMX055accel(uint8_t deviceRegister, int numberOfBytes);
+WarpStatus	readSensorRegisterBMX055gyro(uint8_t deviceRegister, int numberOfBytes);
+WarpStatus	readSensorRegisterBMX055mag(uint8_t deviceRegister, int numberOfBytes);
+
+void		printSensorDataBMX055accel(bool hexModeFlag);
+void		printSensorDataBMX055gyro(bool hexModeFlag);
+void		printSensorDataBMX055mag(bool hexModeFlag);
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devCCS811.c b/src/boot/ksdk1.1.0/devCCS811.c
new file mode 100644
index 0000000..192a124
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devCCS811.c
@@ -0,0 +1,353 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell. Additional contributors,
+	2018-onwards, see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+
+extern volatile WarpI2CDeviceState	deviceCCS811State;
+extern volatile uint32_t		gWarpI2cBaudRateKbps;
+extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
+extern volatile uint32_t		gWarpSupplySettlingDelayMilliseconds;
+
+
+
+/*
+ *	CCS811.
+ */
+void
+initCCS811(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceCCS811State.i2cAddress			= i2cAddress;
+	deviceCCS811State.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+writeSensorRegisterCCS811(uint8_t deviceRegister, uint8_t *payload, uint16_t menuI2cPullupValue)
+{
+	uint8_t		commandByte[1];
+	uint8_t		payloadSize;
+	i2c_status_t	status;
+
+	switch (deviceRegister)
+	{
+		case 0x01:
+		{
+			payloadSize = 1;
+			break;
+		}
+
+		case 0x11:
+		{
+			payloadSize = 2;
+			break;
+		}
+
+		case 0x05:
+		case 0xF1:
+		case 0xFF:
+		{
+			payloadSize = 4;
+			break;
+		}
+
+		case 0x10:
+		{
+			payloadSize = 5;
+			break;
+		}
+
+		case 0xF2:
+		{
+			payloadSize = 9;
+			break;
+		}
+
+		case 0xF3:
+		case 0xF4:
+		{
+			payloadSize = 0;
+			break;
+		}
+
+		default:
+		{
+			return kWarpStatusBadDeviceCommand;
+		}
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceCCS811State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	commandByte[0] = deviceRegister;
+
+	warpScaleSupplyVoltage(deviceCCS811State.operatingVoltageMillivolts);
+	warpEnableI2Cpins();
+	if(payloadSize)
+	{
+		status = I2C_DRV_MasterSendDataBlocking(
+								0 /* I2C instance */,
+								&slave,
+								commandByte,
+								1,
+								payload,
+								payloadSize,
+								gWarpI2cTimeoutMilliseconds);
+	}
+	else
+	{
+		status = I2C_DRV_MasterSendDataBlocking(
+						0 /* I2C instance */,
+						&slave,
+						commandByte,
+						1,
+						NULL,
+						0,
+						gWarpI2cTimeoutMilliseconds);
+	}
+
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+WarpStatus
+configureSensorCCS811(uint8_t *payloadMEAS_MODE, uint16_t menuI2cPullupValue)
+{
+	WarpStatus	status1, status2;
+
+	/*
+	 *	See https://narcisaam.github.io/Init_Device/ for more information
+	 *	on how to initialize and configure CCS811
+	 */
+
+	/*
+	 *	Delay needed before start of i2c.
+	 */
+	OSA_TimeDelay(20);
+
+	warpScaleSupplyVoltage(deviceCCS811State.operatingVoltageMillivolts);
+	status1 = writeSensorRegisterCCS811(kWarpSensorConfigurationRegisterCCS811APP_START /* register address APP_START */,
+							payloadMEAS_MODE /* Dummy value */,
+							menuI2cPullupValue);
+
+	/*
+	 *	Wait for the sensor to change to application mode
+	 */
+	OSA_TimeDelay(500);
+
+	status2 = writeSensorRegisterCCS811(kWarpSensorConfigurationRegisterCCS811MEAS_MODE /* register address MEAS_MODE */,
+							payloadMEAS_MODE /* payload: 3F initial reset */,
+							menuI2cPullupValue);
+
+	/*
+	 *	After writing to MEAS_MODE to configure the sensor in mode 1-4,
+	 *	run CCS811 for 20 minutes, before accurate readings are generated.
+	 */
+
+	return (status1 | status2);
+}
+
+WarpStatus
+readSensorRegisterCCS811(uint8_t deviceRegister, int numberOfBytes)
+{
+	uint8_t		cmdBuf[1] = {0xFF};
+	i2c_status_t	returnValue;
+
+
+	if ((deviceRegister > 0xFF) || (numberOfBytes > kWarpSizesI2cBufferBytes))
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceCCS811State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	cmdBuf[0] = deviceRegister;
+
+	warpScaleSupplyVoltage(deviceCCS811State.operatingVoltageMillivolts);
+	warpEnableI2Cpins();
+	returnValue = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							cmdBuf,
+							1,
+							(uint8_t *)deviceCCS811State.i2cBuffer,
+							numberOfBytes,
+							gWarpI2cTimeoutMilliseconds);
+
+	if (returnValue != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+void
+printSensorDataCCS811(bool hexModeFlag)
+{
+	uint16_t	readSensorRegisterValueLSB;
+	uint16_t	readSensorRegisterValueMSB;
+	int16_t		readSensorRegisterValueCombined;
+	int16_t		equivalentCO2, TVOC;
+	WarpStatus	i2cReadStatus;
+
+
+	warpScaleSupplyVoltage(deviceCCS811State.operatingVoltageMillivolts);
+	i2cReadStatus	= readSensorRegisterCCS811(kWarpSensorOutputRegisterCCS811ALG_DATA, 4 /* numberOfBytes */);
+	equivalentCO2	= (deviceCCS811State.i2cBuffer[0] << 8) | deviceCCS811State.i2cBuffer[1];
+	TVOC		= (deviceCCS811State.i2cBuffer[2] << 8) | deviceCCS811State.i2cBuffer[3];
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----, ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x, 0x%02x 0x%02x,",
+				deviceCCS811State.i2cBuffer[3],
+				deviceCCS811State.i2cBuffer[2],
+				deviceCCS811State.i2cBuffer[1],
+				deviceCCS811State.i2cBuffer[0]);
+		}
+		else
+		{
+			warpPrint(" %d, %d,", equivalentCO2, TVOC);
+		}
+	}
+
+	i2cReadStatus = readSensorRegisterCCS811(kWarpSensorOutputRegisterCCS811RAW_DATA, 2 /* numberOfBytes */);
+	readSensorRegisterValueLSB = deviceCCS811State.i2cBuffer[0];
+	readSensorRegisterValueMSB = deviceCCS811State.i2cBuffer[1];
+
+	/*
+	 *	RAW ADC value. See CCS811 manual, Figure 15:
+	 */
+	readSensorRegisterValueCombined =
+						((readSensorRegisterValueLSB & 0x03) << 8) |
+						(readSensorRegisterValueMSB & 0xFF);
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+	/*
+	 *	Get Voltage across V_REF
+	 */
+	i2cReadStatus = readSensorRegisterCCS811(kWarpSensorOutputRegisterCCS811RAW_REF_NTC, 4 /* numberOfBytes */);
+	readSensorRegisterValueLSB = deviceCCS811State.i2cBuffer[0];
+	readSensorRegisterValueMSB = deviceCCS811State.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB) << 8) | (readSensorRegisterValueLSB);
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+	/*
+	 *	Get Voltage across R_NTC
+	 */
+	readSensorRegisterValueLSB = deviceCCS811State.i2cBuffer[2];
+	readSensorRegisterValueMSB = deviceCCS811State.i2cBuffer[3];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB) << 8) | (readSensorRegisterValueLSB);
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+}
diff --git a/src/boot/ksdk1.1.0/devCCS811.h b/src/boot/ksdk1.1.0/devCCS811.h
new file mode 100644
index 0000000..0d2176d
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devCCS811.h
@@ -0,0 +1,42 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell. Additional contributors,
+	2018-onwards, see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+void		initCCS811(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts);
+WarpStatus	writeSensorRegisterCCS811(uint8_t deviceRegister, uint8_t *payload, uint16_t menuI2cPullupValue);
+WarpStatus	configureSensorCCS811(uint8_t *payloadMEAS_MODE, uint16_t menuI2cPullupValue);
+WarpStatus	readSensorRegisterCCS811(uint8_t deviceRegister, int numberOfBytes);
+void		printSensorDataCCS811(bool hexModeFlag);
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devHDC1000.c b/src/boot/ksdk1.1.0/devHDC1000.c
new file mode 100644
index 0000000..8c9b0ac
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devHDC1000.c
@@ -0,0 +1,300 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell. Additional contributors,
+	2018-onwards, see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+
+extern volatile WarpI2CDeviceState	deviceHDC1000State;
+extern volatile uint32_t		gWarpI2cBaudRateKbps;
+extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
+extern volatile uint32_t		gWarpSupplySettlingDelayMilliseconds;
+
+
+void
+initHDC1000(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceHDC1000State.i2cAddress			= i2cAddress;
+	deviceHDC1000State.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+writeSensorRegisterHDC1000(uint8_t deviceRegister, uint16_t payload, uint16_t menuI2cPullupValue)
+{
+	uint8_t		payloadByte[2], commandByte[1];
+	i2c_status_t	returnValue;
+
+	switch (deviceRegister)
+	{
+		case 0x02:
+		{
+			/* OK */
+			break;
+		}
+		
+		default:
+		{
+			return kWarpStatusBadDeviceCommand;
+		}
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceHDC1000State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	warpScaleSupplyVoltage(deviceHDC1000State.operatingVoltageMillivolts);
+
+	commandByte[0] = deviceRegister;
+	payloadByte[0] = (payload>>8) & 0xFF; /* MSB first */
+	payloadByte[1] = payload & 0xFF; /* LSB */
+	returnValue = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C instance */,
+							&slave,
+							commandByte,
+							1,
+							payloadByte,
+							2,
+							1000);
+	if (returnValue != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+WarpStatus
+readSensorRegisterHDC1000(uint8_t deviceRegister, int numberOfBytes)
+{
+	uint8_t		cmdBuf[1] = {0xFF};
+	i2c_status_t	status1, status2;
+
+
+	i2c_device_t slave =
+	{
+		.address = deviceHDC1000State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	USED(numberOfBytes);
+
+	warpScaleSupplyVoltage(deviceHDC1000State.operatingVoltageMillivolts);
+	warpEnableI2Cpins();
+	if (deviceRegister == 0 || deviceRegister == 1)
+	{
+		/*
+			Steps:
+			(1)	Write transaction beginning with start condition, slave address, 
+				and pointer address (0x02 == configuration register) and 2
+				bytes of config values to be written  (total payload of 3 bytes).
+
+			(2)	Write transaction beginning with start condition, slave address, 
+				and pointer address (0x00/0x01 == humidity/temperature). Total
+				payload is just 1 byte. (Trigger measurement)
+
+			(3)	Wait 10ms for conversion to complete.
+
+			(4)	Read transaction beginning with start condition, followed by
+				slave address, and read 2 byte payload
+
+			Note: to get this to work, had to make the following changes to the default KSDK I2C driver:
+
+			diff KSDK_1.1.0/platform/drivers/src/i2c/fsl_i2c_master_driver.c KSDK_1.1.0/platform/drivers/src/i2c/fsl_i2c_master_driver.c.orig.pip
+			617c617
+			< //    assert(txBuff);
+			---
+			>     assert(txBuff);
+			657,664d656
+			<     //
+			<     //  If txSize is zero, don't try to send anything
+			<     //
+			<     if (txSize == 0)
+			<     {
+			<             goto skip;
+			<     }
+			<     
+			683d674
+			< skip:
+
+			Also added a check to KSDK_1.1.0/platform/hal/src/i2c/fsl_i2c_hal.c so we don't assert whern can't find the device on I2C
+		*/
+
+		/*
+		 *	Step 1: Trigger temperature/humidity measurement
+		 */
+		cmdBuf[0] = deviceRegister;
+
+		status1 = I2C_DRV_MasterSendDataBlocking(
+								0 /* I2C peripheral instance */,
+								&slave,
+								cmdBuf,
+								1,
+								NULL,
+								0,
+								gWarpI2cTimeoutMilliseconds);
+
+		/*
+		 *	Step 2: Wait for max 6.5ms for conversion completion (see Table 7.5 of HDC1000 datasheet)
+		 */
+		OSA_TimeDelay(7);
+
+		/*
+		 *	Step 3: Read temp/humidity
+		 */
+		status2 = I2C_DRV_MasterReceiveDataBlocking(
+								0 /* I2C peripheral instance */,
+								&slave,
+								NULL,
+								0,
+								(uint8_t *)deviceHDC1000State.i2cBuffer,
+								numberOfBytes,
+								gWarpI2cTimeoutMilliseconds);
+
+		if ((status1 != kStatus_I2C_Success) || (status2 != kStatus_I2C_Success))
+		{
+			return kWarpStatusDeviceCommunicationFailed;
+		}
+	}
+	else
+	{
+		cmdBuf[0] = deviceRegister;
+
+		status1 = I2C_DRV_MasterReceiveDataBlocking(
+								0 /* I2C peripheral instance */,
+								&slave,
+								cmdBuf,
+								1,
+								(uint8_t *)deviceHDC1000State.i2cBuffer,
+								numberOfBytes,
+								gWarpI2cTimeoutMilliseconds);
+
+		if (status1 != kStatus_I2C_Success)
+		{
+			return kWarpStatusDeviceCommunicationFailed;
+		}
+	}
+
+	return kWarpStatusOK;
+}
+
+void
+printSensorDataHDC1000(bool hexModeFlag)
+{
+	uint16_t	readSensorRegisterValueLSB;
+	uint16_t	readSensorRegisterValueMSB;
+	int16_t		readSensorRegisterValueCombined;
+	WarpStatus	i2cReadStatus;
+
+
+	warpScaleSupplyVoltage(deviceHDC1000State.operatingVoltageMillivolts);
+	i2cReadStatus = readSensorRegisterHDC1000(kWarpSensorOutputRegisterHDC1000Temperature, 2 /* numberOfBytes */);
+	readSensorRegisterValueMSB = deviceHDC1000State.i2cBuffer[0];
+	readSensorRegisterValueLSB = deviceHDC1000State.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 8) | (readSensorRegisterValueLSB & 0xFF);
+
+	/*
+	 *	NOTE: Here, we don't need to manually sign extend since we are packing directly into an int16_t
+	 */
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			/*
+			 *	See Section 8.6.1 of the HDC1000 manual for the conversion to temperature.
+			 */
+			warpPrint(" %d,", (readSensorRegisterValueCombined*165 / (1u << 16)) - 40);
+		}
+	}
+
+	i2cReadStatus = readSensorRegisterHDC1000(kWarpSensorOutputRegisterHDC1000Humidity, 2 /* numberOfBytes */);
+	readSensorRegisterValueMSB = deviceHDC1000State.i2cBuffer[0];
+	readSensorRegisterValueLSB = deviceHDC1000State.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 8) | (readSensorRegisterValueLSB & 0xFF);
+
+	/*
+	 *	NOTE: Here, we don't need to manually sign extend since we are packing directly into an int16_t
+	 */
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			/*
+			 *	See Section 8.6.2 of the HDC1000 manual for the conversion to temperature.
+			 */
+			warpPrint(" %d,", (readSensorRegisterValueCombined*100 / (1u << 16)));
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devHDC1000.h b/src/boot/ksdk1.1.0/devHDC1000.h
new file mode 100644
index 0000000..751d3ce
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devHDC1000.h
@@ -0,0 +1,42 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell. Additional contributors,
+	2018-onwards, see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+void		initHDC1000(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts);
+WarpStatus	writeSensorRegisterHDC1000(uint8_t deviceRegister, uint16_t payload, uint16_t menuI2cPullupValue);
+WarpStatus	readSensorRegisterHDC1000(uint8_t deviceRegister, int numberOfBytes);
+void		printSensorDataHDC1000(bool hexModeFlag);
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devICE40.c b/src/boot/ksdk1.1.0/devICE40.c
new file mode 100644
index 0000000..0e0fe16
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devICE40.c
@@ -0,0 +1,36 @@
+/*
+	Authored 2021. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
diff --git a/src/boot/ksdk1.1.0/devICE40.h b/src/boot/ksdk1.1.0/devICE40.h
new file mode 100644
index 0000000..9689c11
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devICE40.h
@@ -0,0 +1,39 @@
+/*
+	Authored 2021. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+void		initICE40(int chipSelectIoPinID, uint16_t operatingVoltageMillivolts);
+
diff --git a/src/boot/ksdk1.1.0/devINA219.c b/src/boot/ksdk1.1.0/devINA219.c
deleted file mode 100644
index c2fe295..0000000
--- a/src/boot/ksdk1.1.0/devINA219.c
+++ /dev/null
@@ -1,249 +0,0 @@
-#include <stdlib.h>
-
-/*
- *	config.h needs to come first
- */
-#include "config.h"
-
-#include "fsl_misc_utilities.h"
-#include "fsl_device_registers.h"
-#include "fsl_i2c_master_driver.h"
-#include "fsl_spi_master_driver.h"
-#include "fsl_rtc_driver.h"
-#include "fsl_clock_manager.h"
-#include "fsl_power_manager.h"
-#include "fsl_mcglite_hal.h"
-#include "fsl_port_hal.h"
-
-#include "gpio_pins.h"
-#include "SEGGER_RTT.h"
-#include "warp.h"
-
-
-extern volatile WarpI2CDeviceState	deviceINA219State;
-extern volatile uint32_t		gWarpI2cBaudRateKbps;
-extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
-extern volatile uint32_t		gWarpSupplySettlingDelayMilliseconds;
-
-
-
-void
-initINA219(const uint8_t i2cAddress)
-{
-	deviceINA219State.i2cAddress			= i2cAddress;
-
-	return;
-}
-
-WarpStatus
-writeSensorRegisterINA219(uint8_t deviceRegister, uint16_t payload)
-{
-	uint8_t		payloadBytes[2], commandByte[1];
-	i2c_status_t	returnValue;
-
-	switch (deviceRegister)
-	{
-		case 0x00: case 0x01: case 0x02: case 0x03:
-		case 0x04: case 0x05:
-		{
-			/* OK */
-			break;
-		}
-		
-		default:
-		{
-			return kWarpStatusBadDeviceCommand;
-		}
-	}
-
-	i2c_device_t slave =
-	{
-		.address = deviceINA219State.i2cAddress,
-		.baudRate_kbps = gWarpI2cBaudRateKbps
-	};
-
-	commandByte[0] = deviceRegister;
-
-	payloadBytes[1]= payload & 0xff;
-	payloadBytes[0]= (payload >> 8);
-
-	warpPrint("\n\n------- BYTE CONVERSION -------\n");
-	warpPrint("uint16_t payload recieved: %d\n", payload);
-	warpPrint("payloadBytes[1] post conversion: %d\n", payloadBytes[1]);
-	warpPrint("payloadBytes[0] post conversion: %d\n", payloadBytes[0]);
-	warpPrint("-----------------------\n\n");
-
-	warpEnableI2Cpins();
-
-	returnValue = I2C_DRV_MasterSendDataBlocking(
-							0 /* I2C instance */,
-							&slave,
-							commandByte,
-							1,
-							payloadBytes,
-							2,
-							gWarpI2cTimeoutMilliseconds);
-	if (returnValue != kStatus_I2C_Success)
-	{
-		return kWarpStatusDeviceCommunicationFailed;
-	}
-
-	return kWarpStatusOK;
-}
-
-WarpStatus
-readSensorRegisterINA219(uint8_t deviceRegister, int numberOfBytes)
-{
-	uint8_t		cmdBuf[1]	= {0xFF};
-	i2c_status_t	status1, status2;
-
-
-	USED(numberOfBytes);
-	i2c_device_t slave =
-	{
-		.address = deviceINA219State.i2cAddress,
-		.baudRate_kbps = gWarpI2cBaudRateKbps
-	};
-
-
-	cmdBuf[0] = deviceRegister;
-	warpEnableI2Cpins();
-
-	status1 = I2C_DRV_MasterSendDataBlocking(
-							0 /* I2C peripheral instance */,
-							&slave,
-							cmdBuf,
-							1,
-							NULL,
-							0,
-							gWarpI2cTimeoutMilliseconds);
-
-	status2 = I2C_DRV_MasterReceiveDataBlocking(
-							0 /* I2C peripheral instance */,
-							&slave,
-							cmdBuf,
-							1,
-							(uint8_t *)deviceINA219State.i2cBuffer,
-							numberOfBytes,
-							gWarpI2cTimeoutMilliseconds);
-
-	if ((status1 != kStatus_I2C_Success) || (status2 != kStatus_I2C_Success))
-	{
-		return kWarpStatusDeviceCommunicationFailed;
-	}
-
-	return kWarpStatusOK;
-}
-
-void
-printSensorDataINA219(bool hexModeFlag)
-{
-	uint16_t	readSensorRegisterValueLSB;
-	uint16_t	readSensorRegisterValueMSB;
-	int16_t		readSensorRegisterValueCombined;
-	// int8_t		readSensorRegisterSignedByte;
-	WarpStatus	i2cReadStatus;
-
-
-	for (uint8_t i = 0; i < 6; i++){
-		warpPrint("\nReading from %d: ", i);
-		i2cReadStatus = readSensorRegisterINA219(i, 2 /* numberOfBytes */);
-		readSensorRegisterValueMSB = deviceINA219State.i2cBuffer[0];
-		readSensorRegisterValueLSB = deviceINA219State.i2cBuffer[1];
-		readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 8) | (readSensorRegisterValueLSB & 0xFF);
-
-		/*
-		*	NOTE: Here, we don't need to manually sign extend since we are packing directly into an int16_t
-		*/
-
-		if (i2cReadStatus != kWarpStatusOK)
-		{
-			warpPrint(" ----,");
-		}
-		else
-		{
-			if (hexModeFlag)
-			{
-				warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
-			}
-			else
-			{
-				warpPrint(" %d,", readSensorRegisterValueCombined);
-			}
-		}
-	}
-}
-
-void
-printCurrentDataINA219(bool hexModeFlag)
-{
-	uint16_t	readSensorRegisterValueLSB;
-	uint16_t	readSensorRegisterValueMSB;
-	int16_t		readSensorRegisterValueCombined;
-	// int8_t		readSensorRegisterSignedByte;
-	WarpStatus	i2cReadStatus;
-
-		i2cReadStatus = readSensorRegisterINA219(kWarpSensorOutputRegisterINA219_CURRENT_MSB, 2 /* numberOfBytes */);
-		readSensorRegisterValueMSB = deviceINA219State.i2cBuffer[0];
-		readSensorRegisterValueLSB = deviceINA219State.i2cBuffer[1];
-		readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 8) | (readSensorRegisterValueLSB & 0xFF);
-
-		/*
-		*	NOTE: Here, we don't need to manually sign extend since we are packing directly into an int16_t
-		*/
-
-		if (i2cReadStatus != kWarpStatusOK)
-		{
-			warpPrint(" ----,");
-		}
-		else
-		{
-			if (hexModeFlag)
-			{
-				warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
-			}
-			else
-			{
-				readSensorRegisterValueCombined = (readSensorRegisterValueCombined/20)*50;
-				warpPrint("%d\n,", readSensorRegisterValueCombined);
-			}
-		}
-}
-
-void
-take1000CurrentMeasurements(bool hexModeFlag)
-{
-	uint16_t	readSensorRegisterValueLSB;
-	uint16_t	readSensorRegisterValueMSB;
-	int16_t		readSensorRegisterValueCombined;
-	// int8_t		readSensorRegisterSignedByte;
-	WarpStatus	i2cReadStatus;
-
-		for (int i = 0; i < 1000; i++){
-			i2cReadStatus = readSensorRegisterINA219(kWarpSensorOutputRegisterINA219_CURRENT_MSB, 2 /* numberOfBytes */);
-			readSensorRegisterValueMSB = deviceINA219State.i2cBuffer[0];
-			readSensorRegisterValueLSB = deviceINA219State.i2cBuffer[1];
-			readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 8) | (readSensorRegisterValueLSB & 0xFF);
-
-			/*
-			*	NOTE: Here, we don't need to manually sign extend since we are packing directly into an int16_t
-			*/
-
-			if (i2cReadStatus != kWarpStatusOK)
-			{
-				warpPrint(" ----,");
-			}
-			else
-			{
-				if (hexModeFlag)
-				{
-					warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
-				}
-				else
-				{
-					readSensorRegisterValueCombined = (readSensorRegisterValueCombined*50);
-					warpPrint("%d\n", readSensorRegisterValueCombined);
-				}
-			}
-	}
-}
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devINA219.h b/src/boot/ksdk1.1.0/devINA219.h
deleted file mode 100644
index 2c2512a..0000000
--- a/src/boot/ksdk1.1.0/devINA219.h
+++ /dev/null
@@ -1,6 +0,0 @@
-void initINA219(const uint8_t i2cAddress);
-WarpStatus writeSensorRegisterINA219(uint8_t deviceRegister, uint16_t payload);
-WarpStatus readSensorRegisterINA219(uint8_t deviceRegister, int numberOfBytes);
-void printSensorDataINA219(bool hexModeFlag);
-void printCurrentDataINA219(bool hexModeFlag);
-void take1000CurrentMeasurements(bool hexModeFlag);
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devIS25xP.c b/src/boot/ksdk1.1.0/devIS25xP.c
new file mode 100644
index 0000000..5db08d3
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devIS25xP.c
@@ -0,0 +1,132 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "errstrs.h"
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+#include "devIS25xP.h"
+
+extern volatile WarpSPIDeviceState	deviceIS25xPState;
+extern volatile uint32_t		gWarpSpiTimeoutMicroseconds;
+extern uint8_t				gWarpSpiCommonSourceBuffer[];
+extern uint8_t				gWarpSpiCommonSinkBuffer[];
+
+
+void
+initIS25xP(int chipSelectIoPinID, uint16_t operatingVoltageMillivolts)
+{
+	deviceIS25xPState.chipSelectIoPinID		= chipSelectIoPinID;
+	deviceIS25xPState.spiSourceBuffer		= gWarpSpiCommonSourceBuffer;
+	deviceIS25xPState.spiSinkBuffer			= gWarpSpiCommonSinkBuffer;
+	deviceIS25xPState.spiBufferLength		= kWarpMemoryCommonSpiBufferBytes;
+	deviceIS25xPState.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+spiTransactionIS25xP(uint8_t ops[], size_t opCount)
+{
+	spi_status_t	status;
+
+
+	warpScaleSupplyVoltage(deviceIS25xPState.operatingVoltageMillivolts);
+
+	/*
+	 *	First, configure chip select pins of the various SPI slave devices
+	 *	as GPIO and drive all of them high.
+	 */
+	warpDeasserAllSPIchipSelects();
+
+	for (int i = 0; (i < opCount) && (i < deviceIS25xPState.spiBufferLength); i++)
+	{
+		deviceIS25xPState.spiSourceBuffer[i] = ops[i];
+		deviceIS25xPState.spiSinkBuffer[i] = 0x00;
+	}
+
+	/*
+	 *	First, create a falling edge on chip-select.
+	 */
+	GPIO_DRV_SetPinOutput(deviceIS25xPState.chipSelectIoPinID);
+	OSA_TimeDelay(50);
+	GPIO_DRV_ClearPinOutput(deviceIS25xPState.chipSelectIoPinID);
+
+	/*
+	 *	The result of the SPI transaction will be stored in deviceADXL362State.spiSinkBuffer.
+	 *
+	 *	Providing a spi_master_user_config_t is optional since it is already provided when we did
+	 *	SPI_DRV_MasterConfigureBus(), so we pass in NULL. The "master instance" is always 0 for
+	 *	the KL03 since there is only one SPI peripheral.
+	 */
+	warpEnableSPIpins();
+	status = SPI_DRV_MasterTransferBlocking(0 /* master instance */,
+					NULL /* spi_master_user_config_t */,
+					(const uint8_t * restrict)deviceIS25xPState.spiSourceBuffer,
+					(uint8_t * restrict)deviceIS25xPState.spiSinkBuffer,
+					opCount /* transfer size */,
+					gWarpSpiTimeoutMicroseconds);
+	warpDisableSPIpins();
+
+	/*
+	 *	Deassert the IS25xP
+	 */
+	GPIO_DRV_SetPinOutput(deviceIS25xPState.chipSelectIoPinID);
+
+	if (status != kStatus_SPI_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
diff --git a/src/boot/ksdk1.1.0/devIS25xP.h b/src/boot/ksdk1.1.0/devIS25xP.h
new file mode 100644
index 0000000..f77e3de
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devIS25xP.h
@@ -0,0 +1,39 @@
+/*
+	Authored 2020-2021. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+void		initIS25xP(int chipSelectIoPinID, uint16_t operatingVoltageMillivolts);
+WarpStatus	spiTransactionIS25xP(uint8_t ops[], size_t opCount);
diff --git a/src/boot/ksdk1.1.0/devISL23415.c b/src/boot/ksdk1.1.0/devISL23415.c
new file mode 100644
index 0000000..065269a
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devISL23415.c
@@ -0,0 +1,223 @@
+/*
+	Authored 2019. Vasileios Tsoutsouras.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "errstrs.h"
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+#include "devISL23415.h"
+
+extern volatile WarpSPIDeviceState	deviceISL23415State;
+extern volatile uint32_t		gWarpSpiTimeoutMicroseconds;
+extern uint8_t				gWarpSpiCommonSourceBuffer[];
+extern uint8_t				gWarpSpiCommonSinkBuffer[];
+
+
+void		
+initISL23415(int chipSelectIoPinID, uint16_t operatingVoltageMillivolts) 
+{
+	deviceISL23415State.chipSelectIoPinID		= chipSelectIoPinID;
+	deviceISL23415State.spiSourceBuffer		= gWarpSpiCommonSourceBuffer;
+	deviceISL23415State.spiSinkBuffer		= gWarpSpiCommonSinkBuffer;
+	deviceISL23415State.spiBufferLength		= kWarpMemoryCommonSpiBufferBytes;
+	deviceISL23415State.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus	
+readDeviceRegisterISL23415(uint8_t deviceRegister) 
+{
+	spi_status_t	status;
+
+
+	warpScaleSupplyVoltage(deviceISL23415State.operatingVoltageMillivolts);
+
+	/*
+	 *	First, configure chip select pins of the various SPI slave devices
+	 *	as GPIO and drive all of them high.
+	 */
+	warpDeasserAllSPIchipSelects();
+
+	/*
+	 *	Send the register/instruction, followed by a dummy byte (DCP will shift out value during the
+	 *	send of this dummy byte), followed by NOP byte, followed by another dummy byte.
+	 *
+	 *	Read operations on the ISL23415, unlike write operations, require a NOP instruction to be
+	 *	sent (after the two-byte register+dummy sequence used to indicate what register to read).
+	 *	See Figure 28 of the ISL23415 manual.
+	 */
+	deviceISL23415State.spiSourceBuffer[0] = deviceRegister						/*	See Table 4 of manual	*/;
+	deviceISL23415State.spiSourceBuffer[1] = 0x00							/*	Dummy byte		*/;
+	deviceISL23415State.spiSourceBuffer[2] = kWarpSensorConfigurationRegisterISL23415nopInstruction	/*	NOP byte		*/;
+	deviceISL23415State.spiSourceBuffer[3] = 0x00							/*	Dummy byte		*/;
+
+	deviceISL23415State.spiSinkBuffer[0] = 0xFF;
+	deviceISL23415State.spiSinkBuffer[1] = 0xFF;
+	deviceISL23415State.spiSinkBuffer[2] = 0xFF;
+	deviceISL23415State.spiSinkBuffer[3] = 0xFF;
+
+	/*
+	 *	Drive /CS low.
+	 *
+	 *	Make sure there is a high-to-low transition by first driving high, delay, then drive low.
+	 */
+	GPIO_DRV_SetPinOutput(kWarpPinISL23415_SPI_nCS);
+	OSA_TimeDelay(50);
+	GPIO_DRV_ClearPinOutput(kWarpPinISL23415_SPI_nCS);
+	
+	/*
+	 *	The result of the SPI transaction will be stored in deviceISL23415State.spiSinkBuffer.
+	 *
+	 *	Providing a spi_master_user_config_t is optional since it is already provided when we did
+	 *	SPI_DRV_MasterConfigureBus(), so we pass in NULL. The "master instance" is always 0 for
+	 *	the KL03 since there is only one SPI peripheral.
+	 */
+	warpEnableSPIpins();
+	status = SPI_DRV_MasterTransferBlocking(
+					0								/*	master instance			*/,
+					NULL								/*	spi_master_user_config_t	*/,
+					(const uint8_t * restrict)deviceISL23415State.spiSourceBuffer,
+					(uint8_t * restrict)deviceISL23415State.spiSinkBuffer,
+					4								/*	reg ID + dummy + NOP + dummy	*/,
+					gWarpSpiTimeoutMicroseconds);
+	warpDisableSPIpins();
+
+	/*
+	 *	Drive /CS high
+	 */
+	OSA_TimeDelay(50);
+	GPIO_DRV_SetPinOutput(kWarpPinISL23415_SPI_nCS);
+
+	if (status != kStatus_SPI_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+WarpStatus	
+writeDeviceRegisterISL23415(uint8_t deviceRegister, uint8_t writeValue)
+{
+	spi_status_t	status;
+
+
+	warpScaleSupplyVoltage(deviceISL23415State.operatingVoltageMillivolts);
+
+	/*
+	 *	First, configure chip select pins of the various SPI slave devices
+	 *	as GPIO and drive all of them high.
+	 */
+	warpDeasserAllSPIchipSelects();
+
+	/*
+	 *	Configure the four ISL23415 DCPs over SPI.
+	 *
+	 *	It takes two bytes (16 bit clocks) to complete a write transaction. The ISL23415 at 1.8V can
+	 *	operate at bit clocks of up to 5MHz and so can change value in principle at rates of up to 312.5k
+	 *	times a second. This rate is in principle fast enough for changing  the pull-up resistor values
+	 *	at I2C line speeds.
+	 */
+
+	/*
+	 *	Send the register/instruction, followed by the payload byte.
+	 *
+	 *	Write operations on the ISL23415, unlike read operations, are two-byte sequences.
+	 *	See Figure 27 of the ISL23415 manual.
+	 */
+	deviceISL23415State.spiSourceBuffer[0] = deviceRegister						/*	See Table 4 of manual	*/;
+	deviceISL23415State.spiSourceBuffer[1] = writeValue						/*	Register value to set	*/;
+
+	deviceISL23415State.spiSinkBuffer[0] = 0x00;
+	deviceISL23415State.spiSinkBuffer[1] = 0x00;
+
+	/*
+	 *	Drive /CS low.
+	 *
+	 *	Make sure there is a high-to-low transition by first driving high, delay, then drive low.
+	 */
+	GPIO_DRV_SetPinOutput(kWarpPinISL23415_SPI_nCS);
+	OSA_TimeDelay(50);
+	GPIO_DRV_ClearPinOutput(kWarpPinISL23415_SPI_nCS);
+
+	/*
+	 *	The result of the SPI transaction will be stored in deviceISL23415State.spiSinkBuffer.
+	 *
+	 *	Providing a spi_master_user_config_t is optional since it is already provided when we did
+	 *	SPI_DRV_MasterConfigureBus(), so we pass in NULL. The "master instance" is always 0 for
+	 *	the KL03 since there is only one SPI peripheral.
+	 */
+	warpEnableSPIpins();
+	status = SPI_DRV_MasterTransferBlocking(
+					0								/*	master instance			*/,
+					NULL								/*	spi_master_user_config_t	*/,
+					(const uint8_t * restrict)deviceISL23415State.spiSourceBuffer,
+					(uint8_t * restrict)deviceISL23415State.spiSinkBuffer,
+					2								/*	reg ID + payload		*/,
+					gWarpSpiTimeoutMicroseconds);
+	warpDisableSPIpins();
+
+	/*
+	 *	Drive /CS high
+	 */
+	OSA_TimeDelay(50);
+	GPIO_DRV_SetPinOutput(kWarpPinISL23415_SPI_nCS);
+
+	if (status != kStatus_SPI_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
diff --git a/src/boot/ksdk1.1.0/devISL23415.h b/src/boot/ksdk1.1.0/devISL23415.h
new file mode 100644
index 0000000..67198e0
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devISL23415.h
@@ -0,0 +1,40 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+void		initISL23415(int chipSelectIoPinID, uint16_t operatingVoltageMillivolts);
+WarpStatus	readDeviceRegisterISL23415(uint8_t deviceRegister);
+WarpStatus	writeDeviceRegisterISL23415(uint8_t deviceRegister, uint8_t writeValue);
diff --git a/src/boot/ksdk1.1.0/devL3GD20H.c b/src/boot/ksdk1.1.0/devL3GD20H.c
new file mode 100644
index 0000000..71cb193
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devL3GD20H.c
@@ -0,0 +1,320 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell. Additional contributors,
+	2018-onwards, see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+
+
+extern volatile WarpI2CDeviceState	deviceL3GD20HState;
+extern volatile uint32_t		gWarpI2cBaudRateKbps;
+extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
+extern volatile uint32_t		gWarpSupplySettlingDelayMilliseconds;
+
+
+
+void
+initL3GD20H(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceL3GD20HState.i2cAddress			= i2cAddress;
+	deviceL3GD20HState.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+writeSensorRegisterL3GD20H(uint8_t deviceRegister, uint8_t payload, uint16_t menuI2cPullupValue)
+{
+	uint8_t		payloadByte[1], commandByte[1];
+	i2c_status_t	status;
+
+	switch (deviceRegister)
+	{
+		case 0x20: case 0x21: case 0x22: case 0x23:
+		case 0x24: case 0x25: case 0x2E: case 0x30:
+		case 0x32: case 0x33: case 0x34: case 0x35:
+		case 0x36: case 0x37: case 0x38: case 0x39:
+		{
+			/* OK */
+			break;
+		}
+		
+		default:
+		{
+			return kWarpStatusBadDeviceCommand;
+		}
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceL3GD20HState.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	warpScaleSupplyVoltage(deviceL3GD20HState.operatingVoltageMillivolts);
+
+	commandByte[0] = deviceRegister;
+	payloadByte[0] = payload;
+	warpEnableI2Cpins();
+
+	status = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C instance */,
+							&slave,
+							commandByte,
+							1,
+							payloadByte,
+							1,
+							gWarpI2cTimeoutMilliseconds);
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+WarpStatus
+configureSensorL3GD20H(uint8_t payloadCTRL1, uint8_t payloadCTRL2, uint8_t payloadCTRL5, uint16_t menuI2cPullupValue)
+{
+	WarpStatus	status1, status2, status3;
+
+
+	warpScaleSupplyVoltage(deviceL3GD20HState.operatingVoltageMillivolts);
+
+	status1 = writeSensorRegisterL3GD20H(kWarpSensorConfigurationRegisterL3GD20HCTRL1 /* register address CTRL1 */,
+							payloadCTRL1 /* payload */,
+							menuI2cPullupValue);
+
+	status2 = writeSensorRegisterL3GD20H(kWarpSensorConfigurationRegisterL3GD20HCTRL2 /* register address CTRL2 */,
+							payloadCTRL2 /* payload */,
+							menuI2cPullupValue);
+
+	status3 = writeSensorRegisterL3GD20H(kWarpSensorConfigurationRegisterL3GD20HCTRL5 /* register address CTRL5 */,
+							payloadCTRL5 /* payload */,
+							menuI2cPullupValue);
+
+	return (status1 | status2 | status3);
+}
+
+WarpStatus
+readSensorRegisterL3GD20H(uint8_t deviceRegister, int numberOfBytes)
+{
+	uint8_t		cmdBuf[1] = {0xFF};
+	i2c_status_t	status1, status2;
+
+
+	USED(numberOfBytes);
+	if ((deviceRegister < 0x0F) || (deviceRegister > 0x39))
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceL3GD20HState.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	warpScaleSupplyVoltage(deviceL3GD20HState.operatingVoltageMillivolts);
+	cmdBuf[0] = deviceRegister;
+	warpEnableI2Cpins();
+
+	/*
+	 *	Steps (Repeated single-byte read. See STable 15 and Table 16 of L3GD20H manual.):
+	 *
+	 *	(1) Write transaction beginning with start condition, slave address, and sub address.
+	 *
+	 *	(2) Read transaction beginning with start condition, followed by slave address, and read 1 byte payload
+	 */
+
+	status1 = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							cmdBuf,
+							1,
+							NULL,
+							0,
+							gWarpI2cTimeoutMilliseconds);
+		
+	status2 = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							cmdBuf,
+							1,
+							(uint8_t *)deviceL3GD20HState.i2cBuffer,
+							numberOfBytes,
+							gWarpI2cTimeoutMilliseconds);
+
+	if ((status1 != kStatus_I2C_Success) || (status2 != kStatus_I2C_Success))
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+
+void
+printSensorDataL3GD20H(bool hexModeFlag)
+{
+	uint16_t	readSensorRegisterValueLSB;
+	uint16_t	readSensorRegisterValueMSB;
+	int16_t		readSensorRegisterValueCombined;
+	int8_t		readSensorRegisterSignedByte;
+	WarpStatus	i2cReadStatusLow, i2cReadStatusHigh;
+
+
+	warpScaleSupplyVoltage(deviceL3GD20HState.operatingVoltageMillivolts);
+
+	i2cReadStatusLow = readSensorRegisterL3GD20H(kWarpSensorOutputRegisterL3GD20HOUT_X_L, 1 /* numberOfBytes */);
+	readSensorRegisterValueLSB = deviceL3GD20HState.i2cBuffer[0];
+	i2cReadStatusHigh = readSensorRegisterL3GD20H(kWarpSensorOutputRegisterL3GD20HOUT_X_H, 1 /* numberOfBytes */);
+	readSensorRegisterValueMSB = deviceL3GD20HState.i2cBuffer[0];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 8) | (readSensorRegisterValueLSB & 0xFF);
+
+	/*
+	 *	NOTE: Here, we don't need to manually sign extend since we are packing directly into an int16_t
+	 */
+
+	if ((i2cReadStatusLow != kWarpStatusOK) || (i2cReadStatusHigh != kWarpStatusOK))
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+	i2cReadStatusLow = readSensorRegisterL3GD20H(kWarpSensorOutputRegisterL3GD20HOUT_Y_L, 1 /* numberOfBytes */);
+	readSensorRegisterValueLSB = deviceL3GD20HState.i2cBuffer[0];
+	i2cReadStatusHigh = readSensorRegisterL3GD20H(kWarpSensorOutputRegisterL3GD20HOUT_Y_H, 1 /* numberOfBytes */);
+	readSensorRegisterValueMSB = deviceL3GD20HState.i2cBuffer[0];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 8) | (readSensorRegisterValueLSB & 0xFF);
+
+	/*
+	 *	NOTE: Here, we don't need to manually sign extend since we are packing directly into an int16_t
+	 */
+
+	if ((i2cReadStatusLow != kWarpStatusOK) || (i2cReadStatusHigh != kWarpStatusOK))
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+	i2cReadStatusLow = readSensorRegisterL3GD20H(kWarpSensorOutputRegisterL3GD20HOUT_Z_L, 1 /* numberOfBytes */);
+	readSensorRegisterValueLSB = deviceL3GD20HState.i2cBuffer[0];
+	i2cReadStatusHigh = readSensorRegisterL3GD20H(kWarpSensorOutputRegisterL3GD20HOUT_Z_H, 1 /* numberOfBytes */);
+	readSensorRegisterValueMSB = deviceL3GD20HState.i2cBuffer[0];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 8) | (readSensorRegisterValueLSB & 0xFF);
+
+	/*
+	 *	NOTE: Here, we don't need to manually sign extend since we are packing directly into an int16_t
+	 */
+
+	if ((i2cReadStatusLow != kWarpStatusOK) || (i2cReadStatusHigh != kWarpStatusOK))
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+	i2cReadStatusLow = readSensorRegisterL3GD20H(kWarpSensorOutputRegisterL3GD20HOUT_TEMP, 1 /* numberOfBytes */);
+	readSensorRegisterSignedByte = deviceL3GD20HState.i2cBuffer[0];
+
+	/*
+	 *	NOTE: Here, we don't need to manually sign extend since we are packing directly into an int8_t
+	 */
+
+	if (i2cReadStatusLow != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x,", deviceL3GD20HState.i2cBuffer[0]);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterSignedByte);
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devL3GD20H.h b/src/boot/ksdk1.1.0/devL3GD20H.h
new file mode 100644
index 0000000..bdabcfb
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devL3GD20H.h
@@ -0,0 +1,43 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell. Additional contributors,
+	2018-onwards, see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+void		initL3GD20H(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts);
+WarpStatus	readSensorRegisterL3GD20H(uint8_t deviceRegister, int numberOfBytes);
+WarpStatus	writeSensorRegisterL3GD20H(uint8_t deviceRegister, uint8_t payload, uint16_t menuI2cPullupValue);
+WarpStatus	configureSensorL3GD20H(uint8_t payloadCTRL1, uint8_t payloadCTRL2, uint8_t payloadCTRL5, uint16_t menuI2cPullupValue);
+void		printSensorDataL3GD20H(bool hexModeFlag);
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devLPS25H.c b/src/boot/ksdk1.1.0/devLPS25H.c
new file mode 100644
index 0000000..5a18d7a
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devLPS25H.c
@@ -0,0 +1,130 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+
+
+extern volatile WarpI2CDeviceState	deviceLPS25HState;
+extern volatile uint32_t		gWarpI2cBaudRateKbps;
+extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
+extern volatile uint32_t		gWarpSupplySettlingDelayMilliseconds;
+
+
+
+void
+initLPS25H(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceLPS25HState.i2cAddress			= i2cAddress;
+	deviceLPS25HState.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+readSensorRegisterLPS25H(uint8_t deviceRegister, int numberOfBytes)
+{
+	uint8_t		cmdBuf[1] = {0xFF};
+	i2c_status_t	status1, status2;
+
+
+	USED(numberOfBytes);
+	if ((deviceRegister < 0x0F) || (deviceRegister > 0x39))
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceLPS25HState.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	warpScaleSupplyVoltage(deviceLPS25HState.operatingVoltageMillivolts);
+	cmdBuf[0] = deviceRegister;
+	warpEnableI2Cpins();
+
+	/*
+	 *	Steps (Repeated single-byte read. See Table 13. and Table 14 of LPS25H manual.):
+	 *
+	 *	(1) Write transaction beginning with start condition, slave address, and sub address.
+	 *
+	 *	(2) Read transaction beginning with start condition, followed by slave address, and read 1 byte payload
+	 */
+
+	status1 = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							cmdBuf,
+							1,
+							NULL,
+							0,
+							gWarpI2cTimeoutMilliseconds);
+
+	status2 = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							cmdBuf,
+							1,
+							(uint8_t *)deviceLPS25HState.i2cBuffer,
+							numberOfBytes,
+							gWarpI2cTimeoutMilliseconds);
+
+	if ((status1 != kStatus_I2C_Success) || (status2 != kStatus_I2C_Success))
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
diff --git a/src/boot/ksdk1.1.0/devLPS25H.h b/src/boot/ksdk1.1.0/devLPS25H.h
new file mode 100644
index 0000000..4bd911b
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devLPS25H.h
@@ -0,0 +1,39 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+void		initLPS25H(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts);
+WarpStatus	readSensorRegisterLPS25H(uint8_t deviceRegister, int numberOfBytes);
diff --git a/src/boot/ksdk1.1.0/devMAG3110.c b/src/boot/ksdk1.1.0/devMAG3110.c
new file mode 100644
index 0000000..5ff4d40
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devMAG3110.c
@@ -0,0 +1,307 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell.
+
+	Other contributors, 2018 onwards: See git blame.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+
+extern volatile WarpI2CDeviceState	deviceMAG3110State;
+extern volatile uint32_t		gWarpI2cBaudRateKbps;
+extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
+extern volatile uint32_t		gWarpSupplySettlingDelayMilliseconds;
+
+
+void
+initMAG3110(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceMAG3110State.i2cAddress			= i2cAddress;
+	deviceMAG3110State.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+writeSensorRegisterMAG3110(uint8_t deviceRegister, uint8_t payload, uint16_t menuI2cPullupValue)
+{
+	uint8_t		payloadByte[1], commandByte[1];
+	i2c_status_t	returnValue;
+
+	switch (deviceRegister)
+	{
+		case 0x09: case 0x0A: case 0x0B: case 0x0C:
+		case 0x0D: case 0x0E: case 0x10: case 0x11:
+		{
+			/* OK */
+			break;
+		}
+		
+		default:
+		{
+			return kWarpStatusBadDeviceCommand;
+		}
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceMAG3110State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	warpScaleSupplyVoltage(deviceMAG3110State.operatingVoltageMillivolts);
+	commandByte[0] = deviceRegister;
+	payloadByte[0] = payload;
+	warpEnableI2Cpins();
+
+	returnValue = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C instance */,
+							&slave,
+							commandByte,
+							1,
+							payloadByte,
+							1,
+							gWarpI2cTimeoutMilliseconds);
+	if (returnValue != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+WarpStatus
+configureSensorMAG3110(uint8_t payloadCTRL_REG1, uint8_t payloadCTRL_REG2, uint16_t menuI2cPullupValue)
+{
+	WarpStatus	i2cWriteStatus1, i2cWriteStatus2, i2cWriteStatus3;
+
+
+	warpScaleSupplyVoltage(deviceMAG3110State.operatingVoltageMillivolts);
+
+	i2cWriteStatus1 = writeSensorRegisterMAG3110(kWarpSensorConfigurationRegisterMAG3110CTRL_REG1 /* register address CTRL_REG1 */,
+							payloadCTRL_REG1 /* payload */,
+							menuI2cPullupValue);
+
+	i2cWriteStatus2 = writeSensorRegisterMAG3110(kWarpSensorConfigurationRegisterMAG3110CTRL_REG2 /* register address CTRL_REG2 */,
+							payloadCTRL_REG2 /* payload */,
+							menuI2cPullupValue);
+
+	i2cWriteStatus3 = writeSensorRegisterMAG3110(kWarpSensorConfigurationRegisterMAG3110CTRL_REG1 /* register address CTRL_REG1 */,
+							0x01 /* payload: ACTIVE mode */,
+							menuI2cPullupValue);
+
+	return (i2cWriteStatus1 | i2cWriteStatus2 | i2cWriteStatus3);
+}
+
+WarpStatus
+readSensorRegisterMAG3110(uint8_t deviceRegister, int numberOfBytes)
+{
+	uint8_t		cmdBuf[1]	= {0xFF};
+	i2c_status_t	status1, status2;
+
+
+	USED(numberOfBytes);
+	i2c_device_t slave =
+	{
+		.address = deviceMAG3110State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	/*
+	 *	Steps (Repeated single-byte read. See Section 4.2.2 of MAG3110 manual.):
+	 *
+	 *	(1) Write transaction beginning with start condition, slave address, and pointer address.
+	 *
+	 *	(2) Read transaction beginning with start condition, followed by slave address, and read 1 byte payload
+	*/
+
+	warpScaleSupplyVoltage(deviceMAG3110State.operatingVoltageMillivolts);
+	cmdBuf[0] = deviceRegister;
+	warpEnableI2Cpins();
+
+	status1 = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							cmdBuf,
+							1,
+							NULL,
+							0,
+							gWarpI2cTimeoutMilliseconds);
+
+	status2 = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							cmdBuf,
+							1,
+							(uint8_t *)deviceMAG3110State.i2cBuffer,
+							numberOfBytes,
+							gWarpI2cTimeoutMilliseconds);
+
+	if ((status1 != kStatus_I2C_Success) || (status2 != kStatus_I2C_Success))
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+void
+printSensorDataMAG3110(bool hexModeFlag)
+{
+	uint16_t	readSensorRegisterValueLSB;
+	uint16_t	readSensorRegisterValueMSB;
+	int16_t		readSensorRegisterValueCombined;
+	int8_t		readSensorRegisterSignedByte;
+	WarpStatus	i2cReadStatus;
+
+
+	warpScaleSupplyVoltage(deviceMAG3110State.operatingVoltageMillivolts);
+
+	i2cReadStatus = readSensorRegisterMAG3110(kWarpSensorOutputRegisterMAG3110OUT_X_MSB, 2 /* numberOfBytes */);
+	readSensorRegisterValueMSB = deviceMAG3110State.i2cBuffer[0];
+	readSensorRegisterValueLSB = deviceMAG3110State.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 8) | (readSensorRegisterValueLSB & 0xFF);
+
+	/*
+	 *	NOTE: Here, we don't need to manually sign extend since we are packing directly into an int16_t
+	 */
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+	i2cReadStatus = readSensorRegisterMAG3110(kWarpSensorOutputRegisterMAG3110OUT_Y_MSB, 2 /* numberOfBytes */);
+	readSensorRegisterValueMSB = deviceMAG3110State.i2cBuffer[0];
+	readSensorRegisterValueLSB = deviceMAG3110State.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 8) | (readSensorRegisterValueLSB & 0xFF);
+
+	/*
+	 *	NOTE: Here, we don't need to manually sign extend since we are packing directly into an int16_t
+	 */
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+	i2cReadStatus = readSensorRegisterMAG3110(kWarpSensorOutputRegisterMAG3110OUT_Z_MSB, 2 /* numberOfBytes */);
+	readSensorRegisterValueMSB = deviceMAG3110State.i2cBuffer[0];
+	readSensorRegisterValueLSB = deviceMAG3110State.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 8) | (readSensorRegisterValueLSB & 0xFF);
+
+	/*
+	 *	NOTE: Here, we don't need to manually sign extend since we are packing directly into an int16_t
+	 */
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+	i2cReadStatus = readSensorRegisterMAG3110(kWarpSensorOutputRegisterMAG3110DIE_TEMP, 1 /* numberOfBytes */);
+	readSensorRegisterSignedByte = deviceMAG3110State.i2cBuffer[0];
+
+	/*
+	 *	NOTE: Here, we don't need to manually sign extend since we are packing directly into an int8_t
+	 */
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x,", deviceMAG3110State.i2cBuffer[0]);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterSignedByte);
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devMAG3110.h b/src/boot/ksdk1.1.0/devMAG3110.h
new file mode 100644
index 0000000..88759e0
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devMAG3110.h
@@ -0,0 +1,43 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell. Additional contributors,
+	2018-onwards, see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+void		initMAG3110(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts);
+WarpStatus	writeSensorRegisterMAG3110(uint8_t deviceRegister, uint8_t payload, uint16_t menuI2cPullupValue);
+WarpStatus	configureSensorMAG3110(uint8_t payloadCTRL_REG1, uint8_t payloadCTRL_REG2, uint16_t menuI2cPullupValue);
+WarpStatus	readSensorRegisterMAG3110(uint8_t deviceRegister, int numberOfBytes);
+void		printSensorDataMAG3110(bool hexModeFlag);
diff --git a/src/boot/ksdk1.1.0/devMAX11300.c b/src/boot/ksdk1.1.0/devMAX11300.c
new file mode 100644
index 0000000..126cbf6
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devMAX11300.c
@@ -0,0 +1,609 @@
+/*
+	Authored 2019-2020, Giorgio Mallia.
+
+	All rights reserved.
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#include <stdint.h>
+
+#include "fsl_spi_master_driver.h"
+#include "fsl_port_hal.h"
+
+#include "SEGGER_RTT.h"
+#include "gpio_pins.h"
+#include "warp.h"
+#include "devSSD1331.h"
+
+
+
+volatile uint8_t	inBuffer[32];
+volatile uint8_t	payloadBytes[32];
+
+
+/*
+	Override Warp firmware's use of these pins and define new aliases.
+*/
+
+enum
+{
+	kMAX11300PinMISO	= GPIO_MAKE_PIN(HW_GPIOA,	6),
+	kMAX11300PinMOSI	= GPIO_MAKE_PIN(HW_GPIOA,	8),
+	kMAX11300PinSCK		= GPIO_MAKE_PIN(HW_GPIOA,	9),
+	kMAX11300PinCSn		= GPIO_MAKE_PIN(HW_GPIOB,	13),
+};
+
+
+spi_status_t	writeCommand(uint8_t Register_Byte, uint16_t Command_Bytes, bool W_R)	/* W_R = 0/1 (Write/Read) */ 
+{
+	spi_status_t status;
+	
+	/*
+		Drive /CS low.
+		Make sure there is a high-to-low transition by first driving high, delay, then drive low.
+	*/
+
+	GPIO_DRV_SetPinOutput(kMAX11300PinCSn);
+	OSA_TimeDelay(10);
+	GPIO_DRV_ClearPinOutput(kMAX11300PinCSn);
+
+	uint8_t Byte1 = (Register_Byte << 1) | W_R;
+	uint8_t Byte2 = Command_Bytes >> 8;
+	uint8_t Byte3 = Command_Bytes & 0xff;
+
+	payloadBytes[0] = Byte1;
+	payloadBytes[1] = Byte2;
+	payloadBytes[2] = Byte3;
+
+	status = SPI_DRV_MasterTransferBlocking(0	/* master instance */,
+											NULL	/* spi_master_user_config_t*/,
+											(const uint8_t * restrict)&payloadBytes[0],
+											(uint8_t * restrict) &inBuffer[0],
+											3	/* transfer size */,
+											2000	/* timeout in microseconds */);
+
+	/*
+		Drive /CS high
+	*/
+
+	GPIO_DRV_SetPinOutput(kMAX11300PinCSn);
+
+	return status;
+}
+
+/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+void readID(void){
+	SEGGER_RTT_printf(0, "\r\t Address (R/W): 0x%x Commands: 0x%x 0x%x \n", payloadBytes[0], payloadBytes[1], payloadBytes[2]);
+	OSA_TimeDelay(10);
+	writeCommand(0x00, 0x0000, 1); /* READ DEVICE ID: 0x00 (1) [Read] */
+	SEGGER_RTT_printf(0, "\r\t Bytes Received: 0x%x 0x%x 0x%x \n", inBuffer[0], inBuffer[1], inBuffer[2]);
+	OSA_TimeDelay(10);
+}
+
+/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+int read1digit(int lowerLimit, int higherLimit){
+	int number = -1;
+	while (!(number >= lowerLimit && number <= higherLimit)){
+		number = SEGGER_RTT_WaitKey() - '0';
+	}
+	return number;
+}
+
+/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+int read2digits(int lowerLimit, int higherLimit){
+	int digit1 = 0;
+	int digit2 = 0;
+	int number = -1;
+	while (!(number >= lowerLimit && number <= higherLimit)){
+		digit1 = SEGGER_RTT_WaitKey() - '0';
+		digit2 = SEGGER_RTT_WaitKey() - '0';
+		number = digit1*10 + digit2;
+	}
+	return number;
+}
+
+/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+int read4digits(int lowerLimit, int higherLimit){
+	int digit1 = 0;
+	int digit2 = 0;
+	int digit3 = 0;
+	int digit4 = 0;
+	int number = -1;
+	while (!(number >= lowerLimit && number <= higherLimit)){
+		digit1 = SEGGER_RTT_WaitKey() - '0';
+		digit2 = SEGGER_RTT_WaitKey() - '0';
+		digit3 = SEGGER_RTT_WaitKey() - '0';
+		digit4 = SEGGER_RTT_WaitKey() - '0';
+		number = digit1*1000 + digit2*100 + digit3*10 + digit4*1;
+	}
+	return number;
+}
+
+/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+int read5digits(int lowerLimit, int higherLimit){
+	int digit1 = 0;
+	int digit2 = 0;
+	int digit3 = 0;
+	int digit4 = 0;
+	int digit5 = 0;
+	int number = -1;
+	while (!(number >= lowerLimit && number <= higherLimit)){
+		digit1 = SEGGER_RTT_WaitKey() - '0';
+		digit2 = SEGGER_RTT_WaitKey() - '0';
+		digit3 = SEGGER_RTT_WaitKey() - '0';
+		digit4 = SEGGER_RTT_WaitKey() - '0';
+		digit5 = SEGGER_RTT_WaitKey() - '0';
+		number = digit1*10000 + digit2*1000 + digit3*100 + digit4*10 + digit5*1;
+	}
+	return number;
+}
+
+/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+uint16_t assembleCommand(bool D[16]){
+	uint16_t command = 0;
+	for(int i=0; i<16; i++){
+		command |= D[i] << i;
+	}
+	return command;
+}
+
+/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+void SPIscope(void){
+	SEGGER_RTT_printf(0, "\r\t Address (R/W): 0x%x Commands: 0x%x 0x%x \n", payloadBytes[0], payloadBytes[1], payloadBytes[2]);
+	OSA_TimeDelay(10);
+	SEGGER_RTT_printf(0, "\r\t Bytes Received: 0x%x 0x%x 0x%x \n", inBuffer[0], inBuffer[1], inBuffer[2]);
+	OSA_TimeDelay(10);
+}
+
+/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+uint16_t AssembleDAC_DAT(int data){
+
+	bool D_C_DAC_DATA[12];
+	for (int i = 0; i < 12; i++)
+	{
+		D_C_DAC_DATA[i] = (((data >> i) & 1) == 1);
+	}
+
+	bool D_C_DAC_DATA_C[16] = {D_C_DAC_DATA[0], D_C_DAC_DATA[1], D_C_DAC_DATA[2], D_C_DAC_DATA[3], D_C_DAC_DATA[4], D_C_DAC_DATA[5], D_C_DAC_DATA[6], D_C_DAC_DATA[7], D_C_DAC_DATA[8], D_C_DAC_DATA[9], D_C_DAC_DATA[10], D_C_DAC_DATA[11], 0, 0, 0, 0};
+
+	uint16_t Scommand = assembleCommand(D_C_DAC_DATA_C);
+
+	return Scommand;
+}
+
+
+/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+int read1char(char input[10]){
+
+	char character = '0';
+	while (!((character == input[0] || character == input[1]) || (character == input[2] || character == input[3]) || (character == input[4] || character == input[5]) || (character == input[6] || character == input[7]) || (character == input[8] || character == input[9]))){
+
+		character = SEGGER_RTT_WaitKey();
+	}
+
+	int match = 0;
+
+	if(character == input[0] || character == input[1]){
+		match = 1;
+	}
+	else if(character == input[2] || character == input[3]){
+		match = 2;
+	}
+	else if(character == input[4] || character == input[5]){
+		match = 3;
+	}
+	else if(character == input[6] || character == input[7]){
+		match = 4;
+	}
+	else if(character == input[8] || character == input[9]){
+		match = 5;
+	}
+
+	return  match;
+
+}
+
+/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+int devMAX11300(void){
+
+	/*
+		Override Warp firmware's use of these pins.
+		Re-configure SPI to be on PTA8 and PTA9 for MOSI and SCK respectively.
+	*/
+
+	PORT_HAL_SetMuxMode(PORTA_BASE, 6u, kPortMuxAlt3);
+	PORT_HAL_SetMuxMode(PORTA_BASE, 8u, kPortMuxAlt3);
+	PORT_HAL_SetMuxMode(PORTA_BASE, 9u, kPortMuxAlt3);
+
+	enableSPIpins();
+
+	/*
+		Override Warp firmware's use of these pins.
+		Reconfigure to use as GPIO.
+	*/
+
+	PORT_HAL_SetMuxMode(PORTB_BASE, 13u, kPortMuxAsGpio);
+
+	/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+	uint16_t	Scommand1			=	0x0000;	/*	BRST = 0: Default address incrementing mode
+													THSHD = 0: Thermal shutdown disabled
+													ADCCONV = 00: 200kbps */
+	
+	uint16_t	Scommand2			=	0x0044;	/*	DACREF = 1: DAC Internal reference
+													DACL = 1: Immediate update for DAC configured ports */
+
+	uint16_t	Scommand3			=	0x0047;	/*	Scommand2 + ADCCL initialized as 11 */
+
+	uint16_t	Scommand4_AS		=	0xC000;	/*	AS MODE CONFIGURATION COMMAND */
+	uint16_t	Scommand4_DAC		=	0x5100;	/*	DAC MODE CONFIGURATION COMMAND */
+	uint16_t	Scommand4_HI		=	0x0000;	/*	HIGH IMPEDANCE PORT MODE CONFIGURATION COMMAND */
+	uint16_t	Scommand4_ADC		=	0x7120;	/*	ADC MODE CONFIGURATION COMMAND (Internal/DAC AVR */
+
+	uint16_t	Scommand5			=	0x0020;	/* INTERRUPT REGISTER: DAC OVERCURRENT INTERRUPT 0000 0100 0000 0000 */
+
+	uint8_t PORT_Config_Addr[20]	=	{0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33};
+	uint8_t ADC_DataPorts[20]		=	{0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53};
+	uint8_t DAC_DataPorts[20]		=	{0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73};
+
+	/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+	SEGGER_RTT_WriteString(0, "\r\t Reading Device ID: \n");
+	OSA_TimeDelay(10);
+
+	readID();
+	OSA_TimeDelay(1);
+	SPIscope();
+
+	/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+	SEGGER_RTT_WriteString(0, "\r\t Select Port Configuration: Enter a 20-element vector. \n");
+	OSA_TimeDelay(10);
+	SEGGER_RTT_WriteString(0, "\r\t Options: Analogue switch (A), DAC Output (O), Waveform Generator (G), High impedance port (H) or ADC Input port (I): \n");
+	OSA_TimeDelay(10);
+
+	int AS_number = 0;
+	int AS_port[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+
+	int DAC_number = 0;
+	int DAC_port[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+
+	int ADC_number = 0;
+	int ADC_port[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+
+	int DAC_WAVE_number = 0;
+	int DAC_WAVE_port = 0;
+
+	int HI_number = 0;
+	int HI_port[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+
+	int length = 20;
+	char input_values[10] = {'a', 'A', 'o', 'O', 'g', 'G', 'h', 'H', 'i', 'I'};
+	int input = 0;
+
+	int c = 0;
+	while(c != 1){
+
+		for(int i = 0; i < length; i++){
+			input = read1char(input_values);
+			
+			if(input == 1){
+				AS_number++;
+				AS_port[AS_number] = i;
+			}
+			else if(input == 2){
+				DAC_number++;
+				DAC_port[DAC_number] = i;
+			}
+			else if(input == 3){
+				DAC_WAVE_number++;
+				DAC_WAVE_port = i;
+			}
+			else if(input == 4){
+				HI_number++;
+				HI_port[HI_number] = i;
+			}
+			else if(input == 5){
+				ADC_number++;
+				ADC_port[ADC_number] = i;
+			}
+		}
+
+		if(DAC_WAVE_number > 1){
+			SEGGER_RTT_WriteString(0, "\r\t Variable DAC Output ALREADY SELECTED \n");
+			OSA_TimeDelay(10);
+			
+			AS_number = 0;
+			ADC_number = 0;
+			DAC_number = 0;
+			HI_number = 0;
+			DAC_WAVE_number = 0;
+			DAC_WAVE_port = 0;
+		}
+
+		else{
+			c = 1;
+		}
+
+	}
+
+	/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+	/* CONFIGURING All THE PORTS' FUNCTIONS */
+
+	/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+	SEGGER_RTT_WriteString(0, "\r\t Configuration Starts \n");
+	OSA_TimeDelay(10);
+
+	SEGGER_RTT_WriteString(0, "\r\t Configure BRST, THSHDN, ADCCONV \n");
+	OSA_TimeDelay(10);
+
+	writeCommand(0x10, Scommand1, 0); /* DEVICE CONTROL (0) [Write] */
+	OSA_TimeDelay(1);
+	SPIscope();
+
+	/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+	if(HI_number >= 1){
+		SEGGER_RTT_WriteString(0, "\r\t HIs Configuration \n");
+		OSA_TimeDelay(10);
+
+		for (int k = 0; k < HI_number; k++){
+
+			/* --- --- --- HI PORT CONFIGURATION */
+			writeCommand(PORT_Config_Addr[HI_port[k]], Scommand4_HI, 0); /* PORT CONTROL - HI (0) [Write] */
+			OSA_TimeDelay(1);
+			/* SPIscope(); */
+			/* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- --- */
+		}
+	}
+
+	/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+	if(DAC_number >= 1){
+		
+		SEGGER_RTT_WriteString(0, "\r\t DACREF, DACCTL Configuration \n");
+		OSA_TimeDelay(10);
+		
+		writeCommand(0x10, Scommand2, 0); /*   DEVICE CONTROL (0) [Write]  */
+		OSA_TimeDelay(1);
+		SPIscope();
+		
+		SEGGER_RTT_WriteString(0, "\r\t DACs Configuration \n");
+		OSA_TimeDelay(10);
+		
+		for (int k = 1; k <= DAC_number; k++){
+
+			/* --- --- --- DAC PORT CONFIGURATION   */
+			writeCommand(PORT_Config_Addr[DAC_port[k]], Scommand4_DAC, 0); /* PORT CONTROL - DAC (0) [Write]   */
+			OSA_TimeDelay(1);
+			/* SPIscope(); */
+			/* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- --- */
+		}
+	}
+
+	/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+	if(DAC_WAVE_number == 1){
+
+		SEGGER_RTT_WriteString(0, "\r\t WAVE DAC Configuration \n");
+		OSA_TimeDelay(10);
+
+		/* --- --- --- DAC PORT CONFIGURATION   */
+		writeCommand(PORT_Config_Addr[DAC_WAVE_port], Scommand4_DAC, 0); /* PORT CONTROL - DAC (0) [Write] */
+		OSA_TimeDelay(1);
+		/* SPIscope(); */
+		/* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- --- */
+	}
+
+	/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+	if(ADC_number >= 1){
+
+		SEGGER_RTT_WriteString(0, "\r\t ADCs Configuration \n");
+		OSA_TimeDelay(10);
+
+		for (int k = 1; k <= ADC_number; k++){
+
+			/* --- --- --- ADC PORT CONFIGURATION */
+			writeCommand(PORT_Config_Addr[ADC_port[k]], Scommand4_ADC, 0); /* PORT CONTROL - ADC (0) [Write] */
+			OSA_TimeDelay(1);
+			SPIscope(); OSA_TimeDelay(10);
+			/* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- --- */
+		}
+	}
+
+	/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+	writeCommand(0x10, Scommand3, 0); /* DEVICE CONTROL (0) [Write]  - CONFIGURE ACCTL */
+	OSA_TimeDelay(1);
+	/* SPIscope(); */
+
+	/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+	if(AS_number >= 1){
+
+		SEGGER_RTT_WriteString(0, "\r\t ASs Configuration \n");
+		OSA_TimeDelay(10);
+
+		for (int k = 0; k < AS_number; k++){
+			/* --- --- --- AS PORT CONFIGURATION    */
+			writeCommand(PORT_Config_Addr[AS_port[k]], Scommand4_AS, 0); /*    PORT CONTROL - AS (0) [Write]   */
+			OSA_TimeDelay(1);
+			/* SPIscope(); */
+			/* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- --- */
+		}
+	}
+
+	/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+	/* --- --- --- CONFIGURE INTERRUPT CONTROL */
+	writeCommand(0x11, Scommand5, 0); /* INTERRUPT CONTROL  (0) [Write] */
+	OSA_TimeDelay(1);
+	SPIscope();
+	/* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- --- */
+
+	SEGGER_RTT_WriteString(0, "\r\t End of Configuration \n");
+	OSA_TimeDelay(10);
+
+	/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+	/* WRITING VALUES TO CONFIGURED DACs AND READ DATA FROM CONFIGURED ADCs */
+
+	/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+	if(DAC_number >= 1){
+
+		SEGGER_RTT_printf(0, "\r\t DAC Configuration Starts. %d DACs selected. \n", DAC_number);
+		OSA_TimeDelay(10);
+		for (int k = 1; k <= DAC_number; k++){
+			SEGGER_RTT_printf(0, "\r\t Select single DAC output value for DAC # %d : \n", k);
+			OSA_TimeDelay(10);
+
+			SEGGER_RTT_WriteString(0, "\r\t Enter a value between 00000mV and 10000mV: \n");
+			OSA_TimeDelay(10);
+			int value = read5digits(0, 10000);
+
+			uint16_t VALUE_Command = AssembleDAC_DAT((value*4095/10000));
+
+			/* --- --- --- CONFIGURE DAC STATIC OUTPUT VALUE */
+			writeCommand(DAC_DataPorts[DAC_port[k]], VALUE_Command, 0); /* DAC CONTROL (0) [Write] */
+			OSA_TimeDelay(1);
+			/* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- --- */
+		}	
+	}
+
+	/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+	if(DAC_WAVE_number == 0){ /* IF NO WAVEFORM GENERATION LOOP IS REQUIRED, READ ALL ADCs DATA */
+
+		if(ADC_number >= 1) {
+			SEGGER_RTT_WriteString(0, "\r\t READING ADCs DATA \n");
+			OSA_TimeDelay(10);
+
+			for(int k = 1; k <= ADC_number; k++){
+				/* --- --- ---  READ ADC REGISTER VALUE */
+				writeCommand(ADC_DataPorts[ADC_port[k]], 0x0000, 1); /* ADC CONTROL (1) [Read] */
+				OSA_TimeDelay(1);
+
+				uint16_t ADC_DATA = ((inBuffer[1] << 8) | inBuffer[2]) & 0x0FFF;
+				/* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- --- */
+
+				SEGGER_RTT_printf(0, "\r\t ADC on PORT # %d selected: ADC DATA: %d [mV] \n", ADC_port[k], ADC_DATA*(10000/4096));
+				OSA_TimeDelay(10);
+			}
+		}
+	}
+	
+	else{
+
+		int amplitude = 0;
+		int period = 0;
+
+		SEGGER_RTT_WriteString(0, "\r\t Variable DAC Output Configuration \n");
+		OSA_TimeDelay(10);
+
+		SEGGER_RTT_WriteString(0, "\r\t Select Number of Steps. Enter a value between 00000 and 10000: \n");
+		OSA_TimeDelay(10);
+
+		period = read5digits(0, 10000);
+
+		SEGGER_RTT_WriteString(0, "\r\t Select amplitude. Enter a value between 00000mV and 10000mV: \n");
+		OSA_TimeDelay(10);
+
+		amplitude = read5digits(0, 10000);
+
+		SEGGER_RTT_WriteString(0, "\r\t Waveform Generator Starts \n");
+		OSA_TimeDelay(10);
+
+		/* --- --- ---  CONFIGURE DAC STATIC OUTPUT VALUE */
+		writeCommand(DAC_DataPorts[DAC_WAVE_port], Scommand4_DAC, 0); /* DAC CONTROL  (0) [Write] */
+		OSA_TimeDelay(1);
+		/* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- --- */
+
+		SEGGER_RTT_printf(0, "\r\t DAC # %d selected. \n", DAC_WAVE_port);
+		OSA_TimeDelay(10);
+
+		int WAVE_INT = 0;
+
+		for(int l = 0; l <= period; l++){
+
+			float slope = (amplitude*4095/period/1000);
+			WAVE_INT = l*slope/10;
+			uint16_t WAVE_Command = AssembleDAC_DAT(WAVE_INT);
+
+			/* --- --- ---  CONFIGURE DAC OUTPUT VALUE */
+			writeCommand(DAC_DataPorts[DAC_WAVE_port], WAVE_Command, 0); /* DAC CONTROL  (0) [Write] */
+			OSA_TimeDelay(1);
+			/* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- --- */
+
+			/* FOR EACH LOOP ITERATION, READ ALL THE ADCs DATA */
+			if(ADC_number >= 1){
+
+				for (int k = 1; k <= ADC_number; k++){
+					
+					/* --- --- ---  READ ADC REGISTER VALUE */
+					writeCommand(ADC_DataPorts[ADC_port[k]], 0x0000, 1); /* ADC CONTROL  (1) [Read] */
+					OSA_TimeDelay(1);
+
+					uint16_t ADC_DATA = ((inBuffer[1] << 8) | inBuffer[2]) & 0x0FFF;
+					/* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- ---  */
+
+					SEGGER_RTT_printf(0, "\r\t ADC on PORT # %d selected: ADC DATA: %d [mV] \n", ADC_port[k], ADC_DATA*(10000/4096));
+					OSA_TimeDelay(10);
+				}
+			}
+		}
+	}
+
+	/*		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		*/
+
+	return 0;
+
+	SEGGER_RTT_WriteString(0, "\r\t Test ENDS \n");
+	OSA_TimeDelay(10);
+
+}
+
+
diff --git a/src/boot/ksdk1.1.0/devMAX11300.h b/src/boot/ksdk1.1.0/devMAX11300.h
new file mode 100644
index 0000000..bfc7c52
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devMAX11300.h
@@ -0,0 +1,2 @@
+
+int MAX11300(void);
diff --git a/src/boot/ksdk1.1.0/devMAX11300_FC.c b/src/boot/ksdk1.1.0/devMAX11300_FC.c
new file mode 100644
index 0000000..8023f0c
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devMAX11300_FC.c
@@ -0,0 +1,914 @@
+/*
+    Authored 2019-2020, Giorgio Mallia.
+
+    All rights reserved.
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions
+    are met:
+
+    *    Redistributions of source code must retain the above
+        copyright notice, this list of conditions and the following
+        disclaimer.
+
+    *    Redistributions in binary form must reproduce the above
+        copyright notice, this list of conditions and the following
+        disclaimer in the documentation and/or other materials
+        provided with the distribution.
+
+    *    Neither the name of the author nor the names of its
+        contributors may be used to endorse or promote products
+        derived from this software without specific prior written
+        permission.
+
+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#include <stdint.h>
+
+#include "fsl_spi_master_driver.h"
+#include "fsl_port_hal.h"
+
+#include "SEGGER_RTT.h"
+#include "gpio_pins.h"
+#include "warp.h"
+#include "devSSD1331.h"
+
+
+
+volatile uint8_t    inBuffer[32];
+volatile uint8_t    payloadBytes[32];
+
+
+/*
+ *    Override Warp firmware's use of these pins and define new aliases.
+ */
+enum
+{
+    kMAX11300PinMISO       = GPIO_MAKE_PIN(HW_GPIOA, 6),
+    kMAX11300PinMOSI       = GPIO_MAKE_PIN(HW_GPIOA, 8),
+    kMAX11300PinSCK        = GPIO_MAKE_PIN(HW_GPIOA, 9),
+    kMAX11300PinCSn        = GPIO_MAKE_PIN(HW_GPIOB, 13),
+};
+
+
+int writeCommand(uint8_t Register_Byte, uint16_t Command_Bytes, bool W_R) /* W_R = 0/1 (Write/Read) */
+{
+    spi_status_t status;
+    
+    /*
+     *    Drive /CS low.
+     *
+     *    Make sure there is a high-to-low transition by first driving high, delay, then drive low.
+     */
+    
+    GPIO_DRV_SetPinOutput(kMAX11300PinCSn);
+    OSA_TimeDelay(10);
+    GPIO_DRV_ClearPinOutput(kMAX11300PinCSn);
+    
+    uint8_t Byte1 = (Register_Byte << 1) | W_R;
+    uint8_t Byte2 = Command_Bytes >> 8;
+    uint8_t Byte3 = Command_Bytes & 0xff;
+    
+    payloadBytes[0] = Byte1;
+    payloadBytes[1] = Byte2;
+    payloadBytes[2] = Byte3;
+    
+    status = SPI_DRV_MasterTransferBlocking(0    /* master instance */,
+                      NULL        /* spi_master_user_config_t */,
+                      (const uint8_t * restrict)&payloadBytes[0],
+                      (uint8_t * restrict) &inBuffer[0],
+                      3       /* transfer size */,
+                      2000        /* timeout in microseconds */);
+
+    /*
+     *    Drive /CS high
+     */
+    
+    GPIO_DRV_SetPinOutput(kMAX11300PinCSn);
+
+    return status;
+}
+
+/*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+void read_ID(void){
+    SEGGER_RTT_printf(0, "\r\t Address (R/W): 0x%x Commands: 0x%x 0x%x \n", payloadBytes[0], payloadBytes[1], payloadBytes[2]);
+    OSA_TimeDelay(10);
+    writeCommand(0x00, 0x0000, 1); /* READ DEVICE ID: 0x00 (1) [Read] */
+    SEGGER_RTT_printf(0, "\r\t Bytes Received: 0x%x 0x%x 0x%x \n", inBuffer[0], inBuffer[1], inBuffer[2]);
+    OSA_TimeDelay(10);
+}
+
+/*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+int read_1_digit(int Lower_limit, int Higher_limit){
+    int number = -1;
+    while (!(number >= Lower_limit && number <= Higher_limit)){
+        number = SEGGER_RTT_WaitKey() - '0';
+    }
+    return number;
+}
+
+/*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+int read_2_digits(int Lower_limit, int Higher_limit){
+    int Digit1 = 0;
+    int Digit2 = 0;
+    int number = -1;
+    while (!(number >= Lower_limit && number <= Higher_limit)){
+        Digit1 = SEGGER_RTT_WaitKey() - '0';
+        Digit2 = SEGGER_RTT_WaitKey() - '0';
+        number = Digit1*10 + Digit2;
+    }
+    return number;
+}
+
+/*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+int read_4_digits(int Lower_limit, int Higher_limit){
+    int Digit1 = 0;
+    int Digit2 = 0;
+    int Digit3 = 0;
+    int Digit4 = 0;
+    int number = -1;
+    while (!(number >= Lower_limit && number <= Higher_limit)){
+        Digit1 = SEGGER_RTT_WaitKey() - '0';
+        Digit2 = SEGGER_RTT_WaitKey() - '0';
+        Digit3 = SEGGER_RTT_WaitKey() - '0';
+        Digit4 = SEGGER_RTT_WaitKey() - '0';
+        number = Digit1*1000 + Digit2*100 + Digit3*10 + Digit4*1;
+    }
+    return number;
+}
+
+/*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+int read_5_digits(int Lower_limit, int Higher_limit){
+    int Digit1 = 0;
+    int Digit2 = 0;
+    int Digit3 = 0;
+    int Digit4 = 0;
+    int Digit5 = 0;
+    int number = -1;
+    while (!(number >= Lower_limit && number <= Higher_limit)){
+        Digit1 = SEGGER_RTT_WaitKey() - '0';
+        Digit2 = SEGGER_RTT_WaitKey() - '0';
+        Digit3 = SEGGER_RTT_WaitKey() - '0';
+        Digit4 = SEGGER_RTT_WaitKey() - '0';
+        Digit5 = SEGGER_RTT_WaitKey() - '0';
+        number = Digit1*10000 + Digit2*1000 + Digit3*100 + Digit4*10 + Digit5*1;
+    }
+    return number;
+}
+
+/*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+uint16_t assemble_Command(bool D[16]){
+    uint16_t Command = 0;
+    for(int i=0; i<16; i++){
+       Command |= D[i] << i;
+    }
+    return Command;
+}
+
+/*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+void SPI_Scope(void){
+    SEGGER_RTT_printf(0, "\r\t Address (R/W): 0x%x Commands: 0x%x 0x%x \n", payloadBytes[0], payloadBytes[1], payloadBytes[2]);
+    OSA_TimeDelay(10);
+    SEGGER_RTT_printf(0, "\r\t Bytes Received: 0x%x 0x%x 0x%x \n", inBuffer[0], inBuffer[1], inBuffer[2]);
+    OSA_TimeDelay(10);
+}
+
+/*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+uint16_t Assemble_DAC_DAT(int Data){
+    
+    bool D_C_DAC_DATA[12];
+    for (int i = 0; i < 12; i++)
+    {
+        D_C_DAC_DATA[i] = (((Data >> i) & 1) == 1);
+    }
+
+    bool D_C_DAC_DATA_C[16] = {D_C_DAC_DATA[0], D_C_DAC_DATA[1], D_C_DAC_DATA[2], D_C_DAC_DATA[3], D_C_DAC_DATA[4], D_C_DAC_DATA[5], D_C_DAC_DATA[6], D_C_DAC_DATA[7], D_C_DAC_DATA[8], D_C_DAC_DATA[9], D_C_DAC_DATA[10], D_C_DAC_DATA[11], 0, 0, 0, 0};
+
+    uint16_t S_Command = assemble_Command(D_C_DAC_DATA_C);
+    
+    return S_Command;
+}
+
+/*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+uint16_t Assemble_CONF(bool FUNCPRM[12], bool FUNCid[13][4], int FUNC){
+    
+    bool D_C_FUNC_DAC_ID_PRM_C[16] = {  FUNCPRM[11],
+                                        FUNCPRM[10],
+                                        FUNCPRM[9],
+                                        FUNCPRM[8],
+                                        FUNCPRM[7],
+                                        FUNCPRM[6],
+                                        FUNCPRM[5],
+                                        FUNCPRM[4],
+                                        FUNCPRM[3],
+                                        FUNCPRM[2],
+                                        FUNCPRM[1],
+                                        FUNCPRM[0],
+                                        FUNCid[FUNC][3],
+                                        FUNCid[FUNC][2],
+                                        FUNCid[FUNC][1],
+                                        FUNCid[FUNC][0]};
+    
+    uint16_t S_Command = assemble_Command(D_C_FUNC_DAC_ID_PRM_C);
+    
+    return S_Command;
+}
+
+
+/*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+int read_1_char(char input[10]){
+    
+    char Character = '0';
+    while (!((Character == input[0] || Character == input[1]) || (Character == input[2] || Character == input[3]) || (Character == input[4] || Character == input[5]) || (Character == input[6] || Character == input[7]) || (Character == input[8] || Character == input[9]))){
+        
+        Character = SEGGER_RTT_WaitKey();
+    }
+    
+    int match = 0;
+    
+    if(Character == input[0] || Character == input[1]){
+        match = 1;
+    }
+    else if(Character == input[2] || Character == input[3]){
+        match = 2;
+    }
+    else if(Character == input[4] || Character == input[5]){
+        match = 3;
+    }
+    else if(Character == input[6] || Character == input[7]){
+        match = 4;
+    }
+    else if(Character == input[8] || Character == input[9]){
+        match = 5;
+    }
+    
+    return  match;
+    
+}
+
+/*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+
+int devMAX11300(void){
+    
+    /*
+     *    Override Warp firmware's use of these pins.
+     *
+     *    Re-configure SPI to be on PTA8 and PTA9 for MOSI and SCK respectively.
+     */
+    
+    PORT_HAL_SetMuxMode(PORTA_BASE, 6u, kPortMuxAlt3);
+    PORT_HAL_SetMuxMode(PORTA_BASE, 8u, kPortMuxAlt3);
+    PORT_HAL_SetMuxMode(PORTA_BASE, 9u, kPortMuxAlt3);
+
+    enableSPIpins();
+
+    /*
+     *    Override Warp firmware's use of these pins.
+     *
+     *    Reconfigure to use as GPIO.
+     */
+    
+    PORT_HAL_SetMuxMode(PORTB_BASE, 13u, kPortMuxAsGpio);
+    
+    
+    /*  Address     R/W    Description       B15     B14     B13     B12     B11     B10     B9      B8      B7      B6      B5      B4      B3      B2      B1      B0      */
+    /*  0X00        R      DEVICE ID         -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       */
+    /*  0X10        R/W    DEVICE CONTROL    RESET   BRST    LPEN    RS_C    TMPP    TMPC2   TMPC1   TMPC0   THSHD   DACREF  ADCc1   ADCc0   DACL1   DACL0   ADCL1   ADCL0   */
+    
+
+    int RESET   = 0;
+    int BRST    = 0;
+    int LPEN    = 0;
+    int RS_C    = 0;
+    
+    int TMPP    = 0;
+    int TMPC2   = 0;
+    int TMPC1   = 0;
+    int TMPC0   = 0;
+    int THSHD   = 0;
+    int DACREF  = 0;
+    
+    int ADCc1   = 0;
+    int ADCc0   = 0;
+    
+    int DACL    = 0;
+    int DACL1   = 0;
+    int DACL0   = 0;
+    
+    int ADCL    = 0;
+    int ADCL1   = 0;
+    int ADCL0   = 0;
+        
+    int PORT    = 0;
+    int MODE    = 0;
+    
+    int DAC_DAT = 0;
+    
+    
+    bool FUNCid_XXXX [13][4] = {    {0, 0, 0, 0}, /* 0:   High impedance port */
+                                    {0, 0, 0, 1},
+                                    {0, 0, 1, 0},
+                                    {0, 0, 1, 1},
+                                    {0, 1, 0, 0},
+                                    {0, 1, 0, 1}, /* 5:   Analog output for DAC */
+                                    {0, 1, 1, 0},
+                                    {0, 1, 1, 1}, /* 7:   Positive analog input to single-ended ADC */
+                                    {1, 0, 0, 0},
+                                    {1, 0, 0, 1},
+                                    {1, 0, 1, 0},
+                                    {1, 0, 1, 1},
+                                    {1, 1, 0, 0}}; /* 12: Analog switch */
+    
+    
+    /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+    uint16_t   S_Command1       = 0;
+    uint16_t   S_Command2       = 0;
+    uint16_t   S_Command3       = 0;
+    uint16_t   S_Command4       = 0;
+    uint16_t   S_Command4_AS    = 0;
+    uint16_t   S_Command4_DAC   = 0;
+    uint16_t   S_Command4_HI    = 0;
+    uint16_t   S_Command4_ADC   = 0;
+    uint16_t   S_Command5       = 0;
+        
+    uint8_t ADC_DataPorts[20] = {0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53};
+    uint8_t DAC_DataPorts[20] = {0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73};
+    uint8_t PORT_Config_Addr[20] = {0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33};
+        
+    /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+    SEGGER_RTT_WriteString(0, "\r\t Configuration starts \n");
+    OSA_TimeDelay(10);
+
+    SEGGER_RTT_WriteString(0, "\r\t Enter Configuration Mode: Manual (M) or Auto (A) \n");
+    OSA_TimeDelay(10);
+
+    char Character = '0';
+       while (!((Character == 'M' || Character == 'm')||(Character == 'A' || Character == 'a'))){
+           Character = SEGGER_RTT_WaitKey();
+       }
+        
+    if (Character == 'M' || Character == 'm'){
+        
+        SEGGER_RTT_WriteString(0, "\r\t Manual Configutation Selected \n");
+        OSA_TimeDelay(10);
+
+        /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+        SEGGER_RTT_WriteString(0, "\r\t Serial interface burst-mode selection (0/1): \n");
+        OSA_TimeDelay(10);
+
+        /*  0: Default address incrementing mode    */
+        /*  1: Contextual address incrementing mode */
+            BRST = read_1_digit(0, 1);
+            
+            if(BRST == 0){
+                SEGGER_RTT_WriteString(0, "\r\t Default address incrementing mode selected. \n");
+                OSA_TimeDelay(10);
+
+            }
+            else{
+                SEGGER_RTT_WriteString(0, "\r\t Contextual address incrementing mode selected. \n");
+                OSA_TimeDelay(10);
+
+            }
+            
+        /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+        SEGGER_RTT_WriteString(0, "\r\t Thermal shutdown Mode Selection (0/1): \n");
+        OSA_TimeDelay(10);
+
+        /*  0: Thermal shutdown disabled */
+        /*  1: Thermal shutdown enabled */
+            THSHD = read_1_digit(0, 1);
+                
+            if(THSHD == 0){
+                SEGGER_RTT_printf(0, "\r\t Thermal shutdown disabled. \n");
+                OSA_TimeDelay(10);
+
+            }
+            else{
+                SEGGER_RTT_printf(0, "\r\t Thermal shutdown enabled. \n");
+                OSA_TimeDelay(10);
+
+            }
+            
+        /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+        SEGGER_RTT_WriteString(0, "\r\t ADC Conversion Rate Selection (0-3): \n");
+        OSA_TimeDelay(10);
+        /*  0: 200kbps
+            1: 250kbps
+            2: 333kbps
+            3: 400kbps  */
+        int Rate[4] = {200, 250, 333, 400};
+            ADCL = read_1_digit(0, 3);
+            SEGGER_RTT_printf(0, "\r\t Rate %d kbps Selected. \n", Rate[ADCL]);
+            OSA_TimeDelay(10);
+
+        /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+        BRST = BRST;
+        THSHD = THSHD;
+        ADCL1 = (ADCL>1);
+        ADCL0 = (ADCL % 2 != 0);
+               
+        bool D_C1[16] = {(ADCL0==1), (ADCL1==1), (DACL0==1), (DACL1==1), (ADCc0==1), (ADCc1==1), (DACREF==1), (THSHD==1), (TMPC0==1), (TMPC1==1), (TMPC2==1), (TMPP==1), (RS_C==1), (LPEN==1), (BRST==1), (RESET==1)};
+
+        S_Command1 = assemble_Command(D_C1);
+    
+        SEGGER_RTT_printf(0, "\r\t Bytes Selected: %x \n", S_Command1);
+        OSA_TimeDelay(10);
+
+        /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+        SEGGER_RTT_WriteString(0, "\r\t Port Configuration Mode Selection (03-12): \n");
+        OSA_TimeDelay(10);
+
+        /*  03: Digital Output with DAC Controlled Level
+            04: Unidirectional Path Output with DAC Controlled Level
+            05: Analog Output for DAC
+            06: Analog Output for DAC with ADC Monitoring
+            07: Positive Analog IN to Single Ended ADC
+            08: Positive Analog IN to Differential  ADC
+            09: Negative Analog IN to Differential  ADC
+            10: Analog Output for DAC and negative IN for Differential ADC
+            11: Terminal to GPI-Controlled Analog Switch
+            12: Terminal to Register-Controlled Analog Switch   */
+        MODE = read_2_digits(3, 12);
+        SEGGER_RTT_printf(0, "\r\t Mode %d Selected. \n", MODE);
+        OSA_TimeDelay(10);
+                    
+        /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+        if(MODE == 1 || MODE == 3 || MODE == 4 || MODE == 5 || MODE == 6 || MODE == 10){
+                 
+            SEGGER_RTT_WriteString(0, "\r\t Configure DACREF, DACL: \n");
+            OSA_TimeDelay(10);
+
+            /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+            SEGGER_RTT_WriteString(0, "\r\t DAC Reference Selection (0/1): \n");
+            OSA_TimeDelay(10);
+            /*  0: External Reference Voltage
+                1: Internal Reference Voltage */
+            DACREF = read_1_digit(0, 1);
+                          
+            if(DACREF == 0){
+                SEGGER_RTT_printf(0, "\r\t External Reference. \n");
+                OSA_TimeDelay(10);
+            }
+            else{
+                SEGGER_RTT_printf(0, "\r\t Internal Reference. \n");
+                OSA_TimeDelay(10);
+            }
+                  
+            /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+            SEGGER_RTT_WriteString(0, "\r\t DAC Mode Selection (0-3): \n");
+            OSA_TimeDelay(10);
+            /*  0: Sequential mode for DAC configured ports
+                1: Immediate update for DAC configured ports
+                2: All DAC configured ports use the same data stored in DACPRSTDAT1[11:0]
+                3: All DAC configured ports use the same data stored in DACPRSTDAT2[11:0]   */
+            DACL = read_1_digit(0, 3);
+            SEGGER_RTT_printf(0, "\r\t DAC Mode %d Selected. \n", DACL);
+            OSA_TimeDelay(10);
+            
+            /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+            BRST = BRST;
+            THSHD = THSHD;
+            ADCL1 = (ADCL>1);
+            ADCL0 = (ADCL % 2 != 0);
+                       
+            DACREF = DACREF;
+            DACL1 = (DACL>1);
+            DACL0 = (DACL % 2 != 0);
+                            
+            bool D_C2[16] = {(ADCL0==1), (ADCL1==1), (DACL0==1), (DACL1==1), (ADCc0==1), (ADCc1==1), (DACREF==1), (THSHD==1), (TMPC0==1), (TMPC1==1), (TMPC2==1), (TMPP==1), (RS_C==1), (LPEN==1), (BRST==1), (RESET==1)};
+                        
+            S_Command2 = assemble_Command(D_C2);
+            
+            SEGGER_RTT_printf(0, "\r\t Bytes Selected: %x \n", S_Command2);
+            OSA_TimeDelay(10);
+            
+            /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+            if (!((DACL == 2) || (DACL == 3))){
+                      
+                SEGGER_RTT_WriteString(0, "\r\t Enter DACDAT[i] for ports in mode 1,3,4,5,6 or 10 \n");
+                OSA_TimeDelay(10);
+
+                SEGGER_RTT_WriteString(0, "\r\t Select Port (00-19) \n");
+                OSA_TimeDelay(10);
+
+                PORT = read_2_digits(0, 19);
+                SEGGER_RTT_printf(0, "\r\t Port %d Selected. \n", PORT);
+                OSA_TimeDelay(10);
+
+                SEGGER_RTT_WriteString(0, "\r\t Enter Data (0000-4095) \n");
+                OSA_TimeDelay(10);
+
+                DAC_DAT = read_4_digits(0, 4095);
+                SEGGER_RTT_printf(0, "\r\t Value Selected: %d \n", DAC_DAT);
+                OSA_TimeDelay(10);
+                    
+                S_Command3 = Assemble_DAC_DAT(DAC_DAT);
+                
+                SEGGER_RTT_printf(0, "\r\t Bytes Selected: %x \n", S_Command3);
+                OSA_TimeDelay(10);
+
+            }
+                    
+                  
+            else{
+                
+                SEGGER_RTT_WriteString(0, "\r\t Enter DACPRSTDAT1 or DACPRSTDAT2 DATA \n");
+                OSA_TimeDelay(10);
+
+                SEGGER_RTT_WriteString(0, "\r\t Enter Data for DACPRSTDAT1 (0000-4095): \n");
+                OSA_TimeDelay(10);
+
+                int DACPRSTDAT1 = read_4_digits(0, 4095);
+                SEGGER_RTT_printf(0, "\r\t Values Selected: %d \n", DACPRSTDAT1);
+                OSA_TimeDelay(10);
+
+                SEGGER_RTT_WriteString(0, "\r\t Enter Data for DACPRSTDAT2 (0000-4095): \n");
+                OSA_TimeDelay(10);
+
+                int DACPRSTDAT2 = read_4_digits(0, 4095);
+                      
+                SEGGER_RTT_printf(0, "\r\t Values Selected: %d \n", DACPRSTDAT2);
+                OSA_TimeDelay(10);
+                
+                S_Command3 = Assemble_DAC_DAT(DACPRSTDAT1);
+                
+                SEGGER_RTT_printf(0, "\r\t Bytes Selected: %x \n", S_Command3);
+                OSA_TimeDelay(10);
+
+
+            }
+            
+        }
+        
+    }
+    
+    /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+    else{
+       
+            /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+            BRST = 0;   /*  0: Default address incrementing mode */
+            /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+            THSHD = 0;  /*  0: Thermal shutdown disabled    */
+            /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+            ADCL = 0;   /*  0: 200kbps */
+            /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+            BRST = BRST;
+            THSHD = THSHD;
+            ADCL1 = (ADCL>1);
+            ADCL0 = (ADCL % 2 != 0);
+                  
+            bool D_C1[16] = {(ADCL0==1), (ADCL1==1), (DACL0==1), (DACL1==1), (ADCc0==1), (ADCc1==1), (DACREF==1), (THSHD==1), (TMPC0==1), (TMPC1==1), (TMPC2==1), (TMPP==1), (RS_C==1), (LPEN==1), (BRST==1), (RESET==1)};
+       
+            S_Command1 = assemble_Command(D_C1);
+           
+            /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+            MODE = 5;   /*  DAC Output port */
+            /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+            DACREF = 1; /*  DAC Internal referenc    */
+            /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+            DACL = 1;   /*  Immediate update for DAC configured ports   */
+            /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+            BRST = BRST;
+            THSHD = THSHD;
+            ADCL1 = (ADCL>1);
+            ADCL0 = (ADCL % 2 != 0);
+                      
+            DACREF = DACREF;
+            DACL1 = (DACL>1);
+            DACL0 = (DACL % 2 != 0);
+                           
+            bool D_C2[16] = {(ADCL0==1), (ADCL1==1), (DACL0==1), (DACL1==1), (ADCc0==1), (ADCc1==1), (DACREF==1), (THSHD==1), (TMPC0==1), (TMPC1==1), (TMPC2==1), (TMPP==1), (RS_C==1), (LPEN==1), (BRST==1), (RESET==1)};
+                           
+            S_Command2 = assemble_Command(D_C2);
+               
+            /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+            S_Command3 = Assemble_DAC_DAT(0); /* INITIALISE DAC DATA AS 0 */
+
+    }
+        
+    /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+    bool FUNCPRM_GEN_test[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    /* FUNCPRM GENERAL PURPOSE - HI & AS   */
+    bool FUNCPRM_DAC_test[12] = {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0};    /* FUNCPRM DAC: Voltage range from 0V to +10V  */
+    bool FUNCPRM_ADC_test[12] = {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0};    /* FUNCPRM DAC: Voltage range from 0V to +10V, 1 Sample    */
+    
+    S_Command4_DAC = Assemble_CONF(FUNCPRM_DAC_test, FUNCid_XXXX, 5);    /* DAC MODE CONFIGURATION COMMAND  */
+    S_Command4_AS  = Assemble_CONF(FUNCPRM_GEN_test, FUNCid_XXXX, 12);   /* AS MODE CONFIGURATION COMMAND   */
+    S_Command4_HI  = Assemble_CONF(FUNCPRM_GEN_test, FUNCid_XXXX, 0);    /* HIGH IMPEDANCE PORT MODE CONFIGURATION COMMAND  */
+    S_Command4_ADC = Assemble_CONF(FUNCPRM_ADC_test, FUNCid_XXXX, 7);    /* HIGH IMPEDANCE PORT MODE CONFIGURATION COMMAND  */
+    
+    bool INTERRUPT_MSK_REG[16] = {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; /*   INTERRUPT REGISTER: DAC OVERCURRENT INTERRUPT  0000 0100 0000 0000    */
+    S_Command5 = assemble_Command(INTERRUPT_MSK_REG);
+                   
+    /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+    SEGGER_RTT_WriteString(0, "\r\t Port Configuration Starts \n");
+    OSA_TimeDelay(10);
+
+    read_ID();
+    OSA_TimeDelay(1);
+    SPI_Scope();
+
+    writeCommand(0x10, S_Command1, 0); /*   DEVICE CONTROL (0) [Write]  */
+    OSA_TimeDelay(1);
+    SPI_Scope();
+
+    writeCommand(0x10, S_Command2, 0); /*   DEVICE CONTROL (0) [Write]  */
+    OSA_TimeDelay(1);
+    SPI_Scope();
+    
+    /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+    SEGGER_RTT_WriteString(0, "\r\t Select Port Configuration: Enter a 20-element vector. \n");
+    OSA_TimeDelay(10);
+    SEGGER_RTT_WriteString(0, "\r\t Options: Analogue switch (A), DAC Output (O), Waveform Generator (G), High impedance port (H) or ADC Input port (I): \n");
+    OSA_TimeDelay(10);
+    
+    
+    int AS_number = 0;
+    int AS_port[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+    
+    int DAC_number = 0;
+    int DAC_port[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+    
+    int ADC_number = 0;
+    int ADC_port[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+    
+    int DAC_WAVE_number = 0;
+    int DAC_WAVE_port = 0;
+    
+    int HI_number = 0;
+    int HI_port[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+    
+    int length = 20;
+    char input_values[10] = {'a', 'A', 'o', 'O', 'g', 'G', 'h', 'H', 'i', 'I'};
+    int input = 0;
+    
+    int c = 0;
+    while(c != 1){
+    
+        for(int i = 0; i < length; i++){
+            input = read_1_char(input_values);
+            
+            if (input == 1){
+                AS_number++;
+                AS_port[AS_number] = i;
+            }
+            else if (input == 2){
+                DAC_number++;
+                DAC_port[DAC_number] = i;
+            }
+            else if (input == 3){
+                DAC_WAVE_number++;
+                DAC_WAVE_port = i;
+            }
+            else if (input == 4){
+                HI_number++;
+                HI_port[HI_number] = i;
+            }
+            else if (input == 5){
+                ADC_number++;
+                ADC_port[ADC_number] = i;
+            }
+        }
+    
+        if(DAC_WAVE_number > 1){
+            SEGGER_RTT_WriteString(0, "\r\t Variable DAC Output ALREADY SELECTED \n");
+            OSA_TimeDelay(10);
+            
+            AS_number = 0;
+            ADC_number = 0;
+            DAC_number = 0;
+            HI_number = 0;
+            DAC_WAVE_number = 0;
+            DAC_WAVE_port = 0;
+            
+        }
+        else{
+            c = 1;
+        }
+        
+        
+    }
+    
+    /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+    if (AS_number >= 1){
+        for (int k = 0; k < AS_number; k++){
+
+            /* --- --- --- AS PORT CONFIGURATION    */
+            writeCommand(PORT_Config_Addr[AS_port[k]], S_Command4_AS, 0); /*    PORT CONTROL - AS (0) [Write]   */
+            OSA_TimeDelay(1);
+            /*  SPI_Scope();    */
+            /* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- ---  */
+            
+        }
+    }
+        
+    /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+    if (HI_number >= 1){
+        for (int k = 0; k < HI_number; k++){
+
+            /* --- --- --- HI PORT CONFIGURATION    */
+            writeCommand(PORT_Config_Addr[HI_port[k]], S_Command4_HI, 0); /*    PORT CONTROL - HI (0) [Write]  */
+            OSA_TimeDelay(1);
+            /* SPI_Scope(); */
+            /* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- ---  */
+            
+        }
+    }
+        
+    /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+    if (DAC_number >= 1){
+        
+        for (int k = 1; k <= DAC_number; k++){
+
+            /* --- --- --- DAC PORT CONFIGURATION   */
+            writeCommand(PORT_Config_Addr[DAC_port[k]], S_Command4_DAC, 0); /* PORT CONTROL - DAC (0) [Write]   */
+            OSA_TimeDelay(1);
+            /* SPI_Scope(); */
+            /* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- ---  */
+            
+        }
+        
+        SEGGER_RTT_printf(0, "\r\t DAC Configuration Starts. %d DACs selected. \n", DAC_number);
+        OSA_TimeDelay(10);
+        for (int k = 1; k <= DAC_number; k++){
+            SEGGER_RTT_printf(0, "\r\t Select single DAC output value for DAC # %d : \n", k);
+            OSA_TimeDelay(10);
+            
+            SEGGER_RTT_WriteString(0, "\r\t Enter a value between 00000mV and 10000mV: \n");
+            OSA_TimeDelay(10);
+            int value = read_5_digits(0, 10000);
+            
+            uint16_t VALUE_Command = Assemble_DAC_DAT((value*4095/10000));
+
+            /* --- --- ---  CONFIGURE DAC STATIC OUTPUT VALUE   */
+            writeCommand(DAC_DataPorts[DAC_port[k]], VALUE_Command, 0); /*  DAC CONTROL  (0) [Write] */
+            OSA_TimeDelay(1);
+            /* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- ---  */
+                
+        }
+        
+    }
+    
+    
+    int Amplitude = 0;
+    int Period = 0;
+    
+ 
+    if (DAC_WAVE_number == 1){
+            
+        SEGGER_RTT_WriteString(0, "\r\t Variable DAC Output Configuration \n");
+        OSA_TimeDelay(10);
+        
+        SEGGER_RTT_WriteString(0, "\r\t Select Period. Enter a value between 00000ms and 10000ms: \n");
+        OSA_TimeDelay(10);
+
+        Period = read_5_digits(0, 10000);
+        
+        SEGGER_RTT_WriteString(0, "\r\t Select Amplitude. Enter a value between 00000mV and 10000mV: \n");
+        OSA_TimeDelay(10);
+
+        Amplitude = read_5_digits(0, 10000);
+    
+        SEGGER_RTT_WriteString(0, "\r\t Waveform Generator Starts \n");
+        OSA_TimeDelay(10);
+        
+        /* --- --- --- DAC PORT CONFIGURATION   */
+        writeCommand(PORT_Config_Addr[DAC_WAVE_port], S_Command4_DAC, 0); /* PORT CONTROL - DAC (0) [Write] */
+        OSA_TimeDelay(1);
+        /* SPI_Scope(); */
+        /* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- ---  */
+ 
+        /* --- --- ---  CONFIGURE DAC STATIC OUTPUT VALUE   */
+        writeCommand(DAC_DataPorts[DAC_WAVE_port], S_Command4_DAC, 0); /* DAC CONTROL  (0) [Write]  */
+        OSA_TimeDelay(1);
+        /* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- ---  */
+        
+        SEGGER_RTT_printf(0, "\r\t DAC # %d selected. \n", DAC_WAVE_port);
+        OSA_TimeDelay(10);
+
+        int WAVE_INT = 0;
+
+        for(int l = 0; l <= Period; l+=1){
+          
+            float Slope = (Amplitude*4095/Period/1000);
+          
+            WAVE_INT = l*Slope/10;
+          
+            /*       -       -       -       -       -       -       -       -       -       -  */
+            uint16_t WAVE_Command = Assemble_DAC_DAT(WAVE_INT);
+            /* --- --- ---  CONFIGURE DAC OUTPUT VALUE  */
+            writeCommand(DAC_DataPorts[DAC_WAVE_port], WAVE_Command, 0); /* DAC CONTROL  (0) [Write] */
+            OSA_TimeDelay(1);
+            /* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- ---  */
+        
+        }
+        
+    }
+    
+        
+    if (ADC_number >= 1){
+        
+        
+        SEGGER_RTT_WriteString(0, "\r\t ADCs Configuration \n");
+        OSA_TimeDelay(10);
+        
+        for (int k = 1; k <= ADC_number; k++){
+
+            /* --- --- --- ADC PORT CONFIGURATION   */
+            writeCommand(PORT_Config_Addr[ADC_port[k]], S_Command4_ADC, 0); /* PORT CONTROL - ADC (0) [Write] */
+            OSA_TimeDelay(1);
+            /* SPI_Scope(); */
+            /* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- ---  */
+        }
+       
+        ADCL0 = 1;
+        ADCL1 = 0;
+/*
+        bool D_C4[16] = {(ADCL0==1), (ADCL1==1), (DACL0==1), (DACL1==1), (ADCc0==1), (ADCc1==1), (DACREF==1), (THSHD==1), (TMPC0==1), (TMPC1==1), (TMPC2==1), (TMPP==1), (RS_C==1), (LPEN==1), (BRST==1), (RESET==1)};
+                    
+        S_Command4 = assemble_Command(D_C4);
+        
+        writeCommand(0x10, S_Command4, 0); // DEVICE CONTROL (0) [Write]  - CONFIGURE ACCTL
+        OSA_TimeDelay(1);
+        SPI_Scope();
+        
+        SEGGER_RTT_WriteString(0, "\r\t READING ADCs DATA \n");
+        OSA_TimeDelay(10);
+    
+        for (int k = 1; k <= ADC_number; k++){
+            
+            // --- --- ---  READ ADC REGISTER VALUE //
+            writeCommand(ADC_DataPorts[ADC_port[k]], 0x0000, 1); // DAC CONTROL  (1) [Read]
+            OSA_TimeDelay(1);
+            
+            int ADC_DATA = (inBuffer[1] << inBuffer[0]) & 0x0FFF;
+            // --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- ---  //
+            
+            SEGGER_RTT_printf(0, "\r\t ADC on PORT # %d selected: ADC DATA: # %d . \n", ADC_port[k], ADC_DATA);
+            OSA_TimeDelay(10);
+
+        }
+*/
+    }
+
+
+    /*       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -  */
+
+    SEGGER_RTT_WriteString(0, "\r\t Configuration & TEST END \n");
+    OSA_TimeDelay(10);
+
+    /* --- --- ---  CONFIGURE INTERRUPT CONTROL */
+    writeCommand(0x11, S_Command5, 0); /* INTERRUPT CONTROL  (0) [Write]    */
+    OSA_TimeDelay(1);
+    SPI_Scope();
+    /* --- --- ---  --- --- ---  --- --- ---  --- --- ---  --- --- ---  */
+
+    return 0;
+ 
+    
+}
diff --git a/src/boot/ksdk1.1.0/devMMA8451Q.c b/src/boot/ksdk1.1.0/devMMA8451Q.c
new file mode 100644
index 0000000..187712d
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devMMA8451Q.c
@@ -0,0 +1,308 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell. Additional contributors,
+	2018-onwards, see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+
+
+extern volatile WarpI2CDeviceState	deviceMMA8451QState;
+extern volatile uint32_t		gWarpI2cBaudRateKbps;
+extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
+extern volatile uint32_t		gWarpSupplySettlingDelayMilliseconds;
+
+
+
+void
+initMMA8451Q(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceMMA8451QState.i2cAddress			= i2cAddress;
+	deviceMMA8451QState.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+writeSensorRegisterMMA8451Q(uint8_t deviceRegister, uint8_t payload)
+{
+	uint8_t		payloadByte[1], commandByte[1];
+	i2c_status_t	status;
+
+	switch (deviceRegister)
+	{
+		case 0x09: case 0x0a: case 0x0e: case 0x0f:
+		case 0x11: case 0x12: case 0x13: case 0x14:
+		case 0x15: case 0x17: case 0x18: case 0x1d:
+		case 0x1f: case 0x20: case 0x21: case 0x23:
+		case 0x24: case 0x25: case 0x26: case 0x27:
+		case 0x28: case 0x29: case 0x2a: case 0x2b:
+		case 0x2c: case 0x2d: case 0x2e: case 0x2f:
+		case 0x30: case 0x31:
+		{
+			/* OK */
+			break;
+		}
+		
+		default:
+		{
+			return kWarpStatusBadDeviceCommand;
+		}
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceMMA8451QState.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	warpScaleSupplyVoltage(deviceMMA8451QState.operatingVoltageMillivolts);
+	commandByte[0] = deviceRegister;
+	payloadByte[0] = payload;
+	warpEnableI2Cpins();
+
+	status = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C instance */,
+							&slave,
+							commandByte,
+							1,
+							payloadByte,
+							1,
+							gWarpI2cTimeoutMilliseconds);
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+WarpStatus
+configureSensorMMA8451Q(uint8_t payloadF_SETUP, uint8_t payloadCTRL_REG1)
+{
+	WarpStatus	i2cWriteStatus1, i2cWriteStatus2;
+
+
+	warpScaleSupplyVoltage(deviceMMA8451QState.operatingVoltageMillivolts);
+
+	i2cWriteStatus1 = writeSensorRegisterMMA8451Q(kWarpSensorConfigurationRegisterMMA8451QF_SETUP /* register address F_SETUP */,
+							payloadF_SETUP /* payload: Disable FIFO */
+							);
+
+	i2cWriteStatus2 = writeSensorRegisterMMA8451Q(kWarpSensorConfigurationRegisterMMA8451QCTRL_REG1 /* register address CTRL_REG1 */,
+							payloadCTRL_REG1 /* payload */
+							);
+
+	return (i2cWriteStatus1 | i2cWriteStatus2);
+}
+
+WarpStatus
+readSensorRegisterMMA8451Q(uint8_t deviceRegister, int numberOfBytes)
+{
+	uint8_t		cmdBuf[1] = {0xFF};
+	i2c_status_t	status;
+
+
+	USED(numberOfBytes);
+	switch (deviceRegister)
+	{
+		case 0x00: case 0x01: case 0x02: case 0x03: 
+		case 0x04: case 0x05: case 0x06: case 0x09:
+		case 0x0a: case 0x0b: case 0x0c: case 0x0d:
+		case 0x0e: case 0x0f: case 0x10: case 0x11:
+		case 0x12: case 0x13: case 0x14: case 0x15:
+		case 0x16: case 0x17: case 0x18: case 0x1d:
+		case 0x1e: case 0x1f: case 0x20: case 0x21:
+		case 0x22: case 0x23: case 0x24: case 0x25:
+		case 0x26: case 0x27: case 0x28: case 0x29:
+		case 0x2a: case 0x2b: case 0x2c: case 0x2d:
+		case 0x2e: case 0x2f: case 0x30: case 0x31:
+		{
+			/* OK */
+			break;
+		}
+		
+		default:
+		{
+			return kWarpStatusBadDeviceCommand;
+		}
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceMMA8451QState.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	warpScaleSupplyVoltage(deviceMMA8451QState.operatingVoltageMillivolts);
+	cmdBuf[0] = deviceRegister;
+	warpEnableI2Cpins();
+
+	status = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							cmdBuf,
+							1,
+							(uint8_t *)deviceMMA8451QState.i2cBuffer,
+							numberOfBytes,
+							gWarpI2cTimeoutMilliseconds);
+
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+void
+printSensorDataMMA8451Q(bool hexModeFlag)
+{
+	uint16_t	readSensorRegisterValueLSB;
+	uint16_t	readSensorRegisterValueMSB;
+	int16_t		readSensorRegisterValueCombined;
+	WarpStatus	i2cReadStatus;
+
+
+	warpScaleSupplyVoltage(deviceMMA8451QState.operatingVoltageMillivolts);
+
+	/*
+	 *	From the MMA8451Q datasheet:
+	 *
+	 *		"A random read access to the LSB registers is not possible.
+	 *		Reading the MSB register and then the LSB register in sequence
+	 *		ensures that both bytes (LSB and MSB) belong to the same data
+	 *		sample, even if a new data sample arrives between reading the
+	 *		MSB and the LSB byte."
+	 *
+	 *	We therefore do 2-byte read transactions, for each of the registers.
+	 *	We could also improve things by doing a 6-byte read transaction.
+	 */
+	i2cReadStatus = readSensorRegisterMMA8451Q(kWarpSensorOutputRegisterMMA8451QOUT_X_MSB, 2 /* numberOfBytes */);
+	readSensorRegisterValueMSB = deviceMMA8451QState.i2cBuffer[0];
+	readSensorRegisterValueLSB = deviceMMA8451QState.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 6) | (readSensorRegisterValueLSB >> 2);
+
+	/*
+	 *	Sign extend the 14-bit value based on knowledge that upper 2 bit are 0:
+	 */
+	readSensorRegisterValueCombined = (readSensorRegisterValueCombined ^ (1 << 13)) - (1 << 13);
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+	i2cReadStatus = readSensorRegisterMMA8451Q(kWarpSensorOutputRegisterMMA8451QOUT_Y_MSB, 2 /* numberOfBytes */);
+	readSensorRegisterValueMSB = deviceMMA8451QState.i2cBuffer[0];
+	readSensorRegisterValueLSB = deviceMMA8451QState.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 6) | (readSensorRegisterValueLSB >> 2);
+
+	/*
+	 *	Sign extend the 14-bit value based on knowledge that upper 2 bit are 0:
+	 */
+	readSensorRegisterValueCombined = (readSensorRegisterValueCombined ^ (1 << 13)) - (1 << 13);
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+
+	i2cReadStatus = readSensorRegisterMMA8451Q(kWarpSensorOutputRegisterMMA8451QOUT_Z_MSB, 2 /* numberOfBytes */);
+	readSensorRegisterValueMSB = deviceMMA8451QState.i2cBuffer[0];
+	readSensorRegisterValueLSB = deviceMMA8451QState.i2cBuffer[1];
+	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 6) | (readSensorRegisterValueLSB >> 2);
+
+	/*
+	 *	Sign extend the 14-bit value based on knowledge that upper 2 bit are 0:
+	 */
+	readSensorRegisterValueCombined = (readSensorRegisterValueCombined ^ (1 << 13)) - (1 << 13);
+
+	if (i2cReadStatus != kWarpStatusOK)
+	{
+		warpPrint(" ----,");
+	}
+	else
+	{
+		if (hexModeFlag)
+		{
+			warpPrint(" 0x%02x 0x%02x,", readSensorRegisterValueMSB, readSensorRegisterValueLSB);
+		}
+		else
+		{
+			warpPrint(" %d,", readSensorRegisterValueCombined);
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devMMA8451Q.h b/src/boot/ksdk1.1.0/devMMA8451Q.h
new file mode 100644
index 0000000..499c720
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devMMA8451Q.h
@@ -0,0 +1,44 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell. Additional contributors,
+	2018-onwards, see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+void		initMMA8451Q(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts);
+WarpStatus	readSensorRegisterMMA8451Q(uint8_t deviceRegister, int numberOfBytes);
+WarpStatus	writeSensorRegisterMMA8451Q(uint8_t deviceRegister,
+					uint8_t payloadBtye);
+WarpStatus	configureSensorMMA8451Q(uint8_t payloadF_SETUP, uint8_t payloadCTRL_REG1);
+void		printSensorDataMMA8451Q(bool hexModeFlag);
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devRV8803C7.c b/src/boot/ksdk1.1.0/devRV8803C7.c
new file mode 100644
index 0000000..7a19e3d
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devRV8803C7.c
@@ -0,0 +1,428 @@
+/*
+	Authored 2019. Sam Willis. Additional contributions, 2019-onwards,
+	see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <stdint.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_rtc_driver.h"
+#include "fsl_i2c_master_driver.h"
+
+#include "warp.h"
+#include "devRV8803C7.h"
+
+extern volatile WarpI2CDeviceState	deviceRV8803C7State;
+extern volatile uint32_t		gWarpI2cBaudRateKbps;
+extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
+
+
+void
+initRV8803C7(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceRV8803C7State.i2cAddress			= i2cAddress;
+	deviceRV8803C7State.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+readRTCRegisterRV8803C7(uint8_t deviceRegister, uint8_t *receiveData)
+{
+	/*
+	 *	Read address in 'deviceRegister' into 'receiveData' over i2c from the RTC
+	 */
+	uint8_t		cmdBuff[1];
+	i2c_status_t	status;
+
+	if (deviceRegister > 0x2F) {
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave = {
+		.address = deviceRV8803C7State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+	
+	cmdBuff[0] = deviceRegister;
+
+	warpScaleSupplyVoltage(deviceRV8803C7State.operatingVoltageMillivolts);
+	warpEnableI2Cpins();
+	status = I2C_DRV_MasterReceiveDataBlocking(0 /* I2C instance */,
+							&slave,
+							cmdBuff,
+							1,
+							receiveData,
+							1,
+							gWarpI2cTimeoutMilliseconds);
+	warpDisableI2Cpins();
+
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+WarpStatus
+readRTCRegistersRV8803C7(uint8_t deviceStartRegister, uint8_t nRegs, uint8_t *  receiveData)
+{
+	/*
+	 *	Read 'nRegs' number of consecutive addresses from 'deviceStartRegister' into 'receiveData'
+	 *	over i2c from the RTC
+	 */
+	uint8_t		cmdBuff[1];
+	i2c_status_t	status;
+	
+	if (deviceStartRegister > 0x2F)
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+	
+	i2c_device_t slave = {
+		.address = deviceRV8803C7State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+	
+	cmdBuff[0] = deviceStartRegister;
+
+	warpScaleSupplyVoltage(deviceRV8803C7State.operatingVoltageMillivolts);
+	warpEnableI2Cpins();
+	status = I2C_DRV_MasterReceiveDataBlocking(0 /* I2C instance */,
+							&slave,
+							cmdBuff,
+							1,
+							receiveData,
+							nRegs,
+							gWarpI2cTimeoutMilliseconds);
+	warpDisableI2Cpins();
+
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+WarpStatus
+writeRTCRegisterRV8803C7(uint8_t deviceRegister, uint8_t payload)
+{
+	/*
+	 *	Write the value in 'payload' to the to the address in 'deviceRegister' over i2c to the RTC
+	 */
+	uint8_t		cmdBuff[1];
+	uint8_t		txBuff[1];
+	i2c_status_t	status;
+
+
+	if (deviceRegister > 0x2F)
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave = {
+		.address = deviceRV8803C7State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+	
+	cmdBuff[0] = deviceRegister;
+	txBuff[0] = payload;
+
+	warpScaleSupplyVoltage(deviceRV8803C7State.operatingVoltageMillivolts);
+	warpEnableI2Cpins();
+	status = I2C_DRV_MasterSendDataBlocking(0 /* I2C instance */,
+						&slave,
+						cmdBuff,
+						1,
+						txBuff,
+						1,
+						gWarpI2cTimeoutMilliseconds);
+	warpDisableI2Cpins();
+
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+WarpStatus
+writeRTCRegistersRV8803C7(uint8_t deviceStartRegister, uint8_t nRegs, uint8_t payload[])
+{
+	/*
+	 *	Write to fill 'nRegs' number of consecutive registers, starting with the address at 'deviceStartRegister'
+	 *	with the values in 'payload' over i2c to the RTC.
+	 */
+	uint8_t		cmdBuff[1];
+	i2c_status_t	status;
+
+	if (deviceStartRegister > 0x2F)
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave = {
+		.address = deviceRV8803C7State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	cmdBuff[0] = deviceStartRegister;
+
+	warpScaleSupplyVoltage(deviceRV8803C7State.operatingVoltageMillivolts);
+	warpEnableI2Cpins();
+	status = I2C_DRV_MasterSendDataBlocking(0 /* I2C instance */,
+						&slave,
+						cmdBuff,
+						1,
+						payload,
+						nRegs,
+						gWarpI2cTimeoutMilliseconds);
+	warpDisableI2Cpins();
+
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
+
+uint8_t
+bin2bcd(uint8_t bin)
+{
+	/*
+	 *	Convert a int to bcd format
+	 */
+	uint8_t		r, d, bcd;
+	d = bin;
+	bcd = 0;
+
+	for (uint8_t n = 0; n<16; n+=4)
+	{
+		r = d % 10;
+		d /= 10;
+		bcd |= (r << n);
+	}
+	return bcd;
+}
+
+uint8_t
+date2weekday(uint8_t day, uint8_t month, uint8_t year)
+{
+	/*
+	 *	Returns day of week based on date
+	 *	TODO replace with more understandable expression
+	 */
+	uint8_t	weekday  = (day += month < 3 ? year-- : year - 2, 23*month/9 + day + 4 + year/4- year/100 + year/400)%7;
+	return	weekday;
+}
+
+WarpStatus
+setRTCTimeRV8803C7(rtc_datetime_t *tm)
+{
+	/*
+	 *	Set the time and date of the RV-8803-C7
+	 */
+	WarpStatus	ret;
+	uint8_t		ctrl, flags;
+
+
+	ret = readRTCRegisterRV8803C7(kWarpRV8803RegCtrl, &ctrl);
+
+	/*
+	 *	TODO: Is there special handling needed when ctrl < 0?
+	 */
+	if (ret | (ctrl < 0))
+	{
+		return ret;
+	}
+
+	/*
+	 *	Stop the clock
+	 */
+	ctrl |= kWarpRV8803CtrlRESET;
+	ret = writeRTCRegisterRV8803C7(kWarpRV8803RegCtrl, ctrl);
+	if (ret)
+	{
+		return ret;
+	}
+
+	/*
+	 *	Program the time and date
+	 */
+	uint8_t weekday = date2weekday(tm->day, tm->month, tm->year);
+	uint8_t date[7] = {
+				bin2bcd(tm->second),
+				bin2bcd(tm->minute),
+				bin2bcd(tm->hour),
+				1 << weekday,
+				bin2bcd(tm->day),
+				bin2bcd(tm->month + 1),
+				bin2bcd(tm->year - 100)
+	};
+
+	ret = writeRTCRegistersRV8803C7(kWarpRV8803RegSec, 7, date);
+	if (ret)
+	{
+		return ret;
+	}
+
+	/*
+	 *	Restart the clock
+	 */
+	ctrl &= kWarpRV8803CtrlRESET;
+	ret = writeRTCRegisterRV8803C7(kWarpRV8803RegCtrl, ctrl);
+	if (ret)
+	{
+		return ret;
+	}
+
+	ret = readRTCRegisterRV8803C7(kWarpRV8803RegFlag, &flags);
+
+	/*
+	 *	TODO: Is there special handling needed when flags < 0?
+	 */
+	if (ret | (flags < 0))
+	{
+		return ret;
+	}
+
+	flags &= ~(kWarpRV8803FlagV1F | kWarpRV8803FlagV2F);
+	ret = writeRTCRegisterRV8803C7(kWarpRV8803RegFlag, flags);
+
+
+	return ret;
+}
+
+WarpStatus
+setRTCCountdownRV8803C7(uint16_t countdown, WarpRV8803ExtTD clk_freq, bool interupt_enable)
+{
+	uint8_t		ext, flags, ctrl, ret;
+
+	/*
+	 *	Set the countdown timer and if it should cause the interupt pin of the RV8803 to activate
+	 */
+	if (countdown > 4095)
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	ret = readRTCRegisterRV8803C7(kWarpRV8803RegExt, &ext);
+	if (ret)
+	{
+		return ret;
+	}
+
+	ret = readRTCRegisterRV8803C7(kWarpRV8803RegFlag, &flags);
+	if (ret)
+	{
+		return ret;
+	}
+
+	ret = readRTCRegisterRV8803C7(kWarpRV8803RegCtrl, &ctrl);
+	if (ret)
+	{
+		return ret;
+	}
+
+	ext &= ~kWarpRV8803ExtTE;	/*	Stop countdown			*/
+	ext &= kWarpRV8803ExtClrTD;	/*	Clear the timer clock frequency	*/
+	ext |= clk_freq; 		/*	Set the timer clock frequency	*/
+
+	ret = writeRTCRegisterRV8803C7(kWarpRV8803RegExt, ext);
+	if (ret)
+	{
+		return ret;
+	}
+
+	flags &= ~kWarpRV8803FlagTF; /* clear the timer flag */
+	ret = writeRTCRegisterRV8803C7(kWarpRV8803RegFlag, flags);
+	if (ret)
+	{
+		return ret;
+	}
+
+	/*
+	 *	Set the number of counts before the timer is triggered
+	 */
+	uint8_t	MSByte = (countdown >> 8) & 0xFF;
+	ret = writeRTCRegisterRV8803C7(kWarpRV8803RegTimerCounter1, MSByte);
+	if (ret)
+	{
+		return ret;
+	}
+
+	uint8_t	LSByte = countdown & 0xFF;
+	ret = writeRTCRegisterRV8803C7(kWarpRV8803RegTimerCounter0, LSByte);
+	if (ret)
+	{
+		return ret;
+	}
+
+	/*
+	 *	Set the signal interrupt pin on countdown
+	 */
+	if (interupt_enable)
+	{
+		ctrl |= kWarpRV8803CtrlTIE;
+	}
+	else 
+	{
+		ctrl &= ~kWarpRV8803CtrlTIE;
+	}
+
+	ret = writeRTCRegisterRV8803C7(kWarpRV8803RegCtrl, ctrl);
+	if (ret)
+	{
+		return ret;
+	}
+
+	/*
+	 *	Start countdown again
+	 */
+	ext |= kWarpRV8803ExtTE;
+	ret = writeRTCRegisterRV8803C7(kWarpRV8803RegExt, ext);
+
+
+	return ret;
+}
diff --git a/src/boot/ksdk1.1.0/devRV8803C7.h b/src/boot/ksdk1.1.0/devRV8803C7.h
new file mode 100644
index 0000000..a68099b
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devRV8803C7.h
@@ -0,0 +1,129 @@
+/*
+	Authored 2019. Sam Willis. Additional contributions, 2019-onwards,
+	see git log.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+typedef enum
+{
+	kWarpRV8803ExtTD_4kHZ	= 0,
+	kWarpRV8803ExtTD_64HZ	= 1,
+	kWarpRV8803ExtTD_1HZ	= 2,
+	kWarpRV8803ExtTD_60S	= 3
+} WarpRV8803ExtTD;
+
+typedef enum
+{
+	kWarpRV8803ExtFD_32kHZ	= 0,
+	kWarpRV8803ExtFD_1kHZ	= 4,
+	kWarpRV8803ExtFD_1HZ	= 8
+} WarpRV8803ExtFD;
+
+typedef enum
+{
+	kWarpRV8803RegSec			= 0x00,
+	kWarpRV8803RegMin			= 0x01,
+	kWarpRV8803RegHour			= 0x02,
+	kWarpRV8803RegWeekday			= 0x03,
+	kWarpRV8803RegDate			= 0x04,
+	kWarpRV8803RegMonth			= 0x05,
+	kWarpRV8803RegYear			= 0x06,
+	kWarpRV8803RegRAM			= 0x07,
+	kWarpRV8803RegMinAlarm			= 0x08,
+	kWarpRV8803RegHourAlarm			= 0x09,
+	kWarpRV8803RegWeekdayOrDateAlarm	= 0x0A,
+	kWarpRV8803RegTimerCounter0		= 0x0B,
+	kWarpRV8803RegTimerCounter1		= 0x0C,
+	kWarpRV8803RegExt			= 0x0D,
+	kWarpRV8803RegFlag			= 0x0E,
+	kWarpRV8803RegCtrl			= 0x0F,
+} WarpRV8803Reg;
+
+#define BIT(n) (uint8_t)1U << n
+
+typedef enum
+{
+	kWarpRV8803ExtClrTD			= 0xFC,
+	kWarpRV8803ExtClrFD			= 0xF3,
+} WarpRV8803ExtClr;
+
+typedef enum
+{
+	kWarpRV8803ExtTE			= BIT(4),
+	kWarpRV8803ExtUSEL			= BIT(5),
+	kWarpRV8803ExtWADA			= BIT(6),
+	kWarpRV8803ExtTEST			= BIT(7),
+} WarpRV8803ExtFlag;
+
+typedef enum
+{
+	kWarpRV8803FlagV1F			= BIT(0),
+	kWarpRV8803FlagV2F			= BIT(1),
+	kWarpRV8803FlagEVF			= BIT(2),
+	kWarpRV8803FlagAF			= BIT(3),
+	kWarpRV8803FlagTF			= BIT(4),
+	kWarpRV8803FlagUF			= BIT(5),
+} WarpRV8803FlagFlag;
+
+typedef enum
+{
+	kWarpRV8803CtrlRESET			= BIT(0),
+	kWarpRV8803CtrlEIE			= BIT(2),
+	kWarpRV8803CtrlAIE			= BIT(3),
+	kWarpRV8803CtrlTIE			= BIT(4),
+	kWarpRV8803CtrlUIE			= BIT(5),
+} WarpRV8803CtrlFlag;
+
+void		initRV8803C7(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts);
+WarpStatus	readRTCRegisterRV8803C7(uint8_t deviceRegister, uint8_t *receiveData);
+WarpStatus	readRTCRegistersRV8803C7(uint8_t deviceRegister, uint8_t nRegs, uint8_t receiveData[]);
+WarpStatus	writeRTCRegisterRV8803C7(uint8_t deviceStartRegister, uint8_t payload);
+WarpStatus	writeRTCRegistersRV8803C7(uint8_t deviceStartRegister, uint8_t nRegs, uint8_t payload[]);
+WarpStatus	setRTCTimeRV8803C7(rtc_datetime_t *  tm);
+WarpStatus	setRTCCountdownRV8803C7(uint16_t countdown, WarpRV8803ExtTD clk_freq, bool interupt_enable);
+
+/*
+ *	TODO: Implement other functions:
+ *
+ *		handle_irq
+ *		gettime
+ *		time_update_irq_enable
+ *		set_countdown
+ *		get_countdown
+ *		countdown_irq_enable
+ *		getalarm
+ *		setalarm
+ *		larm_irq_enable
+ */
diff --git a/src/boot/ksdk1.1.0/devSI4705.c b/src/boot/ksdk1.1.0/devSI4705.c
new file mode 100644
index 0000000..c845df8
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devSI4705.c
@@ -0,0 +1,125 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+
+
+extern volatile WarpI2CDeviceState	deviceSI4705State;
+extern volatile uint32_t		gWarpI2cBaudRateKbps;
+extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
+extern volatile uint32_t		gWarpSupplySettlingDelayMilliseconds;
+
+
+
+void
+initSI4705(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceSI4705State.i2cAddress			= i2cAddress;
+	deviceSI4705State.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+readSensorRegisterSI4705(uint8_t deviceRegister, int numberOfBytes)
+{
+	uint8_t		cmdBuf[1] = {0xFF};
+	i2c_status_t	status;
+
+
+	USED(numberOfBytes);
+	i2c_device_t slave =
+	{
+		.address = deviceSI4705State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	/*
+	 *	TODO: for the SI4705, there aren't registers per se,
+	 *	but rather a suite of commands we can send and responses
+	 *	we can read. Turn this 'readSensorRegisterSI4705()'
+	 *	instead directly into a 'readSensorSignalSI4705()' routine.
+	 */
+	cmdBuf[0] = deviceRegister;
+
+	warpScaleSupplyVoltage(deviceSI4705State.operatingVoltageMillivolts);
+
+	/*
+	 *	Enable the SI4705: drive nRST high
+	 */
+	GPIO_DRV_SetPinOutput(kWarpPinSI4705_nRST);
+	warpEnableI2Cpins();
+
+	status = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							cmdBuf,
+							1,
+							(uint8_t *)deviceSI4705State.i2cBuffer,
+							numberOfBytes,
+							gWarpI2cTimeoutMilliseconds);
+
+	/*
+	 *	Disable the SI4705: drive nRST high
+	 */
+	GPIO_DRV_ClearPinOutput(kWarpPinSI4705_nRST);
+
+	if (status != kStatus_I2C_Success)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
diff --git a/src/boot/ksdk1.1.0/devSI4705.h b/src/boot/ksdk1.1.0/devSI4705.h
new file mode 100644
index 0000000..246df56
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devSI4705.h
@@ -0,0 +1,39 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+void		initSI4705(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts);
+WarpStatus	readSensorRegisterSI4705(uint8_t deviceRegister, int numberOfBytes);
diff --git a/src/boot/ksdk1.1.0/devSI7021.c b/src/boot/ksdk1.1.0/devSI7021.c
new file mode 100644
index 0000000..d8bd2d3
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devSI7021.c
@@ -0,0 +1,162 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+
+
+extern volatile WarpI2CDeviceState	deviceSI7021State;
+extern volatile uint32_t		gWarpI2cBaudRateKbps;
+extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
+extern volatile uint32_t		gWarpSupplySettlingDelayMilliseconds;
+
+
+
+void
+initSI7021(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceSI7021State.i2cAddress			= i2cAddress;
+	deviceSI7021State.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+readSensorRegisterSI7021(uint8_t deviceRegister, int numberOfBytes)
+{
+	uint8_t 	cmdBuf[2] = {0xFF, 0xFF};
+	i2c_status_t	status1, status2, status3, status4;
+
+
+	USED(numberOfBytes);
+
+	/*
+	 *	TODO: See SI7021 manual.
+	 *	1.	We should be passing in a 'command code' such as those in table 11
+	 *	2.	We first write command code, then read results
+	 *
+	 *	for now, just fix command code as 'read firmware version'
+	 */
+	
+	i2c_device_t slave =
+	{
+		.address = deviceSI7021State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	warpScaleSupplyVoltage(deviceSI7021State.operatingVoltageMillivolts);
+
+	/*
+	 *	TODO: for now, we fix command code as read first byte of serial number
+	 */
+	cmdBuf[0] = 0xFA;
+	cmdBuf[1] = 0x0F;
+	warpEnableI2Cpins();
+
+	status1 = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							NULL,
+							0,
+							cmdBuf,
+							2,//TODO: for now, we fix command code as two byte 'read firmware version' command
+							gWarpI2cTimeoutMilliseconds);
+
+
+	/*
+	 *	See SI7021 manual, page 20: two reads will be nacked before third succeeds.
+	 *	See similar thing in HDC1000 driver where we also send a NULL cmdBuf in
+	 *	I2C_DRV_MasterReceiveDataBlocking.
+	 */
+	status2 = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							NULL,
+							0,
+							(uint8_t *)deviceSI7021State.i2cBuffer,
+							numberOfBytes,
+							gWarpI2cTimeoutMilliseconds);
+
+	status3 = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							NULL,
+							0,
+							(uint8_t *)deviceSI7021State.i2cBuffer,
+							numberOfBytes,
+							gWarpI2cTimeoutMilliseconds);
+
+	/*
+	 *	Now, this two-byte read should succed according to page 20 of SI7021 manual:
+	 */
+	status4 = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							NULL,
+							0,
+							(uint8_t *)deviceSI7021State.i2cBuffer,
+							numberOfBytes,
+							gWarpI2cTimeoutMilliseconds);
+
+	if (	(status1 != kStatus_I2C_Success) ||
+		(status2 != kStatus_I2C_Success) ||
+		(status3 != kStatus_I2C_Success) ||
+		(status4 != kStatus_I2C_Success)
+		)
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
diff --git a/src/boot/ksdk1.1.0/devSI7021.h b/src/boot/ksdk1.1.0/devSI7021.h
new file mode 100644
index 0000000..1765ae5
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devSI7021.h
@@ -0,0 +1,39 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+void		initSI7021(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts);
+WarpStatus	readSensorRegisterSI7021(uint8_t deviceRegister, int numberOfBytes);
diff --git a/src/boot/ksdk1.1.0/devSSD1331.c b/src/boot/ksdk1.1.0/devSSD1331.c
index 9ad0f4c..7c4eb63 100644
--- a/src/boot/ksdk1.1.0/devSSD1331.c
+++ b/src/boot/ksdk1.1.0/devSSD1331.c
@@ -1,6 +1,4 @@
 #include <stdint.h>
-#include <math.h>
-#include <complex.h>
 
 /*
  *	config.h needs to come first
@@ -14,17 +12,10 @@
 #include "gpio_pins.h"
 #include "warp.h"
 #include "devSSD1331.h"
-#include "devADC.h"
-#include "fft.h"
-
-#define SPLASH_SCREEN 1
-
 
 volatile uint8_t	inBuffer[1];
 volatile uint8_t	payloadBytes[1];
-float stats[6][2];
-uint8_t nBins = 6;
-uint8_t bin_width;
+
 
 /*
  *	Override Warp firmware's use of these pins and define new aliases.
@@ -33,7 +24,7 @@ enum
 {
 	kSSD1331PinMOSI		= GPIO_MAKE_PIN(HW_GPIOA, 8),
 	kSSD1331PinSCK		= GPIO_MAKE_PIN(HW_GPIOA, 9),
-	kSSD1331PinCSn		= GPIO_MAKE_PIN(HW_GPIOB, 11),
+	kSSD1331PinCSn		= GPIO_MAKE_PIN(HW_GPIOB, 13),
 	kSSD1331PinDC		= GPIO_MAKE_PIN(HW_GPIOA, 12),
 	kSSD1331PinRST		= GPIO_MAKE_PIN(HW_GPIOB, 0),
 };
@@ -48,6 +39,8 @@ writeCommand(uint8_t commandByte)
 	 *
 	 *	Make sure there is a high-to-low transition by first driving high, delay, then drive low.
 	 */
+	GPIO_DRV_SetPinOutput(kSSD1331PinCSn);
+	OSA_TimeDelay(10);
 	GPIO_DRV_ClearPinOutput(kSSD1331PinCSn);
 
 	/*
@@ -71,6 +64,8 @@ writeCommand(uint8_t commandByte)
 	return status;
 }
 
+
+
 int
 devSSD1331init(void)
 {
@@ -82,14 +77,14 @@ devSSD1331init(void)
 	PORT_HAL_SetMuxMode(PORTA_BASE, 8u, kPortMuxAlt3);
 	PORT_HAL_SetMuxMode(PORTA_BASE, 9u, kPortMuxAlt3);
 
-	warpEnableSPIpins();
+	enableSPIpins();
 
 	/*
 	 *	Override Warp firmware's use of these pins.
 	 *
 	 *	Reconfigure to use as GPIO.
 	 */
-	PORT_HAL_SetMuxMode(PORTB_BASE, 11u, kPortMuxAsGpio);
+	PORT_HAL_SetMuxMode(PORTB_BASE, 13u, kPortMuxAsGpio);
 	PORT_HAL_SetMuxMode(PORTA_BASE, 12u, kPortMuxAsGpio);
 	PORT_HAL_SetMuxMode(PORTB_BASE, 0u, kPortMuxAsGpio);
 
@@ -161,165 +156,13 @@ devSSD1331init(void)
 	writeCommand(0x3F);
 
 
+
 	/*
 	 *	Any post-initialization drawing commands go here.
 	 */
-	bin_width = 0x5F / nBins;
-
-	#if SPLASH_SCREEN
-		// draw rectangle
-		writeCommand(kSSD1331CommandDRAWRECT);
+	//...
 
-		// set start and end row and column
-		writeCommand(0x00);
-		writeCommand(0x00);
-		writeCommand(0x5F); // col max
-		writeCommand(0x3F); // row max
 
-		// set outline colour
-		writeCommand(0x00);
-		writeCommand(0xFF);
-		writeCommand(0x00);
-
-		// set fill colour
-		writeCommand(0xFF);
-		writeCommand(0x00);
-		writeCommand(0x00);
-	#endif
 
 	return 0;
 }
-
-void chart_calibration(int *adc_readings, float complex *fft_output, float *frequency_powers){
-	// temporary array to store the two reads for each freq. bin
-	float tmp[2] = {0,0};
-
-	// take two readings for the each place so that we can run continously after this
-	// gives values to comapre against in the draw_frequency_chart function
-	for(uint8_t i = 0; i < nBins; i++){
-		ADC_read_set(0);
-		fft(adc_readings, fft_output, NUMBER_OF_STORED_READINGS);
-		process_powers(fft_output, frequency_powers);
-		tmp[0] = frequency_powers[i];
-
-		ADC_read_set(0);
-		fft(adc_readings, fft_output, NUMBER_OF_STORED_READINGS);
-		process_powers(fft_output, frequency_powers);
-		tmp[1] = frequency_powers[i];
-
-		stats[i][0] = min(tmp[0], tmp[1]); // min value for ith bin
-		stats[i][1] = max(tmp[0], tmp[1]); // max value for ith bin
-	}
-}
-
-void draw_frequency_bar(uint8_t start, uint8_t end, uint8_t height, uint8_t colour){
-
-	writeCommand(kSSD1331CommandDRAWRECT);
-	writeCommand(start); // start col
-	writeCommand(0x00); // start row
-	writeCommand(end); // end col
-	writeCommand(height); // end row
-
-	// set outline colour
-	writeCommand(0xFF);
-	writeCommand(0xFF);
-	writeCommand(0xFF);
-
-	// set fill colour - could pass in a struct containing all values, but
-	// would be memory intensive for all bars and we are close to stack limit.
-	// Sacrifice MCU cycles instead.
-	switch(colour){
-
-		// red
-		case RED:
-			writeCommand(0xFF);
-			writeCommand(0x00);
-			writeCommand(0x00);
-			break;
-
-		// green
-		case GREEN:
-			writeCommand(0x00);
-			writeCommand(0xFF);
-			writeCommand(0x00);
-			break;
-
-		// blue
-		case BLUE:
-			writeCommand(0x00);
-			writeCommand(0x00);
-			writeCommand(0xFF);
-			break;
-
-		// purple
-		case PURPLE:
-			writeCommand(0xA0);
-			writeCommand(0x20);
-			writeCommand(0xF0);
-			break;
-
-		// yellow
-		case YELLOW:
-			writeCommand(0xFF);
-			writeCommand(0xFF);
-			writeCommand(0x00);
-			break;
-
-		// orange
-		case ORANGE:
-			writeCommand(0xFF);
-			writeCommand(0xA5);
-			writeCommand(0x00);
-			break;
-	}
-	
-}
-
-void draw_frequency_chart(float *bar_heights){
-
-	// innit vars
-	uint8_t normalised_height, start, end;
-	
-	// clear screen before redrawing
-	writeCommand(kSSD1331CommandCLEAR);
-	writeCommand(0x00);
-	writeCommand(0x00);
-	writeCommand(0x5F);
-	writeCommand(0x3F);
-
-	// draw chart - loop through each bar that needs to be created
-	for(uint8_t i = 0; i < nBins; i++){
-
-		/*  check if new min / max found with decays - these stop
-			one erroneous large value from permenatly affecting the
-			scaling for a chart so that it looks small, with it
-			decaying to lower bounds if no other large values. */
-
-        if (bar_heights[i] > stats[i][1]){
-
-			// new max found - replace and upscale the minimum
-        	stats[i][1] = bar_heights[i];
-			stats[i][0] *= 1.1;
-		}
-		else if (bar_heights[i] < stats[i][0]){
-			// new min found - replace and downscale the max
-			stats[i][0] = bar_heights[i];
-			stats[i][1] *= 0.9;
-		}
-		else{
-			// value sits in middle - scales current bounds inwards
-			stats[i][0] *= 1.1;
-			stats[i][1] *= 0.8;
-		}
-
-		// scale bars to fit on display and have interesting dynamics
-		normalised_height = (bar_heights[i] - stats[i][0])/(stats[i][1]-stats[i][0])*(0x3F);
-
-		// calculate bar 'coordinates'
-		start = i * bin_width;
-		end = start + bin_width;
-
-		// call drawing routine
-		draw_frequency_bar(start, end, normalised_height, i);
-	}
- }
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devSSD1331.h b/src/boot/ksdk1.1.0/devSSD1331.h
index e5d12e6..0de5b34 100644
--- a/src/boot/ksdk1.1.0/devSSD1331.h
+++ b/src/boot/ksdk1.1.0/devSSD1331.h
@@ -2,10 +2,6 @@
  *	See https://github.com/adafruit/Adafruit-SSD1331-OLED-Driver-Library-for-Arduino for the Arduino driver.
  */
 
-int	devSSD1331init(void);
-void draw_frequency_chart(float *bar_heights);
-void draw_frequency_bar(uint8_t start, uint8_t end, uint8_t height, uint8_t colour);
-void chart_calibration(int *adc_readings, float complex *fft_output, float *frequency_powers);
 typedef enum
 {
 	kSSD1331ColororderRGB		= 1,
@@ -44,11 +40,6 @@ typedef enum
 	kSSD1331CommandPRECHARGEC	= 0x8C,
 	kSSD1331CommandPRECHARGELEVEL	= 0xBB,
 	kSSD1331CommandVCOMH		= 0xBE,
-	RED = 0,
-	GREEN = 1,
-	BLUE = 2,
-	PURPLE = 3,
-	YELLOW = 4,
-	ORANGE = 5
-	
 } SSD1331Commands;
+
+int	devSSD1331init(void);
diff --git a/src/boot/ksdk1.1.0/devTCS34725.c b/src/boot/ksdk1.1.0/devTCS34725.c
new file mode 100644
index 0000000..0b3b442
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devTCS34725.c
@@ -0,0 +1,129 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+
+/*
+ *	config.h needs to come first
+ */
+#include "config.h"
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+
+extern volatile WarpI2CDeviceState	deviceTCS34725State;
+extern volatile uint32_t		gWarpI2cBaudRateKbps;
+extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
+extern volatile uint32_t		gWarpSupplySettlingDelayMilliseconds;
+
+
+void
+initTCS34725(const uint8_t i2cAddress, uint16_t operatingVoltageMillivolts)
+{
+	deviceTCS34725State.i2cAddress			= i2cAddress;
+	deviceTCS34725State.operatingVoltageMillivolts	= operatingVoltageMillivolts;
+
+	return;
+}
+
+WarpStatus
+readSensorRegisterTCS34725(uint8_t deviceRegister)
+{
+	uint8_t		cmdBuf[1] = {0xFF};
+	i2c_status_t	status1, status2;
+
+	if (deviceRegister > 0x1D)
+	{
+		return kWarpStatusBadDeviceCommand;
+	}
+
+	i2c_device_t slave =
+	{
+		.address = deviceTCS34725State.i2cAddress,
+		.baudRate_kbps = gWarpI2cBaudRateKbps
+	};
+
+	cmdBuf[0] = deviceRegister;
+	warpScaleSupplyVoltage(deviceTCS34725State.operatingVoltageMillivolts);
+	warpEnableI2Cpins();
+
+	/*
+	 *	From manual, page 17 (bottom): First write to specify register address, then read.
+	 *
+	 *	See fields of COMMAND register on page 18. We write the bit pattern 1000 0000
+	 *	to specify that this is a command write for subsequent repeated byte protocol
+	 *	transactions (and special function flags in lower nybble ignored).
+	 */
+	cmdBuf[0] = 0x80;
+
+	status1 = I2C_DRV_MasterSendDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							cmdBuf,
+							1,
+							NULL,
+							0,
+							gWarpI2cTimeoutMilliseconds);
+
+	cmdBuf[0] = deviceRegister;
+	status2 = I2C_DRV_MasterReceiveDataBlocking(
+							0 /* I2C peripheral instance */,
+							&slave,
+							cmdBuf,
+							1,
+							(uint8_t *)deviceTCS34725State.i2cBuffer,
+							1,
+							gWarpI2cTimeoutMilliseconds);
+
+
+	if ((status1 != kStatus_I2C_Success) || (status2 != kStatus_I2C_Success))
+	{
+		return kWarpStatusDeviceCommunicationFailed;
+	}
+
+	return kWarpStatusOK;
+}
diff --git a/src/boot/ksdk1.1.0/devTCS34725.h b/src/boot/ksdk1.1.0/devTCS34725.h
new file mode 100644
index 0000000..c2eca3a
--- /dev/null
+++ b/src/boot/ksdk1.1.0/devTCS34725.h
@@ -0,0 +1,39 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+void		initTCS34725(const uint8_t i2cAddress, WarpI2CDeviceState volatile *  deviceStatePointer, uint16_t operatingVoltageMillivolts);
+WarpStatus	readSensorRegisterTCS34725(uint8_t deviceRegister, int numberOfBytes);
diff --git a/src/boot/ksdk1.1.0/fft.c b/src/boot/ksdk1.1.0/fft.c
deleted file mode 100644
index a40632d..0000000
--- a/src/boot/ksdk1.1.0/fft.c
+++ /dev/null
@@ -1,47 +0,0 @@
-/* Fast Fourier Transform
- * Cooley-Tukey algorithm with 2-radix DFT
- * Low memory embedded implementation from: https://github.com/brendanashworth/fft-small
- */
-
-#include <complex.h>
-#include <stdint.h>
-
-#include "devADC.h"
-
-#define PI 3.14159265358979323846
-
-void fft_radix2(int* x, float complex* X, unsigned int N, unsigned int s) {
-    unsigned int k;
-    double complex t;
-
-    // At the lowest level pass through (delta T=0 means no phase).
-    if (N == 1) {
-        X[0] = x[0];
-        return;
-    }
-
-    // Cooley-Tukey: recursively split in two, then combine beneath.
-    fft_radix2(x, X, N/2, 2*s);
-    fft_radix2(x+s, X + N/2, N/2, 2*s);
-
-    for (k = 0; k < N/2; k++) {
-        t = X[k];
-        X[k] = t + cexp(-2 * PI * I * k / N) * X[k + N/2];
-        X[k + N/2] = t - cexp(-2 * PI * I * k / N) * X[k + N/2];
-    }
-}
-
-void fft(int* x, float complex* X, unsigned int N) {
-    fft_radix2(x, X, N, 1);
-}
-
-/*
- * Takes magnitude of FFT complex returns to find 'quantity' of each
- * frequency bin. Added by myself for program needs.
- */
-void process_powers(float complex *fft_output, float *frequency_powers){
-    for(uint8_t i = 0; i < NUMBER_OF_FREQS - IGNORED_FREQS; i++){
-			
-		frequency_powers[i] = (creal(fft_output[i + SHUNT])*creal(fft_output[i + SHUNT]) + cimag(fft_output[i + SHUNT])*cimag(fft_output[i + SHUNT]));
-    }
-}
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/fft.h b/src/boot/ksdk1.1.0/fft.h
deleted file mode 100644
index 6760756..0000000
--- a/src/boot/ksdk1.1.0/fft.h
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Fast Fourier Transform
- * Cooley-Tukey algorithm with 2-radix DFT
- */
-
-#include <stdint.h>
-#include <complex.h>
-
-void fft_radix2(int* x, float complex* X, unsigned int N, unsigned int s);
-void fft(int* x, float complex* X, uint16_t N);
-void process_powers(float complex *fft_output, float *frequency_powers);
diff --git a/src/boot/ksdk1.1.0/glaux.h b/src/boot/ksdk1.1.0/glaux.h
new file mode 100644
index 0000000..64ccf16
--- /dev/null
+++ b/src/boot/ksdk1.1.0/glaux.h
@@ -0,0 +1,44 @@
+/*
+	Authored 2016-2021. Phillip Stanley-Marbell.
+	
+	Additional contributions, 2018: Jan Heck, Chatura Samarakoon, Youchao Wang, Sam Willis.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+
+typedef enum
+{
+	kGlauxSleepSecondsBetweenSensorRepetitions	=	3,
+	kGlauxSensorRepetitionsPerSleepIteration	=	1,
+} Glaux;
diff --git a/src/boot/ksdk1.1.0/warp-kl03-ksdk1.1-boot.c b/src/boot/ksdk1.1.0/warp-kl03-ksdk1.1-boot.c
new file mode 100755
index 0000000..01cff5f
--- /dev/null
+++ b/src/boot/ksdk1.1.0/warp-kl03-ksdk1.1-boot.c
@@ -0,0 +1,3676 @@
+/*
+	Authored 2016-2018. Phillip Stanley-Marbell.
+
+	Additional contributions, 2018 onwards: Jan Heck, Chatura Samarakoon, Youchao Wang, Sam Willis.
+
+	All rights reserved.
+
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions
+	are met:
+
+	*	Redistributions of source code must retain the above
+		copyright notice, this list of conditions and the following
+		disclaimer.
+
+	*	Redistributions in binary form must reproduce the above
+		copyright notice, this list of conditions and the following
+		disclaimer in the documentation and/or other materials
+		provided with the distribution.
+
+	*	Neither the name of the author nor the names of its
+		contributors may be used to endorse or promote products
+		derived from this software without specific prior written
+		permission.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+	POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "fsl_misc_utilities.h"
+#include "fsl_device_registers.h"
+#include "fsl_i2c_master_driver.h"
+#include "fsl_spi_master_driver.h"
+#include "fsl_rtc_driver.h"
+#include "fsl_clock_manager.h"
+#include "fsl_power_manager.h"
+#include "fsl_mcglite_hal.h"
+#include "fsl_port_hal.h"
+#include "fsl_lpuart_driver.h"
+
+#include "gpio_pins.h"
+#include "SEGGER_RTT.h"
+#include "warp.h"
+
+
+//#define WARP_FRDMKL03
+
+
+/*
+*	Comment out the header file to disable devices
+*/
+#ifndef WARP_FRDMKL03
+#	include "devBMX055.h"
+#	include "devMMA8451Q.h"
+#	include "devHDC1000.h"
+#	include "devMAG3110.h"
+#	include "devL3GD20H.h"
+#	include "devBME680.h"
+#	include "devCCS811.h"
+#	include "devAMG8834.h"
+//#	include "devMAX11300.h"
+//#include "devTCS34725.h"
+//#include "devSI4705.h"
+//#include "devSI7021.h"
+//#include "devLPS25H.h"
+//#include "devADXL362.h"
+//#include "devPAN1326.h"
+//#include "devAS7262.h"
+//#include "devAS7263.h"
+//#include "devRV8803C7.h"
+//#include "devISL23415.h"
+#else
+#	include "devMMA8451Q.h"
+#endif
+
+
+#define WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+//#define WARP_BUILD_BOOT_TO_CSVSTREAM
+
+
+/*
+*	BTstack includes WIP
+*/
+// #include "btstack_main.h"
+
+
+#define						kWarpConstantStringI2cFailure		"\rI2C failed, reg 0x%02x, code %d\n"
+#define						kWarpConstantStringErrorInvalidVoltage	"\rInvalid supply voltage [%d] mV!"
+#define						kWarpConstantStringErrorSanity		"\rSanity check failed!"
+
+
+#ifdef WARP_BUILD_ENABLE_DEVADXL362
+volatile WarpSPIDeviceState			deviceADXL362State;
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVISL23415
+volatile WarpSPIDeviceState			deviceISL23415State;
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVBMX055
+volatile WarpI2CDeviceState			deviceBMX055accelState;
+volatile WarpI2CDeviceState			deviceBMX055gyroState;
+volatile WarpI2CDeviceState			deviceBMX055magState;
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVMMA8451Q
+volatile WarpI2CDeviceState			deviceMMA8451QState;
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVLPS25H
+volatile WarpI2CDeviceState			deviceLPS25HState;
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVHDC1000
+volatile WarpI2CDeviceState			deviceHDC1000State;
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVMAG3110
+volatile WarpI2CDeviceState			deviceMAG3110State;
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVSI7021
+volatile WarpI2CDeviceState			deviceSI7021State;
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVL3GD20H
+volatile WarpI2CDeviceState			deviceL3GD20HState;
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVBME680
+volatile WarpI2CDeviceState			deviceBME680State;
+volatile uint8_t				deviceBME680CalibrationValues[kWarpSizesBME680CalibrationValuesCount];
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVTCS34725
+volatile WarpI2CDeviceState			deviceTCS34725State;
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVSI4705
+volatile WarpI2CDeviceState			deviceSI4705State;
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVCCS811
+volatile WarpI2CDeviceState			deviceCCS811State;
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVAMG8834
+volatile WarpI2CDeviceState			deviceAMG8834State;
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVPAN1326
+volatile WarpUARTDeviceState			devicePAN1326BState;
+volatile WarpUARTDeviceState			devicePAN1323ETUState;
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVAS7262
+volatile WarpI2CDeviceState			deviceAS7262State;
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVAS7263
+volatile WarpI2CDeviceState			deviceAS7263State;
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVRV8803C7
+volatile WarpI2CDeviceState			deviceRV8803C7State;
+#endif
+
+/*
+ *	TODO: move this and possibly others into a global structure
+ */
+volatile i2c_master_state_t			i2cMasterState;
+volatile spi_master_state_t			spiMasterState;
+volatile spi_master_user_config_t		spiUserConfig;
+volatile lpuart_user_config_t 			lpuartUserConfig;
+volatile lpuart_state_t 			lpuartState;
+
+/*
+ *	TODO: move magic default numbers into constant definitions.
+ */
+volatile uint32_t			gWarpI2cBaudRateKbps		= 200;
+volatile uint32_t			gWarpUartBaudRateKbps		= 1;
+volatile uint32_t			gWarpSpiBaudRateKbps		= 200;
+volatile uint32_t			gWarpSleeptimeSeconds		= 0;
+volatile WarpModeMask			gWarpMode			= kWarpModeDisableAdcOnSleep;
+volatile uint32_t			gWarpI2cTimeoutMilliseconds	= 5;
+volatile uint32_t			gWarpSpiTimeoutMicroseconds	= 5;
+volatile uint32_t			gWarpMenuPrintDelayMilliseconds	= 10;
+volatile uint32_t			gWarpSupplySettlingDelayMilliseconds = 1;
+
+void					sleepUntilReset(void);
+void					lowPowerPinStates(void);
+void					disableTPS82740A(void);
+void					disableTPS82740B(void);
+void					enableTPS82740A(uint16_t voltageMillivolts);
+void					enableTPS82740B(uint16_t voltageMillivolts);
+void					setTPS82740CommonControlLines(uint16_t voltageMillivolts);
+void					printPinDirections(void);
+void					dumpProcessorState(void);
+void					repeatRegisterReadForDeviceAndAddress(WarpSensorDevice warpSensorDevice, uint8_t baseAddress, 
+								uint8_t pullupValue, bool autoIncrement, int chunkReadsPerAddress, bool chatty,
+								int spinDelay, int repetitionsPerAddress, uint16_t sssupplyMillivolts,
+								uint16_t adaptiveSssupplyMaxMillivolts, uint8_t referenceByte);
+int					char2int(int character);
+void					enableSssupply(uint16_t voltageMillivolts);
+void					disableSssupply(void);
+void					activateAllLowPowerSensorModes(bool verbose);
+void					powerupAllSensors(void);
+uint8_t					readHexByte(void);
+int					read4digits(void);
+void					printAllSensors(bool printHeadersAndCalibration, bool hexModeFlag, int menuDelayBetweenEachRun, int i2cPullupValue);
+
+
+/*
+ *	TODO: change the following to take byte arrays
+ */
+WarpStatus				writeByteToI2cDeviceRegister(uint8_t i2cAddress, bool sendCommandByte, uint8_t commandByte, bool sendPayloadByte, uint8_t payloadByte);
+WarpStatus				writeBytesToSpi(uint8_t *  payloadBytes, int payloadLength);
+
+
+void					warpLowPowerSecondsSleep(uint32_t sleepSeconds, bool forceAllPinsIntoLowPowerState);
+
+
+
+/*
+ *	From KSDK power_manager_demo.c <<BEGIN>>>
+ */
+
+clock_manager_error_code_t clockManagerCallbackRoutine(clock_notify_struct_t *  notify, void *  callbackData);
+
+/*
+ *	static clock callback table.
+ */
+clock_manager_callback_user_config_t		clockManagerCallbackUserlevelStructure =
+									{
+										.callback	= clockManagerCallbackRoutine,
+										.callbackType	= kClockManagerCallbackBeforeAfter,
+										.callbackData	= NULL
+									};
+
+static clock_manager_callback_user_config_t *	clockCallbackTable[] =
+									{
+										&clockManagerCallbackUserlevelStructure
+									};
+
+clock_manager_error_code_t
+clockManagerCallbackRoutine(clock_notify_struct_t *  notify, void *  callbackData)
+{
+	clock_manager_error_code_t result = kClockManagerSuccess;
+
+	switch (notify->notifyType)
+	{
+		case kClockManagerNotifyBefore:
+			break;
+		case kClockManagerNotifyRecover:
+		case kClockManagerNotifyAfter:
+			break;
+		default:
+			result = kClockManagerError;
+		break;
+	}
+
+	return result;
+}
+
+
+/*
+ *	Override the RTC IRQ handler
+ */
+void
+RTC_IRQHandler(void)
+{
+	if (RTC_DRV_IsAlarmPending(0))
+	{
+		RTC_DRV_SetAlarmIntCmd(0, false);
+	}
+}
+
+/*
+ *	Override the RTC Second IRQ handler
+ */
+void
+RTC_Seconds_IRQHandler(void)
+{
+	gWarpSleeptimeSeconds++;
+}
+
+/*
+ *	Power manager user callback
+ */
+power_manager_error_code_t callback0(power_manager_notify_struct_t *  notify,
+					power_manager_callback_data_t *  dataPtr)
+{
+	WarpPowerManagerCallbackStructure *		callbackUserData = (WarpPowerManagerCallbackStructure *) dataPtr;
+	power_manager_error_code_t			status = kPowerManagerError;
+
+	switch (notify->notifyType)
+	{
+		case kPowerManagerNotifyBefore:
+			status = kPowerManagerSuccess;
+			break;
+		case kPowerManagerNotifyAfter:
+			status = kPowerManagerSuccess;
+			break;
+		default:
+			callbackUserData->errorCount++;
+			break;
+	}
+
+	return status;
+}
+
+/*
+ *	From KSDK power_manager_demo.c <<END>>>
+ */
+
+
+
+void
+sleepUntilReset(void)
+{
+	while (1)
+	{
+#ifdef WARP_BUILD_ENABLE_DEVSI4705
+		GPIO_DRV_SetPinOutput(kWarpPinSI4705_nRST);
+#endif
+		warpLowPowerSecondsSleep(1, false /* forceAllPinsIntoLowPowerState */);
+#ifdef WARP_BUILD_ENABLE_DEVSI4705
+		GPIO_DRV_ClearPinOutput(kWarpPinSI4705_nRST);
+#endif
+		warpLowPowerSecondsSleep(60, true /* forceAllPinsIntoLowPowerState */);
+	}
+}
+
+
+void
+enableLPUARTpins(void)
+{
+	/*	Enable UART CLOCK */
+	CLOCK_SYS_EnableLpuartClock(0);
+
+	/*
+	*	set UART pin association
+	*	see page 99 in https://www.nxp.com/docs/en/reference-manual/KL03P24M48SF0RM.pdf
+	*/
+
+#ifdef WARP_BUILD_ENABLE_DEVPAN1326
+	/*	Warp KL03_UART_HCI_TX	--> PTB3 (ALT3)	--> PAN1326 HCI_RX */
+	PORT_HAL_SetMuxMode(PORTB_BASE, 3, kPortMuxAlt3);
+	/*	Warp KL03_UART_HCI_RX	--> PTB4 (ALT3)	--> PAN1326 HCI_RX */
+	PORT_HAL_SetMuxMode(PORTB_BASE, 4, kPortMuxAlt3);
+
+	/* TODO: Partial Implementation */
+	/*	Warp PTA6 --> PAN1326 HCI_RTS */
+	/*	Warp PTA7 --> PAN1326 HCI_CTS */
+#endif
+
+	/*
+	 *	Initialize LPUART0. See KSDK13APIRM.pdf section 40.4.3, page 1353
+	 *
+	 */
+	lpuartUserConfig.baudRate = 115;
+	lpuartUserConfig.parityMode = kLpuartParityDisabled;
+	lpuartUserConfig.stopBitCount = kLpuartOneStopBit;
+	lpuartUserConfig.bitCountPerChar = kLpuart8BitsPerChar;
+
+	LPUART_DRV_Init(0,(lpuart_state_t *)&lpuartState,(lpuart_user_config_t *)&lpuartUserConfig);
+
+}
+
+
+void
+disableLPUARTpins(void)
+{
+	/*
+	 *	LPUART deinit
+	 */
+	LPUART_DRV_Deinit(0);
+
+	/*	Warp KL03_UART_HCI_RX	--> PTB4 (GPIO)	*/
+	PORT_HAL_SetMuxMode(PORTB_BASE, 4, kPortMuxAsGpio);
+	/*	Warp KL03_UART_HCI_TX	--> PTB3 (GPIO) */
+	PORT_HAL_SetMuxMode(PORTB_BASE, 3, kPortMuxAsGpio);
+
+#ifdef WARP_BUILD_ENABLE_DEVPAN1326
+	GPIO_DRV_ClearPinOutput(kWarpPinPAN1326_HCI_CTS);
+	GPIO_DRV_ClearPinOutput(kWarpPinPAN1326_HCI_CTS);
+#endif
+
+	GPIO_DRV_ClearPinOutput(kWarpPinLPUART_HCI_TX);
+	GPIO_DRV_ClearPinOutput(kWarpPinLPUART_HCI_RX);
+
+	/* Disable LPUART CLOCK */
+	CLOCK_SYS_DisableLpuartClock(0);
+
+}
+
+void
+enableSPIpins(void)
+{
+	CLOCK_SYS_EnableSpiClock(0);
+
+	/*	Warp KL03_SPI_MISO	--> PTA6	(ALT3)		*/
+	PORT_HAL_SetMuxMode(PORTA_BASE, 6, kPortMuxAlt3);
+
+	/*	Warp KL03_SPI_MOSI	--> PTA7	(ALT3)		*/
+	PORT_HAL_SetMuxMode(PORTA_BASE, 7, kPortMuxAlt3);
+
+	/*	Warp KL03_SPI_SCK	--> PTB0	(ALT3)		*/
+	PORT_HAL_SetMuxMode(PORTB_BASE, 0, kPortMuxAlt3);
+
+
+	/*
+	 *	Initialize SPI master. See KSDK13APIRM.pdf Section 70.4
+	 *
+	 */
+	uint32_t			calculatedBaudRate;
+	spiUserConfig.polarity		= kSpiClockPolarity_ActiveHigh;
+	spiUserConfig.phase		= kSpiClockPhase_FirstEdge;
+	spiUserConfig.direction		= kSpiMsbFirst;
+	spiUserConfig.bitsPerSec	= gWarpSpiBaudRateKbps * 1000;
+	SPI_DRV_MasterInit(0 /* SPI master instance */, (spi_master_state_t *)&spiMasterState);
+	SPI_DRV_MasterConfigureBus(0 /* SPI master instance */, (spi_master_user_config_t *)&spiUserConfig, &calculatedBaudRate);
+}
+
+
+
+void
+disableSPIpins(void)
+{
+	SPI_DRV_MasterDeinit(0);
+
+
+	/*	Warp KL03_SPI_MISO	--> PTA6	(GPI)		*/
+	PORT_HAL_SetMuxMode(PORTA_BASE, 6, kPortMuxAsGpio);
+
+	/*	Warp KL03_SPI_MOSI	--> PTA7	(GPIO)		*/
+	PORT_HAL_SetMuxMode(PORTA_BASE, 7, kPortMuxAsGpio);
+
+	/*	Warp KL03_SPI_SCK	--> PTB0	(GPIO)		*/
+	PORT_HAL_SetMuxMode(PORTB_BASE, 0, kPortMuxAsGpio);
+
+	GPIO_DRV_ClearPinOutput(kWarpPinSPI_MOSI);
+	GPIO_DRV_ClearPinOutput(kWarpPinSPI_MISO);
+	GPIO_DRV_ClearPinOutput(kWarpPinSPI_SCK);
+
+
+	CLOCK_SYS_DisableSpiClock(0);
+}
+
+void
+configureI2Cpins(uint8_t pullupValue)
+{
+#ifdef WARP_BUILD_ENABLE_DEVISL23415
+	/*
+	 *	Configure the two ISL23415 DCPs over SPI
+	 */
+	uint8_t valuesDCP[2] = {pullupValue, pullupValue};
+	writeDeviceRegisterISL23415(kWarpISL23415RegWR, valuesDCP, 4);
+#endif
+}
+
+void
+enableI2Cpins(uint8_t pullupValue)
+{
+	CLOCK_SYS_EnableI2cClock(0);
+
+	/*	Warp KL03_I2C0_SCL	--> PTB3	(ALT2 == I2C)		*/
+	PORT_HAL_SetMuxMode(PORTB_BASE, 3, kPortMuxAlt2);
+
+	/*	Warp KL03_I2C0_SDA	--> PTB4	(ALT2 == I2C)		*/
+	PORT_HAL_SetMuxMode(PORTB_BASE, 4, kPortMuxAlt2);
+
+
+	I2C_DRV_MasterInit(0 /* I2C instance */, (i2c_master_state_t *)&i2cMasterState);
+
+	configureI2Cpins(pullupValue);
+}
+
+
+
+void
+disableI2Cpins(void)
+{
+	I2C_DRV_MasterDeinit(0 /* I2C instance */);
+
+
+	/*	Warp KL03_I2C0_SCL	--> PTB3	(GPIO)			*/
+	PORT_HAL_SetMuxMode(PORTB_BASE, 3, kPortMuxAsGpio);
+
+	/*	Warp KL03_I2C0_SDA	--> PTB4	(GPIO)			*/
+	PORT_HAL_SetMuxMode(PORTB_BASE, 4, kPortMuxAsGpio);
+
+
+	/*
+	 *	Reset DCP configuration
+	 */
+	configureI2Cpins(0x80); /* Defaults DCP configuration ISL datasheet FN7780 Rev 2.00 - page 14 */
+
+	/*
+	 *	Drive the I2C pins low
+	 */
+	GPIO_DRV_ClearPinOutput(kWarpPinI2C0_SDA);
+	GPIO_DRV_ClearPinOutput(kWarpPinI2C0_SCL);
+
+
+	CLOCK_SYS_DisableI2cClock(0);
+}
+
+
+// TODO: add pin states for pan1326 lp states
+void
+lowPowerPinStates(void)
+{
+	/*
+	 *	Following Section 5 of "Power Management for Kinetis L Family" (AN5088.pdf),
+	 *	we configure all pins as output and set them to a known state. We choose
+	 *	to set them all to '0' since it happens that the devices we want to keep
+	 *	deactivated (SI4705, PAN1326) also need '0'.
+	 */
+
+	/*
+	 *			PORT A
+	 */
+	/*
+	 *	For now, don't touch the PTA0/1/2 SWD pins. Revisit in the future.
+	 */
+	/*
+	PORT_HAL_SetMuxMode(PORTA_BASE, 0, kPortMuxAsGpio);
+	PORT_HAL_SetMuxMode(PORTA_BASE, 1, kPortMuxAsGpio);
+	PORT_HAL_SetMuxMode(PORTA_BASE, 2, kPortMuxAsGpio);
+	*/
+
+	/*
+	 *	PTA3 and PTA4 are the EXTAL/XTAL
+	 */
+	PORT_HAL_SetMuxMode(PORTA_BASE, 3, kPortPinDisabled);
+	PORT_HAL_SetMuxMode(PORTA_BASE, 4, kPortPinDisabled);
+
+	PORT_HAL_SetMuxMode(PORTA_BASE, 5, kPortMuxAsGpio);
+	PORT_HAL_SetMuxMode(PORTA_BASE, 6, kPortMuxAsGpio);
+	PORT_HAL_SetMuxMode(PORTA_BASE, 7, kPortMuxAsGpio);
+	PORT_HAL_SetMuxMode(PORTA_BASE, 8, kPortMuxAsGpio);
+	PORT_HAL_SetMuxMode(PORTA_BASE, 9, kPortMuxAsGpio);
+
+	/*
+	 *	NOTE: The KL03 has no PTA10 or PTA11
+	 */
+
+	PORT_HAL_SetMuxMode(PORTA_BASE, 12, kPortMuxAsGpio);
+
+
+
+	/*
+	 *			PORT B
+	 */
+	PORT_HAL_SetMuxMode(PORTB_BASE, 0, kPortMuxAsGpio);
+
+	/*
+	 *	PTB1 is connected to KL03_VDD. We have a choice of:
+	 *		(1) Keep 'disabled as analog'.
+	 *		(2) Set as output and drive high.
+	 *
+	 *	Pin state "disabled" means default functionality (ADC) is _active_
+	 */
+	if (gWarpMode & kWarpModeDisableAdcOnSleep)
+	{
+		PORT_HAL_SetMuxMode(PORTB_BASE, 1, kPortMuxAsGpio);
+	}
+	else
+	{
+		PORT_HAL_SetMuxMode(PORTB_BASE, 1, kPortPinDisabled);
+	}
+
+	PORT_HAL_SetMuxMode(PORTB_BASE, 2, kPortMuxAsGpio);
+
+	/*
+	 *	PTB3 and PTB3 (I2C pins) are true open-drain
+	 *	and we purposefully leave them disabled.
+	 */
+	PORT_HAL_SetMuxMode(PORTB_BASE, 3, kPortPinDisabled);
+	PORT_HAL_SetMuxMode(PORTB_BASE, 4, kPortPinDisabled);
+
+
+	PORT_HAL_SetMuxMode(PORTB_BASE, 5, kPortMuxAsGpio);
+	PORT_HAL_SetMuxMode(PORTB_BASE, 6, kPortMuxAsGpio);
+	PORT_HAL_SetMuxMode(PORTB_BASE, 7, kPortMuxAsGpio);
+
+	/*
+	 *	NOTE: The KL03 has no PTB8 or PTB9
+	 */
+
+	PORT_HAL_SetMuxMode(PORTB_BASE, 10, kPortMuxAsGpio);
+	PORT_HAL_SetMuxMode(PORTB_BASE, 11, kPortMuxAsGpio);
+
+	/*
+	 *	NOTE: The KL03 has no PTB12
+	 */
+
+	PORT_HAL_SetMuxMode(PORTB_BASE, 13, kPortMuxAsGpio);
+
+
+
+	/*
+	 *	Now, set all the pins (except kWarpPinKL03_VDD_ADC, the SWD pins, and the XTAL/EXTAL) to 0
+	 */
+
+
+
+	/*
+	 *	If we are in mode where we disable the ADC, then drive the pin high since it is tied to KL03_VDD
+	 */
+	if (gWarpMode & kWarpModeDisableAdcOnSleep)
+	{
+		GPIO_DRV_SetPinOutput(kWarpPinKL03_VDD_ADC);
+	}
+#ifndef WARP_BUILD_ENABLE_THERMALCHAMBERANALYSIS
+#ifdef WARP_BUILD_ENABLE_DEVPAN1326
+	GPIO_DRV_ClearPinOutput(kWarpPinPAN1326_nSHUTD);
+#endif
+#endif
+
+	GPIO_DRV_ClearPinOutput(kWarpPinTPS82740A_CTLEN);
+	GPIO_DRV_ClearPinOutput(kWarpPinTPS82740B_CTLEN);
+	GPIO_DRV_ClearPinOutput(kWarpPinTPS82740_VSEL1);
+	GPIO_DRV_ClearPinOutput(kWarpPinTPS82740_VSEL2);
+	GPIO_DRV_ClearPinOutput(kWarpPinTPS82740_VSEL3);
+
+#ifndef WARP_BUILD_ENABLE_THERMALCHAMBERANALYSIS
+	GPIO_DRV_ClearPinOutput(kWarpPinCLKOUT32K);
+#endif
+
+	GPIO_DRV_ClearPinOutput(kWarpPinTS5A3154_IN);
+	GPIO_DRV_ClearPinOutput(kWarpPinSI4705_nRST);
+
+	/*
+	 *	Drive these chip selects high since they are active low:
+	 */
+#ifndef WARP_BUILD_ENABLE_THERMALCHAMBERANALYSIS
+	GPIO_DRV_SetPinOutput(kWarpPinISL23415_nCS);
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVADXL362
+	GPIO_DRV_SetPinOutput(kWarpPinADXL362_CS);
+#endif
+
+	/*
+	 *	When the PAN1326 is installed, note that it has the
+	 *	following pull-up/down by default:
+	 *
+	 *		HCI_RX / kWarpPinI2C0_SCL	: pull up
+	 *		HCI_TX / kWarpPinI2C0_SDA	: pull up
+	 *		HCI_RTS / kWarpPinSPI_MISO	: pull up
+	 *		HCI_CTS / kWarpPinSPI_MOSI	: pull up
+	 *
+	 *	These I/Os are 8mA (see panasonic_PAN13xx.pdf, page 10),
+	 *	so we really don't want to be driving them low. We
+	 *	however also have to be careful of the I2C pullup and
+	 *	pull-up gating. However, driving them high leads to
+	 *	higher board power dissipation even when SSSUPPLY is off
+	 *	by ~80mW on board #003 (PAN1326 populated).
+	 *
+	 *	In revB board, with the ISL23415 DCP pullups, we also
+	 *	want I2C_SCL and I2C_SDA driven high since when we
+	 *	send a shutdown command to the DCP it will connect
+	 *	those lines to 25570_VOUT.
+	 *
+	 *	For now, we therefore leave the SPI pins low and the
+	 *	I2C pins (PTB3, PTB4, which are true open-drain) disabled.
+	 */
+
+	GPIO_DRV_ClearPinOutput(kWarpPinI2C0_SDA);
+	GPIO_DRV_ClearPinOutput(kWarpPinI2C0_SCL);
+	GPIO_DRV_ClearPinOutput(kWarpPinSPI_MOSI);
+	GPIO_DRV_ClearPinOutput(kWarpPinSPI_MISO);
+	GPIO_DRV_ClearPinOutput(kWarpPinSPI_SCK);
+
+	/*
+	 *	HCI_RX / kWarpPinI2C0_SCL is an input. Set it low.
+	 */
+	//GPIO_DRV_SetPinOutput(kWarpPinI2C0_SCL);
+
+	/*
+	 *	HCI_TX / kWarpPinI2C0_SDA is an output. Set it high.
+	 */
+	//GPIO_DRV_SetPinOutput(kWarpPinI2C0_SDA);
+
+	/*
+	 *	HCI_RTS / kWarpPinSPI_MISO is an output. Set it high.
+	 */
+	//GPIO_DRV_SetPinOutput(kWarpPinSPI_MISO);
+
+	/*
+	 *	From PAN1326 manual, page 10:
+	 *
+	 *		"When HCI_CTS is high, then CC256X is not allowed to send data to Host device"
+	 */
+	//GPIO_DRV_SetPinOutput(kWarpPinSPI_MOSI);
+}
+
+
+
+void
+disableTPS82740A(void)
+{
+	GPIO_DRV_ClearPinOutput(kWarpPinTPS82740A_CTLEN);
+}
+
+void
+disableTPS82740B(void)
+{
+	GPIO_DRV_ClearPinOutput(kWarpPinTPS82740B_CTLEN);
+}
+
+
+void
+enableTPS82740A(uint16_t voltageMillivolts)
+{
+	setTPS82740CommonControlLines(voltageMillivolts);
+	GPIO_DRV_SetPinOutput(kWarpPinTPS82740A_CTLEN);
+	GPIO_DRV_ClearPinOutput(kWarpPinTPS82740B_CTLEN);
+
+	/*
+	 *	Select the TS5A3154 to use the output of the TPS82740
+	 *
+	 *		IN = high selects the output of the TPS82740B:
+	 *		IN = low selects the output of the TPS82740A:
+	 */
+	GPIO_DRV_ClearPinOutput(kWarpPinTS5A3154_IN);
+}
+
+
+void
+enableTPS82740B(uint16_t voltageMillivolts)
+{
+	setTPS82740CommonControlLines(voltageMillivolts);
+	GPIO_DRV_ClearPinOutput(kWarpPinTPS82740A_CTLEN);
+	GPIO_DRV_SetPinOutput(kWarpPinTPS82740B_CTLEN);
+
+	/*
+	 *	Select the TS5A3154 to use the output of the TPS82740
+	 *
+	 *		IN = high selects the output of the TPS82740B:
+	 *		IN = low selects the output of the TPS82740A:
+	 */
+	GPIO_DRV_SetPinOutput(kWarpPinTS5A3154_IN);
+}
+
+
+void
+setTPS82740CommonControlLines(uint16_t voltageMillivolts)
+{
+	/*
+	 *	 From Manual:
+	 *
+	 *		TPS82740A:	VSEL1 VSEL2 VSEL3:	000-->1.8V, 111-->2.5V
+	 *		TPS82740B:	VSEL1 VSEL2 VSEL3:	000-->2.6V, 111-->3.3V
+	 */
+
+	switch(voltageMillivolts)
+	{
+		case 2600:
+		case 1800:
+		{
+			GPIO_DRV_ClearPinOutput(kWarpPinTPS82740_VSEL1);
+			GPIO_DRV_ClearPinOutput(kWarpPinTPS82740_VSEL2);
+			GPIO_DRV_ClearPinOutput(kWarpPinTPS82740_VSEL3);
+
+			break;
+		}
+
+		case 2700:
+		case 1900:
+		{
+			GPIO_DRV_SetPinOutput(kWarpPinTPS82740_VSEL1);
+			GPIO_DRV_ClearPinOutput(kWarpPinTPS82740_VSEL2);
+			GPIO_DRV_ClearPinOutput(kWarpPinTPS82740_VSEL3);
+
+			break;
+		}
+
+		case 2800:
+		case 2000:
+		{
+			GPIO_DRV_ClearPinOutput(kWarpPinTPS82740_VSEL1);
+			GPIO_DRV_SetPinOutput(kWarpPinTPS82740_VSEL2);
+			GPIO_DRV_ClearPinOutput(kWarpPinTPS82740_VSEL3);
+
+			break;
+		}
+
+		case 2900:
+		case 2100:
+		{
+			GPIO_DRV_SetPinOutput(kWarpPinTPS82740_VSEL1);
+			GPIO_DRV_SetPinOutput(kWarpPinTPS82740_VSEL2);
+			GPIO_DRV_ClearPinOutput(kWarpPinTPS82740_VSEL3);
+
+			break;
+		}
+
+		case 3000:
+		case 2200:
+		{
+			GPIO_DRV_ClearPinOutput(kWarpPinTPS82740_VSEL1);
+			GPIO_DRV_ClearPinOutput(kWarpPinTPS82740_VSEL2);
+			GPIO_DRV_SetPinOutput(kWarpPinTPS82740_VSEL3);
+
+			break;
+		}
+
+		case 3100:
+		case 2300:
+		{
+			GPIO_DRV_SetPinOutput(kWarpPinTPS82740_VSEL1);
+			GPIO_DRV_ClearPinOutput(kWarpPinTPS82740_VSEL2);
+			GPIO_DRV_SetPinOutput(kWarpPinTPS82740_VSEL3);
+
+			break;
+		}
+
+		case 3200:
+		case 2400:
+		{
+			GPIO_DRV_ClearPinOutput(kWarpPinTPS82740_VSEL1);
+			GPIO_DRV_SetPinOutput(kWarpPinTPS82740_VSEL2);
+			GPIO_DRV_SetPinOutput(kWarpPinTPS82740_VSEL3);
+
+			break;
+		}
+
+		case 3300:
+		case 2500:
+		{
+			GPIO_DRV_SetPinOutput(kWarpPinTPS82740_VSEL1);
+			GPIO_DRV_SetPinOutput(kWarpPinTPS82740_VSEL2);
+			GPIO_DRV_SetPinOutput(kWarpPinTPS82740_VSEL3);
+
+			break;
+		}
+
+		/*
+		 *	Should never happen, due to previous check in enableSssupply()
+		 */
+		default:
+		{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+			SEGGER_RTT_printf(0, RTT_CTRL_RESET RTT_CTRL_BG_BRIGHT_YELLOW RTT_CTRL_TEXT_BRIGHT_WHITE kWarpConstantStringErrorSanity RTT_CTRL_RESET "\n");
+#endif
+		}
+	}
+
+	/*
+	 *	Vload ramp time of the TPS82740 is 800us max (datasheet, Section 8.5 / page 5)
+	 */
+	OSA_TimeDelay(gWarpSupplySettlingDelayMilliseconds);
+}
+
+void
+enableSssupply(uint16_t voltageMillivolts)
+{
+	if (voltageMillivolts >= 1800 && voltageMillivolts <= 2500)
+	{
+		enableTPS82740A(voltageMillivolts);
+	}
+	else if (voltageMillivolts >= 2600 && voltageMillivolts <= 3300)
+	{
+		enableTPS82740B(voltageMillivolts);
+	}
+	else
+	{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+		SEGGER_RTT_printf(0, RTT_CTRL_RESET RTT_CTRL_BG_BRIGHT_RED RTT_CTRL_TEXT_BRIGHT_WHITE kWarpConstantStringErrorInvalidVoltage RTT_CTRL_RESET "\n", voltageMillivolts);
+#endif
+	}
+}
+
+
+
+void
+disableSssupply(void)
+{
+	disableTPS82740A();
+	disableTPS82740B();
+
+	/*
+	 *	Clear the pin. This sets the TS5A3154 to use the output of the TPS82740B,
+	 *	which shouldn't matter in any case. The main objective here is to clear
+	 *	the pin to reduce power drain.
+	 *
+	 *		IN = high selects the output of the TPS82740B:
+	 *		IN = low selects the output of the TPS82740A:
+	 */
+	GPIO_DRV_SetPinOutput(kWarpPinTS5A3154_IN);
+
+	/*
+	 *	Vload ramp time of the TPS82740 is 800us max (datasheet, Section 8.5 / page 5)
+	 */
+	OSA_TimeDelay(gWarpSupplySettlingDelayMilliseconds);
+}
+
+
+
+void
+warpLowPowerSecondsSleep(uint32_t sleepSeconds, bool forceAllPinsIntoLowPowerState)
+{
+	/*
+	 *	Set all pins into low-power states. We don't just disable all pins,
+	 *	as the various devices hanging off will be left in higher power draw
+	 *	state. And manuals say set pins to output to reduce power.
+	 */
+	if (forceAllPinsIntoLowPowerState)
+	{
+		lowPowerPinStates();
+	}
+
+	warpSetLowPowerMode(kWarpPowerModeVLPR, 0);
+	warpSetLowPowerMode(kWarpPowerModeVLPS, sleepSeconds);
+}
+
+
+
+void
+printPinDirections(void)
+{
+	/*
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+	SEGGER_RTT_printf(0, "KL03_VDD_ADC:%d\n", GPIO_DRV_GetPinDir(kWarpPinKL03_VDD_ADC));
+	OSA_TimeDelay(100);
+	SEGGER_RTT_printf(0, "I2C0_SDA:%d\n", GPIO_DRV_GetPinDir(kWarpPinI2C0_SDA));
+	OSA_TimeDelay(100);
+	SEGGER_RTT_printf(0, "I2C0_SCL:%d\n", GPIO_DRV_GetPinDir(kWarpPinI2C0_SCL));
+	OSA_TimeDelay(100);
+	SEGGER_RTT_printf(0, "SPI_MOSI:%d\n", GPIO_DRV_GetPinDir(kWarpPinSPI_MOSI));
+	OSA_TimeDelay(100);
+	SEGGER_RTT_printf(0, "SPI_MISO:%d\n", GPIO_DRV_GetPinDir(kWarpPinSPI_MISO));
+	OSA_TimeDelay(100);
+	SEGGER_RTT_printf(0, "SPI_SCK_I2C_PULLUP_EN:%d\n", GPIO_DRV_GetPinDir(kWarpPinSPI_SCK_I2C_PULLUP_EN));
+	OSA_TimeDelay(100);
+	SEGGER_RTT_printf(0, "TPS82740A_VSEL2:%d\n", GPIO_DRV_GetPinDir(kWarpPinTPS82740_VSEL2));
+	OSA_TimeDelay(100);
+	SEGGER_RTT_printf(0, "ADXL362_CS:%d\n", GPIO_DRV_GetPinDir(kWarpPinADXL362_CS));
+	OSA_TimeDelay(100);
+	SEGGER_RTT_printf(0, "kWarpPinPAN1326_nSHUTD:%d\n", GPIO_DRV_GetPinDir(kWarpPinPAN1326_nSHUTD));
+	OSA_TimeDelay(100);
+	SEGGER_RTT_printf(0, "TPS82740A_CTLEN:%d\n", GPIO_DRV_GetPinDir(kWarpPinTPS82740A_CTLEN));
+	OSA_TimeDelay(100);
+	SEGGER_RTT_printf(0, "TPS82740B_CTLEN:%d\n", GPIO_DRV_GetPinDir(kWarpPinTPS82740B_CTLEN));
+	OSA_TimeDelay(100);
+	SEGGER_RTT_printf(0, "TPS82740A_VSEL1:%d\n", GPIO_DRV_GetPinDir(kWarpPinTPS82740_VSEL1));
+	OSA_TimeDelay(100);
+	SEGGER_RTT_printf(0, "TPS82740A_VSEL3:%d\n", GPIO_DRV_GetPinDir(kWarpPinTPS82740_VSEL3));
+	OSA_TimeDelay(100);
+	SEGGER_RTT_printf(0, "CLKOUT32K:%d\n", GPIO_DRV_GetPinDir(kWarpPinCLKOUT32K));
+	OSA_TimeDelay(100);
+	SEGGER_RTT_printf(0, "TS5A3154_IN:%d\n", GPIO_DRV_GetPinDir(kWarpPinTS5A3154_IN));
+	OSA_TimeDelay(100);
+	SEGGER_RTT_printf(0, "SI4705_nRST:%d\n", GPIO_DRV_GetPinDir(kWarpPinSI4705_nRST));
+	OSA_TimeDelay(100);
+#endif
+	*/
+}
+
+
+
+void
+dumpProcessorState(void)
+{
+/*
+	uint32_t	cpuClockFrequency;
+
+	CLOCK_SYS_GetFreq(kCoreClock, &cpuClockFrequency);
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+	SEGGER_RTT_printf(0, "\r\n\n\tCPU @ %u KHz\n", (cpuClockFrequency / 1000));
+	SEGGER_RTT_printf(0, "\r\tCPU power mode: %u\n", POWER_SYS_GetCurrentMode());
+	SEGGER_RTT_printf(0, "\r\tCPU clock manager configuration: %u\n", CLOCK_SYS_GetCurrentConfiguration());
+	SEGGER_RTT_printf(0, "\r\tRTC clock: %d\n", CLOCK_SYS_GetRtcGateCmd(0));
+	SEGGER_RTT_printf(0, "\r\tSPI clock: %d\n", CLOCK_SYS_GetSpiGateCmd(0));
+	SEGGER_RTT_printf(0, "\r\tI2C clock: %d\n", CLOCK_SYS_GetI2cGateCmd(0));
+	SEGGER_RTT_printf(0, "\r\tLPUART clock: %d\n", CLOCK_SYS_GetLpuartGateCmd(0));
+	SEGGER_RTT_printf(0, "\r\tPORT A clock: %d\n", CLOCK_SYS_GetPortGateCmd(0));
+	SEGGER_RTT_printf(0, "\r\tPORT B clock: %d\n", CLOCK_SYS_GetPortGateCmd(1));
+	SEGGER_RTT_printf(0, "\r\tFTF clock: %d\n", CLOCK_SYS_GetFtfGateCmd(0));
+	SEGGER_RTT_printf(0, "\r\tADC clock: %d\n", CLOCK_SYS_GetAdcGateCmd(0));
+	SEGGER_RTT_printf(0, "\r\tCMP clock: %d\n", CLOCK_SYS_GetCmpGateCmd(0));
+	SEGGER_RTT_printf(0, "\r\tVREF clock: %d\n", CLOCK_SYS_GetVrefGateCmd(0));
+	SEGGER_RTT_printf(0, "\r\tTPM clock: %d\n", CLOCK_SYS_GetTpmGateCmd(0));
+#endif
+*/
+}
+
+#ifdef WARP_BUILD_ENABLE_THERMALCHAMBERANALYSIS
+void
+addAndMultiplicationBusyLoop(long iterations)
+{
+	int value;
+	for (volatile long i = 0; i < iterations; i++)
+	{
+		value = kWarpThermalChamberBusyLoopAdder + value * kWarpThermalChamberBusyLoopMutiplier;
+	}
+}
+
+uint8_t
+checkSum(uint8_t *  pointer, uint16_t length) /*	Adapted from https://stackoverflow.com/questions/31151032/writing-an-8-bit-checksum-in-c	*/
+{
+	unsigned int sum;
+	for ( sum = 0 ; length != 0 ; length-- )
+	{
+		sum += *(pointer++);
+	}
+	return (uint8_t)sum;
+}
+#endif
+
+int
+main(void)
+{
+	uint8_t					key;
+	WarpSensorDevice			menuTargetSensor = kWarpSensorBMX055accel;
+	volatile WarpI2CDeviceState *		menuI2cDevice = NULL;
+	uint16_t				menuI2cPullupValue = 32768;
+	uint8_t					menuRegisterAddress = 0x00;
+	uint16_t				menuSupplyVoltage = 0;
+
+
+	rtc_datetime_t				warpBootDate;
+
+	power_manager_user_config_t		warpPowerModeWaitConfig;
+	power_manager_user_config_t		warpPowerModeStopConfig;
+	power_manager_user_config_t		warpPowerModeVlpwConfig;
+	power_manager_user_config_t		warpPowerModeVlpsConfig;
+	power_manager_user_config_t		warpPowerModeVlls0Config;
+	power_manager_user_config_t		warpPowerModeVlls1Config;
+	power_manager_user_config_t		warpPowerModeVlls3Config;
+	power_manager_user_config_t		warpPowerModeRunConfig;
+
+	const power_manager_user_config_t	warpPowerModeVlprConfig = {
+							.mode			= kPowerManagerVlpr,
+							.sleepOnExitValue	= false,
+							.sleepOnExitOption	= false
+						};
+
+	power_manager_user_config_t const *	powerConfigs[] = {
+							/*
+							 *	NOTE: This order is depended on by POWER_SYS_SetMode()
+							 *
+							 *	See KSDK13APIRM.pdf Section 55.5.3
+							 */
+							&warpPowerModeWaitConfig,
+							&warpPowerModeStopConfig,
+							&warpPowerModeVlprConfig,
+							&warpPowerModeVlpwConfig,
+							&warpPowerModeVlpsConfig,
+							&warpPowerModeVlls0Config,
+							&warpPowerModeVlls1Config,
+							&warpPowerModeVlls3Config,
+							&warpPowerModeRunConfig,
+						};
+
+	WarpPowerManagerCallbackStructure			powerManagerCallbackStructure;
+
+	/*
+	 *	Callback configuration structure for power manager
+	 */
+	const power_manager_callback_user_config_t callbackCfg0 = {
+							callback0,
+							kPowerManagerCallbackBeforeAfter,
+							(power_manager_callback_data_t *) &powerManagerCallbackStructure};
+
+	/*
+	 *	Pointers to power manager callbacks.
+	 */
+	power_manager_callback_user_config_t const *	callbacks[] = {
+								&callbackCfg0
+						};
+
+
+
+	/*
+	 *	Enable clock for I/O PORT A and PORT B
+	 */
+	CLOCK_SYS_EnablePortClock(0);
+	CLOCK_SYS_EnablePortClock(1);
+
+
+
+	/*
+	 *	Setup board clock source.
+	 */
+	g_xtal0ClkFreq = 32768U;
+
+
+
+	/*
+	 *	Initialize KSDK Operating System Abstraction layer (OSA) layer.
+	 */
+	OSA_Init();
+
+
+
+	/*
+	 *	Setup SEGGER RTT to output as much as fits in buffers.
+	 *
+	 *	Using SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL can lead to deadlock, since
+	 *	we might have SWD disabled at time of blockage.
+	 */
+	SEGGER_RTT_ConfigUpBuffer(0, NULL, NULL, 0, SEGGER_RTT_MODE_NO_BLOCK_TRIM);
+
+
+	SEGGER_RTT_WriteString(0, "\n\n\n\rBooting Warp, in 3... ");
+	OSA_TimeDelay(200);
+	SEGGER_RTT_WriteString(0, "2... ");
+	OSA_TimeDelay(200);
+	SEGGER_RTT_WriteString(0, "1...\n\r");
+	OSA_TimeDelay(200);
+
+
+
+	/*
+	 *	Configure Clock Manager to default, and set callback for Clock Manager mode transition.
+	 *
+	 *	See "Clocks and Low Power modes with KSDK and Processor Expert" document (Low_Power_KSDK_PEx.pdf)
+	 */
+	CLOCK_SYS_Init(	g_defaultClockConfigurations,
+			CLOCK_CONFIG_NUM,
+			&clockCallbackTable,
+			ARRAY_SIZE(clockCallbackTable)
+			);
+	CLOCK_SYS_UpdateConfiguration(CLOCK_CONFIG_INDEX_FOR_RUN, kClockManagerPolicyForcible);
+
+
+
+	/*
+	 *	Initialize RTC Driver
+	 */
+	RTC_DRV_Init(0);
+
+
+
+	/*
+	 *	Set initial date to 1st January 2016 00:00, and set date via RTC driver
+	 */
+	warpBootDate.year	= 2016U;
+	warpBootDate.month	= 1U;
+	warpBootDate.day	= 1U;
+	warpBootDate.hour	= 0U;
+	warpBootDate.minute	= 0U;
+	warpBootDate.second	= 0U;
+	RTC_DRV_SetDatetime(0, &warpBootDate);
+
+
+
+	/*
+	 *	Setup Power Manager Driver
+	 */
+	memset(&powerManagerCallbackStructure, 0, sizeof(WarpPowerManagerCallbackStructure));
+
+
+	warpPowerModeVlpwConfig = warpPowerModeVlprConfig;
+	warpPowerModeVlpwConfig.mode = kPowerManagerVlpw;
+
+	warpPowerModeVlpsConfig = warpPowerModeVlprConfig;
+	warpPowerModeVlpsConfig.mode = kPowerManagerVlps;
+
+	warpPowerModeWaitConfig = warpPowerModeVlprConfig;
+	warpPowerModeWaitConfig.mode = kPowerManagerWait;
+
+	warpPowerModeStopConfig = warpPowerModeVlprConfig;
+	warpPowerModeStopConfig.mode = kPowerManagerStop;
+
+	warpPowerModeVlls0Config = warpPowerModeVlprConfig;
+	warpPowerModeVlls0Config.mode = kPowerManagerVlls0;
+
+	warpPowerModeVlls1Config = warpPowerModeVlprConfig;
+	warpPowerModeVlls1Config.mode = kPowerManagerVlls1;
+
+	warpPowerModeVlls3Config = warpPowerModeVlprConfig;
+	warpPowerModeVlls3Config.mode = kPowerManagerVlls3;
+
+	warpPowerModeRunConfig.mode = kPowerManagerRun;
+
+	POWER_SYS_Init(	&powerConfigs,
+			sizeof(powerConfigs)/sizeof(power_manager_user_config_t *),
+			&callbacks,
+			sizeof(callbacks)/sizeof(power_manager_callback_user_config_t *)
+			);
+
+
+
+	/*
+	 *	Switch CPU to Very Low Power Run (VLPR) mode
+	 */
+	warpSetLowPowerMode(kWarpPowerModeVLPR, 0);
+
+
+
+	/*
+	 *	Initialize the GPIO pins with the appropriate pull-up, etc.,
+	 *	defined in the inputPins and outputPins arrays (gpio_pins.c).
+	 *
+	 *	See also Section 30.3.3 GPIO Initialization of KSDK13APIRM.pdf
+	 */
+	GPIO_DRV_Init(inputPins  /* input pins */, outputPins  /* output pins */);
+
+	/*
+	 *	Note that it is lowPowerPinStates() that sets the pin mux mode,
+	 *	so until we call it pins are in their default state.
+	 */
+	lowPowerPinStates();
+
+
+
+	/*
+	 *	Toggle LED3 (kWarpPinSI4705_nRST)
+	 */
+	GPIO_DRV_SetPinOutput(kWarpPinSI4705_nRST);
+	OSA_TimeDelay(200);
+	GPIO_DRV_ClearPinOutput(kWarpPinSI4705_nRST);
+	OSA_TimeDelay(200);
+	GPIO_DRV_SetPinOutput(kWarpPinSI4705_nRST);
+	OSA_TimeDelay(200);
+	GPIO_DRV_ClearPinOutput(kWarpPinSI4705_nRST);
+	OSA_TimeDelay(200);
+	GPIO_DRV_SetPinOutput(kWarpPinSI4705_nRST);
+	OSA_TimeDelay(200);
+	GPIO_DRV_ClearPinOutput(kWarpPinSI4705_nRST);
+
+
+
+	/*
+	 *	Initialize all the sensors
+	 */
+#ifdef WARP_BUILD_ENABLE_DEVBMX055
+	initBMX055accel(0x18	/* i2cAddress */,	&deviceBMX055accelState	);
+	initBMX055gyro(	0x68	/* i2cAddress */,	&deviceBMX055gyroState	);
+	initBMX055mag(	0x10	/* i2cAddress */,	&deviceBMX055magState	);
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVMMA8451Q
+	initMMA8451Q(	0x1C	/* i2cAddress */,	&deviceMMA8451QState	);
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVLPS25H
+	initLPS25H(	0x5C	/* i2cAddress */,	&deviceLPS25HState	);
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVHDC1000
+	initHDC1000(	0x43	/* i2cAddress */,	&deviceHDC1000State	);
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVMAG3110
+	initMAG3110(	0x0E	/* i2cAddress */,	&deviceMAG3110State	);
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVSI7021
+	initSI7021(	0x40	/* i2cAddress */,	&deviceSI7021State	);
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVL3GD20H
+	initL3GD20H(	0x6A	/* i2cAddress */,	&deviceL3GD20HState	);
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVBME680
+	initBME680(	0x77	/* i2cAddress */,	&deviceBME680State	);
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVTCS34725
+	initTCS34725(	0x29	/* i2cAddress */,	&deviceTCS34725State	);
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVSI4705
+	initSI4705(	0x11	/* i2cAddress */,	&deviceSI4705State	);
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVCCS811
+	initCCS811(	0x5A	/* i2cAddress */,	&deviceCCS811State	);
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVAMG8834
+	initAMG8834(	0x68	/* i2cAddress */,	&deviceAMG8834State	);
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVAS7262
+	initAS7262(	0x49	/* i2cAddress */,	&deviceAS7262State	);
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVAS7263
+	initAS7263(	0x49	/* i2cAddress */,	&deviceAS7263State	);
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVRV8803C7
+  initRV8803C7(0x32 /* i2cAddress */, &deviceRV8803C7State);
+  enableI2Cpins(menuI2cPullupValue);
+  setRTCCountdownRV8803C7(0, TD_1HZ, false);
+  disableI2Cpins();
+#endif
+
+	/*
+	 *	Initialization: Devices hanging off SPI
+	 */
+#ifdef WARP_BUILD_ENABLE_DEVADXL362
+	initADXL362(&deviceADXL362State);
+#endif
+
+
+	/*
+	 *	Initialization: the PAN1326, generating its 32k clock
+	 */
+#ifdef WARP_BUILD_ENABLE_DEVPAN1326
+	initPAN1326B(&devicePAN1326BState);
+#endif
+
+#ifdef WARP_BUILD_ENABLE_DEVISL23415
+	initISL23415(&deviceISL23415State);
+#endif
+
+	/*
+	 *	Make sure SCALED_SENSOR_SUPPLY is off.
+	 *
+	 *	(There's no point in calling activateAllLowPowerSensorModes())
+	 */
+	disableSssupply();
+
+
+	/*
+	 *	TODO: initialize the kWarpPinKL03_VDD_ADC, write routines to read the VDD and temperature
+	 */
+
+
+
+
+#ifdef WARP_BUILD_BOOT_TO_CSVSTREAM
+	/*
+	 *	Force to printAllSensors
+	 */
+	gWarpI2cBaudRateKbps = 300;
+	warpSetLowPowerMode(kWarpPowerModeRUN, 0 /* sleep seconds : irrelevant here */);
+	enableSssupply(3000);
+	enableI2Cpins(menuI2cPullupValue);
+	printAllSensors(false /* printHeadersAndCalibration */, true /* hexModeFlag */, 0 /* menuDelayBetweenEachRun */, menuI2cPullupValue);
+	/*
+	 *	Notreached
+	 */
+#endif
+
+	while (1)
+	{
+		/*
+		 *	Do not, e.g., lowPowerPinStates() on each iteration, because we actually
+		 *	want to use menu to progressiveley change the machine state with various
+		 *	commands.
+		 */
+
+		/*
+		 *	We break up the prints with small delays to allow us to use small RTT print
+		 *	buffers without overrunning them when at max CPU speed.
+		 */
+		SEGGER_RTT_WriteString(0, "\r\n\n\n\n[ *\t\t\t\tW\ta\tr\tp\t(rev. b)\t\t\t* ]\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r[  \t\t\t\t      Cambridge / Physcomplab   \t\t\t\t  ]\n\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+		SEGGER_RTT_printf(0, "\r\tSupply=%dmV,\tDefault Target Read Register=0x%02x\n",
+								menuSupplyVoltage, menuRegisterAddress);
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_printf(0, "\r\tI2C=%dkb/s,\tSPI=%dkb/s,\tUART=%dkb/s,\tI2C Pull-Up=%d\n\n",
+								gWarpI2cBaudRateKbps, gWarpSpiBaudRateKbps, gWarpUartBaudRateKbps, menuI2cPullupValue);
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_printf(0, "\r\tSIM->SCGC6=0x%02x\t\tRTC->SR=0x%02x\t\tRTC->TSR=0x%02x\n", SIM->SCGC6, RTC->SR, RTC->TSR);
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_printf(0, "\r\tMCG_C1=0x%02x\t\t\tMCG_C2=0x%02x\t\tMCG_S=0x%02x\n", MCG_C1, MCG_C2, MCG_S);
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_printf(0, "\r\tMCG_SC=0x%02x\t\t\tMCG_MC=0x%02x\t\tOSC_CR=0x%02x\n", MCG_SC, MCG_MC, OSC_CR);
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_printf(0, "\r\tSMC_PMPROT=0x%02x\t\t\tSMC_PMCTRL=0x%02x\t\tSCB->SCR=0x%02x\n", SMC_PMPROT, SMC_PMCTRL, SCB->SCR);
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_printf(0, "\r\tPMC_REGSC=0x%02x\t\t\tSIM_SCGC4=0x%02x\tRTC->TPR=0x%02x\n\n", PMC_REGSC, SIM_SCGC4, RTC->TPR);
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+		SEGGER_RTT_printf(0, "\r\t%ds in RTC Handler to-date,\t%d Pmgr Errors\n", gWarpSleeptimeSeconds, powerManagerCallbackStructure.errorCount);
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+#else
+		SEGGER_RTT_WriteString(0, "\r\n\n\t\tWARNING: SEGGER_RTT_printf disabled in this firmware build.\n\t\tOnly showing output that does not require value formatting.\n\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+#endif
+
+		SEGGER_RTT_WriteString(0, "\rSelect:\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 'a': set default sensor.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 'b': set I2C baud rate.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 'c': set SPI baud rate.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 'd': set UART baud rate.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 'e': set default register address.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 'f': write byte to sensor.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 'g': set default SSSUPPLY.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 'h': powerdown command to all sensors.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 'i': set pull-up enable value.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+		SEGGER_RTT_printf(0, "\r- 'j': repeat read reg 0x%02x on sensor #%d.\n", menuRegisterAddress, menuTargetSensor);
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+#endif
+
+		SEGGER_RTT_WriteString(0, "\r- 'k': sleep until reset.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 'l': send repeated byte on I2C.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 'm': send repeated byte on SPI.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 'n': enable SSSUPPLY.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 'o': disable SSSUPPLY.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 'p': switch to VLPR mode.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_DEVMAX11300
+		SEGGER_RTT_WriteString(0, "\r- 'q': MAX11300.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+#endif
+
+		SEGGER_RTT_WriteString(0, "\r- 'r': switch to RUN mode.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 's': power up all sensors.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 't': dump processor state.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\r- 'u': set I2C address.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+#ifdef WARP_BUILD_ENABLE_DEVRV8803C7
+		SEGGER_RTT_WriteString(0, "\r- 'v': Enter VLLS0 low-power mode for 3s, then reset\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+#endif
+		SEGGER_RTT_WriteString(0, "\r- 'x': disable SWD and spin for 10 secs.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_THERMALCHAMBERANALYSIS
+		SEGGER_RTT_WriteString(0, "\r- 'y': stress test (need a force quit)\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+#endif
+
+		SEGGER_RTT_WriteString(0, "\r- 'z': dump all sensors data.\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+		SEGGER_RTT_WriteString(0, "\rEnter selection> ");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		key = SEGGER_RTT_WaitKey();
+		
+		switch (key)
+		{
+			/*
+			 *		Select sensor
+			 */
+			case 'a':
+			{
+				SEGGER_RTT_WriteString(0, "\r\tSelect:\n");
+#ifdef WARP_BUILD_ENABLE_DEVADXL362
+				SEGGER_RTT_WriteString(0, "\r\t- '1' ADXL362			(0x00--0x2D): 1.6V -- 3.5V\n");
+				#else
+				SEGGER_RTT_WriteString(0, "\r\t- '1' ADXL362			(0x00--0x2D): 1.6V -- 3.5V (compiled out) \n");
+#endif
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_DEVBMX055
+				SEGGER_RTT_WriteString(0, "\r\t- '2' BMX055accel		(0x00--0x3F): 2.4V -- 3.6V\n");
+				SEGGER_RTT_WriteString(0, "\r\t- '3' BMX055gyro			(0x00--0x3F): 2.4V -- 3.6V\n");
+				SEGGER_RTT_WriteString(0, "\r\t- '4' BMX055mag			(0x40--0x52): 2.4V -- 3.6V\n");
+				#else
+				SEGGER_RTT_WriteString(0, "\r\t- '2' BMX055accel 		(0x00--0x3F): 2.4V -- 3.6V (compiled out) \n");
+				SEGGER_RTT_WriteString(0, "\r\t- '3' BMX055gyro			(0x00--0x3F): 2.4V -- 3.6V (compiled out) \n");
+				SEGGER_RTT_WriteString(0, "\r\t- '4' BMX055mag			(0x40--0x52): 2.4V -- 3.6V (compiled out) \n");
+#endif
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_DEVMMA8451Q
+				SEGGER_RTT_WriteString(0, "\r\t- '5' MMA8451Q			(0x00--0x31): 1.95V -- 3.6V\n");
+				#else
+				SEGGER_RTT_WriteString(0, "\r\t- '5' MMA8451Q			(0x00--0x31): 1.95V -- 3.6V (compiled out) \n");
+#endif
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_DEVLPS25H
+				SEGGER_RTT_WriteString(0, "\r\t- '6' LPS25H			(0x08--0x24): 1.7V -- 3.6V\n");
+				#else
+				SEGGER_RTT_WriteString(0, "\r\t- '6' LPS25H			(0x08--0x24): 1.7V -- 3.6V (compiled out) \n");
+#endif
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_DEVMAG3110
+				SEGGER_RTT_WriteString(0, "\r\t- '7' MAG3110			(0x00--0x11): 1.95V -- 3.6V\n");
+				#else
+				SEGGER_RTT_WriteString(0, "\r\t- '7' MAG3110			(0x00--0x11): 1.95V -- 3.6V (compiled out) \n");
+#endif
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_DEVHDC1000
+				SEGGER_RTT_WriteString(0, "\r\t- '8' HDC1000			(0x00--0x1F): 3.0V -- 5.0V\n");
+				#else
+				SEGGER_RTT_WriteString(0, "\r\t- '8' HDC1000			(0x00--0x1F): 3.0V -- 5.0V (compiled out) \n");
+#endif
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_DEVSI7021
+				SEGGER_RTT_WriteString(0, "\r\t- '9' SI7021			(0x00--0x0F): 1.9V -- 3.6V\n");
+				#else
+				SEGGER_RTT_WriteString(0, "\r\t- '9' SI7021			(0x00--0x0F): 1.9V -- 3.6V (compiled out) \n");
+#endif
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_DEVL3GD20H
+				SEGGER_RTT_WriteString(0, "\r\t- 'a' L3GD20H			(0x0F--0x39): 2.2V -- 3.6V\n");
+				#else
+				SEGGER_RTT_WriteString(0, "\r\t- 'a' L3GD20H			(0x0F--0x39): 2.2V -- 3.6V (compiled out) \n");
+#endif
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_DEVBME680
+				SEGGER_RTT_WriteString(0, "\r\t- 'b' BME680			(0xAA--0xF8): 1.6V -- 3.6V\n");
+				#else
+				SEGGER_RTT_WriteString(0, "\r\t- 'b' BME680			(0xAA--0xF8): 1.6V -- 3.6V (compiled out) \n");
+#endif
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_DEVTCS34725
+				SEGGER_RTT_WriteString(0, "\r\t- 'd' TCS34725			(0x00--0x1D): 2.7V -- 3.3V\n");
+				#else
+				SEGGER_RTT_WriteString(0, "\r\t- 'd' TCS34725			(0x00--0x1D): 2.7V -- 3.3V (compiled out) \n");
+#endif
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_DEVSI4705
+				SEGGER_RTT_WriteString(0, "\r\t- 'e' SI4705			(n/a):        2.7V -- 5.5V\n");
+				#else
+				SEGGER_RTT_WriteString(0, "\r\t- 'e' SI4705			(n/a):        2.7V -- 5.5V (compiled out) \n");
+#endif
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_DEVPAN1326
+				SEGGER_RTT_WriteString(0, "\r\t- 'f' PAN1326			(n/a)\n");
+				#else
+				SEGGER_RTT_WriteString(0, "\r\t- 'f' PAN1326			(n/a) (compiled out) \n");
+#endif
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_DEVCCS811
+				SEGGER_RTT_WriteString(0, "\r\t- 'g' CCS811			(0x00--0xFF): 1.8V -- 3.6V\n");
+				#else
+				SEGGER_RTT_WriteString(0, "\r\t- 'g' CCS811			(0x00--0xFF): 1.8V -- 3.6V (compiled out) \n");
+#endif
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_DEVAMG8834
+				SEGGER_RTT_WriteString(0, "\r\t- 'h' AMG8834			(0x00--?): ?V -- ?V\n");
+				#else
+				SEGGER_RTT_WriteString(0, "\r\t- 'h' AMG8834			(0x00--?): ?V -- ?V (compiled out) \n");
+#endif
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_DEVAS7262
+				SEGGER_RTT_WriteString(0, "\r\t- 'j' AS7262			(0x00--0x2B): 2.7V -- 3.6V\n");
+				#else
+				SEGGER_RTT_WriteString(0, "\r\t- 'j' AS7262			(0x00--0x2B): 2.7V -- 3.6V (compiled out) \n");
+#endif
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+#ifdef WARP_BUILD_ENABLE_DEVAS7263
+				SEGGER_RTT_WriteString(0, "\r\t- 'k' AS7263			(0x00--0x2B): 2.7V -- 3.6V\n");
+				#else
+				SEGGER_RTT_WriteString(0, "\r\t- 'k' AS7263			(0x00--0x2B): 2.7V -- 3.6V (compiled out) \n");
+#endif
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+				SEGGER_RTT_WriteString(0, "\r\tEnter selection> ");
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+				key = SEGGER_RTT_WaitKey();
+
+				switch(key)
+				{
+#ifdef WARP_BUILD_ENABLE_DEVADXL362
+					case '1':
+					{
+						menuTargetSensor = kWarpSensorADXL362;
+
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVBMX055
+					case '2':
+					{
+						menuTargetSensor = kWarpSensorBMX055accel;
+						menuI2cDevice = &deviceBMX055accelState;
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVBMX055
+					case '3':
+					{
+						menuTargetSensor = kWarpSensorBMX055gyro;
+						menuI2cDevice = &deviceBMX055gyroState;
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVBMX055
+					case '4':
+					{
+						menuTargetSensor = kWarpSensorBMX055mag;
+						menuI2cDevice = &deviceBMX055magState;
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVMMA8451Q
+					case '5':
+					{
+						menuTargetSensor = kWarpSensorMMA8451Q;
+						menuI2cDevice = &deviceMMA8451QState;
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVLPS25H
+					case '6':
+					{
+						menuTargetSensor = kWarpSensorLPS25H;
+						menuI2cDevice = &deviceLPS25HState;
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVMAG3110
+					case '7':
+					{
+						menuTargetSensor = kWarpSensorMAG3110;
+						menuI2cDevice = &deviceMAG3110State;
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVHDC1000
+					case '8':
+					{
+						menuTargetSensor = kWarpSensorHDC1000;
+						menuI2cDevice = &deviceHDC1000State;
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVSI7021
+					case '9':
+					{
+						menuTargetSensor = kWarpSensorSI7021;
+						menuI2cDevice = &deviceSI7021State;
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVL3GD20H
+					case 'a':
+					{
+						menuTargetSensor = kWarpSensorL3GD20H;
+						menuI2cDevice = &deviceL3GD20HState;
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVBME680
+					case 'b':
+					{
+						menuTargetSensor = kWarpSensorBME680;
+						menuI2cDevice = &deviceBME680State;
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVTCS34725
+					case 'd':
+					{
+						menuTargetSensor = kWarpSensorTCS34725;
+						menuI2cDevice = &deviceTCS34725State;
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVSI4705
+					case 'e':
+					{
+						menuTargetSensor = kWarpSensorSI4705;
+						menuI2cDevice = &deviceSI4705State;
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVPAN1326
+					case 'f':
+					{
+						menuTargetSensor = kWarpSensorPAN1326;
+
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVCCS811
+					case 'g':
+					{
+						menuTargetSensor = kWarpSensorCCS811;
+						menuI2cDevice = &deviceCCS811State;
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVAMG8834
+					case 'h':
+					{
+						menuTargetSensor = kWarpSensorAMG8834;
+						menuI2cDevice = &deviceAMG8834State;
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVAS7262
+					case 'j':
+					{
+						menuTargetSensor = kWarpSensorAS7262;
+						menuI2cDevice = &deviceAS7262State;
+						break;
+					}
+#endif
+#ifdef WARP_BUILD_ENABLE_DEVAS7263
+					case 'k':
+					{
+						menuTargetSensor = kWarpSensorAS7263;
+						menuI2cDevice = &deviceAS7263State;
+						break;
+					}
+#endif
+					default:
+					{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+						SEGGER_RTT_printf(0, "\r\tInvalid selection '%c' !\n", key);
+#endif
+					}
+				}
+
+				break;
+			}
+
+			/*
+			 *	Change default I2C baud rate
+			 */
+			case 'b':
+			{
+				SEGGER_RTT_WriteString(0, "\r\n\tSet I2C baud rate in kbps (e.g., '0001')> ");
+				gWarpI2cBaudRateKbps = read4digits();
+
+				/*
+				 *	Round 9999kbps to 10Mbps
+				 */
+				if (gWarpI2cBaudRateKbps == 9999)
+				{
+					gWarpI2cBaudRateKbps = 10000;
+				}
+
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+				SEGGER_RTT_printf(0, "\r\n\tI2C baud rate set to %d kb/s", gWarpI2cBaudRateKbps);
+#endif
+
+				break;
+			}
+
+			/*
+			 *	Change default SPI baud rate
+			 */
+			case 'c':
+			{
+				SEGGER_RTT_WriteString(0, "\r\n\tSet SPI baud rate in kbps (e.g., '0001')> ");
+				gWarpSpiBaudRateKbps = read4digits();
+
+				/*
+				 *	Round 9999kbps to 10Mbps
+				 */
+				if (gWarpSpiBaudRateKbps == 9999)
+				{
+					gWarpSpiBaudRateKbps = 10000;
+				}
+
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+				SEGGER_RTT_printf(0, "\r\n\tSPI baud rate: %d kb/s", gWarpSpiBaudRateKbps);
+#endif
+
+				break;
+			}
+
+			/*
+			 *	Change default UART baud rate
+			 */
+			case 'd':
+			{
+				SEGGER_RTT_WriteString(0, "\r\n\tSet UART baud rate in kbps (e.g., '0001')> ");
+				gWarpUartBaudRateKbps = read4digits();
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+				SEGGER_RTT_printf(0, "\r\n\tUART baud rate: %d kb/s", gWarpUartBaudRateKbps);
+#endif
+
+				break;
+			}
+
+			/*
+			 *	Set register address for subsequent operations
+			 */
+			case 'e':
+			{
+				SEGGER_RTT_WriteString(0, "\r\n\tEnter 2-nybble register hex address (e.g., '3e')> ");
+				menuRegisterAddress = readHexByte();
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+				SEGGER_RTT_printf(0, "\r\n\tEntered [0x%02x].\n\n", menuRegisterAddress);
+#endif
+
+				break;
+			}
+
+			/*
+			 *	Write byte to sensor
+			 */
+			case 'f':
+			{
+				uint8_t		i2cAddress, payloadByte[1], commandByte[1];
+				i2c_status_t	i2cStatus;
+				WarpStatus	status;
+
+
+				USED(status);
+				SEGGER_RTT_WriteString(0, "\r\n\tEnter I2C addr. (e.g., '0f') or '99' for SPI > ");
+				i2cAddress = readHexByte();
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+				SEGGER_RTT_printf(0, "\r\n\tEntered [0x%02x].\n", i2cAddress);
+#endif
+
+				SEGGER_RTT_WriteString(0, "\r\n\tEnter hex byte to send (e.g., '0f')> ");
+				payloadByte[0] = readHexByte();
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+				SEGGER_RTT_printf(0, "\r\n\tEntered [0x%02x].\n", payloadByte[0]);
+#endif
+
+				if (i2cAddress == 0x99)
+				{
+#ifdef WARP_BUILD_ENABLE_DEVADXL362
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+					SEGGER_RTT_printf(0, "\r\n\tWriting [0x%02x] to SPI register [0x%02x]...\n", payloadByte[0], menuRegisterAddress);
+#endif
+					status = writeSensorRegisterADXL362(	0x0A			/* command == write register	*/,
+										menuRegisterAddress,
+										payloadByte[0]		/* writeValue			*/
+									);
+					if (status != kWarpStatusOK)
+					{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+						SEGGER_RTT_printf(0, "\r\n\tSPI write failed, error %d.\n\n", status);
+#endif
+					}
+					#else
+					SEGGER_RTT_WriteString(0, "\r\n\tSPI write failed. ADXL362 Disabled");
+#endif
+				}
+				else
+				{
+					i2c_device_t slave =
+					{
+						.address = i2cAddress,
+						.baudRate_kbps = gWarpI2cBaudRateKbps
+					};
+
+					enableSssupply(menuSupplyVoltage);
+					enableI2Cpins(menuI2cPullupValue);
+
+					commandByte[0] = menuRegisterAddress;
+					i2cStatus = I2C_DRV_MasterSendDataBlocking(
+											0 /* I2C instance */,
+											&slave,
+											commandByte,
+											1,
+											payloadByte,
+											1,
+											gWarpI2cTimeoutMilliseconds);
+					if (i2cStatus != kStatus_I2C_Success)
+					{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+						SEGGER_RTT_printf(0, "\r\n\tI2C write failed, error %d.\n\n", i2cStatus);
+#endif
+					}
+					disableI2Cpins();
+				}
+
+				/*
+				 *	NOTE: do not disable the supply here, because we typically want to build on the effect of this register write command.
+				 */
+
+				break;
+			}
+
+			/*
+			 *	Configure default TPS82740 voltage
+			 */
+			case 'g':
+			{
+				SEGGER_RTT_WriteString(0, "\r\n\tOverride SSSUPPLY in mV (e.g., '1800')> ");
+				menuSupplyVoltage = read4digits();
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+				SEGGER_RTT_printf(0, "\r\n\tOverride SSSUPPLY set to %d mV", menuSupplyVoltage);
+#endif
+
+				break;
+			}
+
+			/*
+			 *	Activate low-power modes in all sensors.
+			 */
+			case 'h':
+			{
+				SEGGER_RTT_WriteString(0, "\r\n\tNOTE: First power sensors and enable I2C\n\n");
+				activateAllLowPowerSensorModes(true /* verbose */);
+
+				break;
+			}
+
+			/*
+			 *	Configure default pullup enable value
+			 */
+			case 'i':
+			{
+				SEGGER_RTT_WriteString(0, "\r\n\tDefault pullup enable value in kiloOhms (e.g., '0000')> ");
+				menuI2cPullupValue = read4digits();
+
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+				SEGGER_RTT_printf(0, "\r\n\tI2cPullupValue set to %d\n", menuI2cPullupValue);
+#endif
+
+				break;
+			}
+
+			/*
+			 *	Start repeated read
+			 */
+			case 'j':
+			{
+				bool		autoIncrement, chatty;
+				int		spinDelay, repetitionsPerAddress, chunkReadsPerAddress;
+				int		adaptiveSssupplyMaxMillivolts;
+				uint8_t		referenceByte;
+
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+				SEGGER_RTT_printf(0, "\r\n\tAuto-increment from base address 0x%02x? ['0' | '1']> ", menuRegisterAddress);
+				#else
+				SEGGER_RTT_WriteString(0, "\r\n\tChunk reads per address (e.g., '1')> ");
+#endif
+
+				autoIncrement = SEGGER_RTT_WaitKey() - '0';
+
+				SEGGER_RTT_WriteString(0, "\r\n\tChunk reads per address (e.g., '1')> ");
+				chunkReadsPerAddress = SEGGER_RTT_WaitKey() - '0';
+
+				SEGGER_RTT_WriteString(0, "\r\n\tChatty? ['0' | '1']> ");
+				chatty = SEGGER_RTT_WaitKey() - '0';
+
+				SEGGER_RTT_WriteString(0, "\r\n\tInter-operation spin delay in milliseconds (e.g., '0000')> ");
+				spinDelay = read4digits();
+
+				SEGGER_RTT_WriteString(0, "\r\n\tRepetitions per address (e.g., '0000')> ");
+				repetitionsPerAddress = read4digits();
+
+				SEGGER_RTT_WriteString(0, "\r\n\tMaximum voltage for adaptive supply (e.g., '0000')> ");
+				adaptiveSssupplyMaxMillivolts = read4digits();
+
+				SEGGER_RTT_WriteString(0, "\r\n\tReference byte for comparisons (e.g., '3e')> ");
+				referenceByte = readHexByte();
+
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+				SEGGER_RTT_printf(0, "\r\n\tRepeating dev%d @ 0x%02x, reps=%d, pull=%d, delay=%dms:\n\n",
+					menuTargetSensor, menuRegisterAddress, repetitionsPerAddress, menuI2cPullupValue, spinDelay);
+#endif
+
+				repeatRegisterReadForDeviceAndAddress(	menuTargetSensor /*warpSensorDevice*/,
+									menuRegisterAddress /*baseAddress */,
+									menuI2cPullupValue,
+									autoIncrement /*autoIncrement*/,
+									chunkReadsPerAddress,
+									chatty,
+									spinDelay,
+									repetitionsPerAddress,
+									menuSupplyVoltage,
+									adaptiveSssupplyMaxMillivolts,
+									referenceByte
+								);
+
+				break;
+			}
+
+			/*
+			 *	Sleep for 30 seconds.
+			 */
+			case 'k':
+			{
+				SEGGER_RTT_WriteString(0, "\r\n\tSleeping until system reset...\n");
+				sleepUntilReset();
+
+				break;
+			}
+
+			/*
+			 *	Send repeated byte on I2C or SPI
+			 */
+			case 'l':
+			case 'm':
+			{
+				uint8_t		outBuffer[1];
+				int		repetitions;
+
+				SEGGER_RTT_WriteString(0, "\r\n\tNOTE: First power sensors and enable I2C\n\n");
+				SEGGER_RTT_WriteString(0, "\r\n\tByte to send (e.g., 'F0')> ");
+				outBuffer[0] = readHexByte();
+
+				SEGGER_RTT_WriteString(0, "\r\n\tRepetitions (e.g., '0000')> ");
+				repetitions = read4digits();
+
+				if (key == 'l')
+				{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+					SEGGER_RTT_printf(0, "\r\n\tSending %d repetitions of [0x%02x] on I2C, i2cPullupEnable=%d, SSSUPPLY=%dmV\n\n",
+						repetitions, outBuffer[0], menuI2cPullupValue, menuSupplyVoltage);
+#endif
+					for (int i = 0; i < repetitions; i++)
+					{
+						writeByteToI2cDeviceRegister(0xFF, true /* sedCommandByte */, outBuffer[0] /* commandByte */, false /* sendPayloadByte */, 0 /* payloadByte */);
+					}
+				}
+				else
+				{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+					SEGGER_RTT_printf(0, "\r\n\tSending %d repetitions of [0x%02x] on SPI, SSSUPPLY=%dmV\n\n",
+						repetitions, outBuffer[0], menuSupplyVoltage);
+#endif
+					for (int i = 0; i < repetitions; i++)
+					{
+						writeBytesToSpi(outBuffer /* payloadByte */, 1 /* payloadLength */);
+					}
+				}
+
+				break;
+			}
+
+
+			/*
+			 *	enable SSSUPPLY
+			 */
+			case 'n':
+			{
+				enableSssupply(menuSupplyVoltage);
+				break;
+			}
+
+			/*
+			 *	disable SSSUPPLY
+			 */
+			case 'o':
+			{
+				disableSssupply();
+				break;
+			}
+
+			/*
+			 *	Switch to VLPR
+			 */
+			case 'p':
+			{
+				warpSetLowPowerMode(kWarpPowerModeVLPR, 0 /* sleep seconds : irrelevant here */);
+				break;
+			}
+#ifdef WARP_BUILD_ENABLE_DEVMAX11300
+			case 'q':
+			{
+				SEGGER_RTT_printf(0, "\r\tMAX11300 Configuration\n");
+				devMAX11300();
+				break;
+			}
+#endif
+
+			/*
+			 *	Switch to RUN
+			 */
+			case 'r':
+			{
+				warpSetLowPowerMode(kWarpPowerModeRUN, 0 /* sleep seconds : irrelevant here */);
+				break;
+			}
+
+			/*
+			 *	Power up all sensors
+			 */
+			case 's':
+			{
+				SEGGER_RTT_WriteString(0, "\r\n\tNOTE: First power sensors and enable I2C\n\n");
+				powerupAllSensors();
+				break;
+			}
+
+			/*
+			 *	Dump processor state
+			 */
+			case 't':
+			{
+				dumpProcessorState();
+				break;
+			}
+
+			case 'u':
+			{
+				if (menuI2cDevice == NULL)
+				{
+					SEGGER_RTT_WriteString(0, "\r\n\tCannot set I2C address: First set the default I2C device.\n");
+				}
+				else
+				{
+					SEGGER_RTT_WriteString(0, "\r\n\tSet I2C address of the selected sensor(e.g., '1C')> ");
+					uint8_t address = readHexByte();
+					menuI2cDevice->i2cAddress = address;
+				}
+
+				break;
+			}
+#ifdef WARP_BUILD_ENABLE_DEVRV8803C7
+			case 'v':
+			{
+				SEGGER_RTT_WriteString(0, "\r\n\tEnabling I2C pins\n");
+				enableI2Cpins(menuI2cPullupValue);
+				SEGGER_RTT_WriteString(0, "\r\n\tSleeping for 3 seconds, then resetting\n");
+				warpSetLowPowerMode(kWarpPowerModeVLLS0, 3 /* sleep seconds */);
+				SEGGER_RTT_WriteString(0, "\r\n\tThis should never happen...\n");
+			}
+#endif
+			/*
+			 *	Simply spin for 10 seconds. Since the SWD pins should only be enabled when we are waiting for key at top of loop (or toggling after printf), during this time there should be no interference from the SWD.
+			 */
+			case 'x':
+			{
+				SEGGER_RTT_WriteString(0, "\r\n\tSpinning for 10 seconds...\n");
+				OSA_TimeDelay(10000);
+				SEGGER_RTT_WriteString(0, "\r\tDone.\n\n");
+
+				break;
+			}
+
+			/*
+			 *	Stress test, including bit-wise toggling and checksum, as well as extensive add and mul, with continous read and write to I2C MMA8451Q
+			 */
+#ifdef WARP_BUILD_ENABLE_THERMALCHAMBERANALYSIS
+			case 'y':
+			{
+				/*
+				 *	I2C MMA8451Q initialization
+				 */
+
+				WarpStatus i2cWriteStatusA, i2cWriteStatusB;
+				WarpStatus i2cReadStatusX = kWarpStatusDeviceCommunicationFailed;
+				WarpStatus i2cReadStatusY = kWarpStatusDeviceCommunicationFailed;
+				WarpStatus i2cReadStatusZ = kWarpStatusDeviceCommunicationFailed;
+
+				enableI2Cpins(menuI2cPullupValue);
+				i2cWriteStatusA = writeSensorRegisterMMA8451Q(0x09 /* register address F_SETUP */,
+										0x00 /* payload: Disable FIFO */,
+										1);
+
+				i2cWriteStatusB = writeSensorRegisterMMA8451Q(0x2A /* register address */,
+										0x03 /* payload: Enable fast read 8bit, 800Hz, normal, active mode */,
+										1);
+
+				if((i2cWriteStatusA != kWarpStatusOK) && (i2cWriteStatusB != kWarpStatusOK))
+				{
+					SEGGER_RTT_printf(0, "\nError when writing to I2C device");
+					for(int errorLED = 0; errorLED < 5; errorLED++)
+					{
+						/*
+						 *	Error when writing to I2C device
+						 *	LED pattern : All On -> All off -> Red
+						 */
+						GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Red);
+						GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Blue);
+						GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Green);
+						OSA_TimeDelay(100);
+						GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Red);
+						GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Blue);
+						GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Green);
+						OSA_TimeDelay(100);
+						GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Red);
+						OSA_TimeDelay(1000);
+					}
+				}
+				/*
+				 *	Fill up the remaining memory space using a fixed size array
+				 *	The size of this array is highly dependent on the firmware code size
+				 */
+				WarpThermalChamberKL03MemoryFill	KL03MemoryFill;
+				KL03MemoryFill.outputBuffer[0] = 0;
+				KL03MemoryFill.outputBuffer[1] = 0;
+				KL03MemoryFill.outputBuffer[2] = 0;
+
+				GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Blue);
+				GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Red);
+				GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Green);
+				OSA_TimeDelay(1000);
+				GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Blue);
+				OSA_TimeDelay(1000);
+				GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Blue);
+				OSA_TimeDelay(1000);
+				SEGGER_RTT_printf(0, "\n\nFilling memory");
+
+				for (uint16_t i = 0; i < sizeof(KL03MemoryFill.memoryFillingBuffer); i++)
+				{
+					if(i % 2 == 0)
+					{
+						KL03MemoryFill.memoryFillingBuffer[i] = kWarpThermalChamberMemoryFillEvenComponent;
+					}
+					if(i % 2 != 0)
+					{
+						KL03MemoryFill.memoryFillingBuffer[i] = kWarpThermalChamberMemoryFillOddComponent;
+					}
+				}
+
+				uint8_t checkSumValue = checkSum(KL03MemoryFill.memoryFillingBuffer,
+								sizeof(KL03MemoryFill.memoryFillingBuffer));
+
+
+				while (1)
+				{
+					/*
+					 *	(1) addAndMultiplicationLoop performs basic multiplication and addition
+					 *	(2) bit-wise toggling and checksum operations are performed
+					 *	(3) checking the I2C read and write status
+					 */
+
+					GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Green);
+					GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Red);
+					GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Blue);
+					OSA_TimeDelay(100);
+
+					addAndMultiplicationBusyLoop(kWarpThermalChamberBusyLoopCountOffset);
+
+					/*
+					 *	Error-less operation
+					 *	LED pattern : Blue -> Red -> Blue
+					 */
+					GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Blue);
+					GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Red);
+					GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Green);
+					OSA_TimeDelay(100);
+					GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Red);
+					GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Blue);
+					GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Green);
+					OSA_TimeDelay(100);
+					GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Blue);
+					GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Red);
+					GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Green);
+					OSA_TimeDelay(100);
+
+					for(uint16_t j = 0; j < sizeof(KL03MemoryFill.memoryFillingBuffer); j++)
+					{
+						KL03MemoryFill.memoryFillingBuffer[j] = ~KL03MemoryFill.memoryFillingBuffer[j];
+					}
+					SEGGER_RTT_printf(0, "\nBit-wise flip");
+
+					uint8_t checkSumValueOnline = checkSum(KL03MemoryFill.memoryFillingBuffer,
+										sizeof(KL03MemoryFill.memoryFillingBuffer));
+					if(checkSumValue == checkSumValueOnline)
+					{
+						i2cWriteStatusA = writeSensorRegisterMMA8451Q(0x09 /* register address F_SETUP */,
+												0x00 /* payload: Disable FIFO */,
+												1);
+
+						i2cWriteStatusB = writeSensorRegisterMMA8451Q(0x2A /* register address */,
+												0x03 /* payload: Enable fast read 8bit, 800Hz, normal, active mode */,
+												1);
+						SEGGER_RTT_printf(0, "\nWriting to I2C device");
+						if((i2cWriteStatusA != kWarpStatusOK) && (i2cWriteStatusB != kWarpStatusOK))
+						{
+							SEGGER_RTT_printf(0, "\nError when writing to I2C device");
+							for(int errorLED = 0; errorLED < 5; errorLED++)
+							{
+								/*
+								 *	Error when writing to I2C device
+								 *	LED pattern : All On -> All off -> Red
+								 */
+								GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Red);
+								GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Blue);
+								GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Green);
+								OSA_TimeDelay(100);
+								GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Red);
+								GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Blue);
+								GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Green);
+								OSA_TimeDelay(100);
+								GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Red);
+								OSA_TimeDelay(1000);
+							}
+						}
+
+						i2cReadStatusX = readSensorRegisterMMA8451Q(0x01);
+						if(i2cReadStatusX == kWarpStatusOK)
+						{
+							KL03MemoryFill.outputBuffer[0] = deviceMMA8451QState.i2cBuffer[0];
+							SEGGER_RTT_printf(0, "\nReading from sensor X: %d", KL03MemoryFill.outputBuffer[0]);
+
+							i2cReadStatusY = readSensorRegisterMMA8451Q(0x03);
+							if(i2cReadStatusY == kWarpStatusOK)
+							{
+								KL03MemoryFill.outputBuffer[1] = deviceMMA8451QState.i2cBuffer[0];
+								SEGGER_RTT_printf(0, "\nReading from sensor Y: %d", KL03MemoryFill.outputBuffer[1]);
+
+								i2cReadStatusZ = readSensorRegisterMMA8451Q(0x05);
+								if(i2cReadStatusZ == kWarpStatusOK)
+								{
+									KL03MemoryFill.outputBuffer[2] = deviceMMA8451QState.i2cBuffer[0];
+									SEGGER_RTT_printf(0, "\nReading from sensor Z: %d", KL03MemoryFill.outputBuffer[2]);
+								}
+							}
+						}
+
+						if((i2cReadStatusX != kWarpStatusOK) && (i2cReadStatusY != kWarpStatusOK) &&
+								(i2cReadStatusZ != kWarpStatusOK))
+						{
+							SEGGER_RTT_printf(0, "\nError when reading from I2C device");
+							for(int errorLED = 0; errorLED < 5; errorLED++)
+							{
+								/*
+								 *	Error when reading from I2C device
+								 *	LED pattern : Red -> All off
+								 */
+								GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Red);
+								GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Blue);
+								GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Green);
+								OSA_TimeDelay(100);
+								GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Red);
+								GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Blue);
+								GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Green);
+								OSA_TimeDelay(100);
+							}
+						}
+						else
+						{
+							KL03MemoryFill.outputBuffer[0] = 0;
+							KL03MemoryFill.outputBuffer[1] = 0;
+							KL03MemoryFill.outputBuffer[2] = 0;
+						}
+					}
+					else
+					{
+						while(1)
+						{
+							/*
+							 *	Error in checksum leading to error in bit wise operation
+							 *	LED pattern : Red -> All off
+							 */
+							SEGGER_RTT_printf(0, "\nError in checksum");
+							GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Red);
+							GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Blue);
+							GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Green);
+							OSA_TimeDelay(100);
+							GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Red);
+							OSA_TimeDelay(100);
+
+							SEGGER_RTT_printf(0, "\nWriting to I2C device");
+							i2cWriteStatusA = writeSensorRegisterMMA8451Q(0x09 /* register address F_SETUP */,
+												0x00 /* payload: Disable FIFO */,
+												1);
+
+							i2cWriteStatusB = writeSensorRegisterMMA8451Q(0x2A /* register address */,
+												0x03 /* payload: Enable fast read 8bit, 800Hz, normal, active mode */,
+												1);
+
+							if((i2cWriteStatusA != kWarpStatusOK) && (i2cWriteStatusB != kWarpStatusOK))
+							{
+								SEGGER_RTT_printf(0, "\nError when writing to I2C device");
+								for(int errorLED = 0; errorLED < 5; errorLED++)
+								{
+									/*
+									 *	Error when writing to I2C device
+									 *	LED pattern : All On -> All off -> Red
+									 */
+									GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Red);
+									GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Blue);
+									GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Green);
+									OSA_TimeDelay(100);
+									GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Red);
+									GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Blue);
+									GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Green);
+									OSA_TimeDelay(100);
+									GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Red);
+									OSA_TimeDelay(1000);
+								}
+							}
+
+							i2cReadStatusX = readSensorRegisterMMA8451Q(0x01);
+							if(i2cReadStatusX == kWarpStatusOK)
+							{
+								KL03MemoryFill.outputBuffer[0] = deviceMMA8451QState.i2cBuffer[0];
+								SEGGER_RTT_printf(0, "\nReading from sensor X: %d", KL03MemoryFill.outputBuffer[0]);
+
+								i2cReadStatusY = readSensorRegisterMMA8451Q(0x03);
+								if(i2cReadStatusY == kWarpStatusOK)
+								{
+									KL03MemoryFill.outputBuffer[1] = deviceMMA8451QState.i2cBuffer[0];
+									SEGGER_RTT_printf(0, "\nReading from sensor Y: %d", KL03MemoryFill.outputBuffer[1]);
+
+									i2cReadStatusZ = readSensorRegisterMMA8451Q(0x05);
+									if(i2cReadStatusZ == kWarpStatusOK)
+									{
+										KL03MemoryFill.outputBuffer[2] = deviceMMA8451QState.i2cBuffer[0];
+										SEGGER_RTT_printf(0, "\nReading from sensor Z: %d", KL03MemoryFill.outputBuffer[2]);
+									}
+								}
+							}
+
+							if((i2cReadStatusX != kWarpStatusOK) && (i2cReadStatusY != kWarpStatusOK) &&
+								(i2cReadStatusZ != kWarpStatusOK))
+							{
+								SEGGER_RTT_printf(0, "\nError when reading from I2C device");
+								for(int errorLED = 0; errorLED < 5; errorLED++)
+								{
+									/*
+									 *	Error when reading from I2C device
+									 *	LED pattern : All on -> All off
+									 */
+									GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Red);
+									GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Blue);
+									GPIO_DRV_ClearPinOutput(kWarpPinFRDMKL03LED_Green);
+									OSA_TimeDelay(100);
+									GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Red);
+									GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Blue);
+									GPIO_DRV_SetPinOutput(kWarpPinFRDMKL03LED_Green);
+									OSA_TimeDelay(100);
+								}
+							}
+						}
+					}
+				}
+				disableI2Cpins();
+
+				break;
+			}
+#endif
+			/*
+			 *	Dump all the sensor data in one go
+			 */
+			case 'z':
+			{
+				bool		hexModeFlag;
+
+				SEGGER_RTT_WriteString(0, "\r\n\tEnabling I2C pins...\n");
+				enableI2Cpins(menuI2cPullupValue);
+
+				SEGGER_RTT_WriteString(0, "\r\n\tHex or converted mode? ('h' or 'c')> ");
+				key = SEGGER_RTT_WaitKey();
+				hexModeFlag = (key == 'h' ? 1 : 0);
+
+				SEGGER_RTT_WriteString(0, "\r\n\tSet the time delay between each run in milliseconds (e.g., '1234')> ");
+				uint16_t	menuDelayBetweenEachRun = read4digits();
+				SEGGER_RTT_printf(0, "\r\n\tDelay between read batches set to %d milliseconds.\n\n", menuDelayBetweenEachRun);
+				OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+				printAllSensors(true /* printHeadersAndCalibration */, hexModeFlag, menuDelayBetweenEachRun, menuI2cPullupValue);
+
+				/*
+				 *	Not reached (printAllSensors() does not return)
+				 */
+				disableI2Cpins();
+
+				break;
+			}
+
+
+			/*
+			 *	Ignore naked returns.
+			 */
+			case '\n':
+			{
+				SEGGER_RTT_WriteString(0, "\r\tPayloads make rockets more than just fireworks.");
+				break;
+			}
+
+			default:
+			{
+				#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+				SEGGER_RTT_printf(0, "\r\tInvalid selection '%c' !\n", key);
+				#endif
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+
+void
+printAllSensors(bool printHeadersAndCalibration, bool hexModeFlag, int menuDelayBetweenEachRun, int i2cPullupValue)
+{
+	/*
+	 *	A 32-bit counter gives us > 2 years of before it wraps, even if sampling at 60fps
+	 */
+	uint32_t	readingCount = 0;
+	uint32_t	numberOfConfigErrors = 0;
+
+
+	#ifdef WARP_BUILD_ENABLE_DEVAMG8834
+	numberOfConfigErrors += configureSensorAMG8834(	0x3F,/* Initial reset */
+					0x01,/* Frame rate 1 FPS */
+					i2cPullupValue
+					);
+	#endif
+	#ifdef WARP_BUILD_ENABLE_DEVMMA8451Q
+	numberOfConfigErrors += configureSensorMMA8451Q(0x00,/* Payload: Disable FIFO */
+					0x01,/* Normal read 8bit, 800Hz, normal, active mode */
+					i2cPullupValue
+					);
+	#endif
+	#ifdef WARP_BUILD_ENABLE_DEVMAG3110
+	numberOfConfigErrors += configureSensorMAG3110(	0x00,/*	Payload: DR 000, OS 00, 80Hz, ADC 1280, Full 16bit, standby mode to set up register*/
+					0xA0,/*	Payload: AUTO_MRST_EN enable, RAW value without offset */
+					i2cPullupValue
+					);
+	#endif
+	#ifdef WARP_BUILD_ENABLE_DEVL3GD20H
+	numberOfConfigErrors += configureSensorL3GD20H(	0b11111111,/* ODR 800Hz, Cut-off 100Hz, see table 21, normal mode, x,y,z enable */
+					0b00100000,
+					0b00000000,/* normal mode, disable FIFO, disable high pass filter */
+					i2cPullupValue
+					);
+	#endif
+	#ifdef WARP_BUILD_ENABLE_DEVBME680
+	numberOfConfigErrors += configureSensorBME680(	0b00000001,	/*	Humidity oversampling (OSRS) to 1x				*/
+							0b00100100,	/*	Temperature oversample 1x, pressure overdsample 1x, mode 00	*/
+							0b00001000,	/*	Turn off heater							*/
+							i2cPullupValue
+					);
+
+	if (printHeadersAndCalibration)
+	{
+		SEGGER_RTT_WriteString(0, "\r\n\nBME680 Calibration Data: ");
+		for (uint8_t i = 0; i < kWarpSizesBME680CalibrationValuesCount; i++)
+		{
+			#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+			SEGGER_RTT_printf(0, "0x%02x", deviceBME680CalibrationValues[i]);
+			if (i < kWarpSizesBME680CalibrationValuesCount - 1)
+			{
+				SEGGER_RTT_WriteString(0, ", ");
+			}
+			else
+			{
+				SEGGER_RTT_WriteString(0, "\n\n");
+			}
+
+			OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+			#endif
+		}
+	}
+	#endif
+
+	#ifdef WARP_BUILD_ENABLE_DEVHDC1000
+	numberOfConfigErrors += writeSensorRegisterHDC1000(kWarpSensorConfigurationRegisterHDC1000Configuration,/* Configuration register	*/
+					(0b1000000<<8),
+					i2cPullupValue
+					);
+	#endif
+
+	#ifdef WARP_BUILD_ENABLE_DEVCCS811
+	uint8_t		payloadCCS811[1];
+	payloadCCS811[0] = 0b01000000;/* Constant power, measurement every 250ms */
+	numberOfConfigErrors += configureSensorCCS811(payloadCCS811,
+					i2cPullupValue
+					);
+	#endif
+	#ifdef WARP_BUILD_ENABLE_DEVBMX055
+	numberOfConfigErrors += configureSensorBMX055accel(0b00000011,/* Payload:+-2g range */
+					0b10000000,/* Payload:unfiltered data, shadowing enabled */
+					i2cPullupValue
+					);
+	numberOfConfigErrors += configureSensorBMX055mag(0b00000001,/* Payload:from suspend mode to sleep mode*/
+					0b00000001,/* Default 10Hz data rate, forced mode*/
+					i2cPullupValue
+					);
+	numberOfConfigErrors += configureSensorBMX055gyro(0b00000100,/* +- 125degrees/s */
+					0b00000000,/* ODR 2000 Hz, unfiltered */
+					0b00000000,/* normal mode */
+					0b10000000,/* unfiltered data, shadowing enabled */
+					i2cPullupValue
+					);
+	#endif
+
+
+	if (printHeadersAndCalibration)
+	{
+		SEGGER_RTT_WriteString(0, "Measurement number, RTC->TSR, RTC->TPR,");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+
+		#ifdef WARP_BUILD_ENABLE_DEVAMG8834
+		for (uint8_t i = 0; i < 64; i++)
+		{
+			#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+			SEGGER_RTT_printf(0, " AMG8834 %d,", i);
+			OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+			#endif
+		}
+		SEGGER_RTT_WriteString(0, " AMG8834 Temp,");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		#endif
+
+		#ifdef WARP_BUILD_ENABLE_DEVMMA8451Q
+		SEGGER_RTT_WriteString(0, " MMA8451 x, MMA8451 y, MMA8451 z,");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		#endif
+		#ifdef WARP_BUILD_ENABLE_DEVMAG3110
+		SEGGER_RTT_WriteString(0, " MAG3110 x, MAG3110 y, MAG3110 z, MAG3110 Temp,");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		#endif
+		#ifdef WARP_BUILD_ENABLE_DEVL3GD20H
+		SEGGER_RTT_WriteString(0, " L3GD20H x, L3GD20H y, L3GD20H z, L3GD20H Temp,");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		#endif
+		#ifdef WARP_BUILD_ENABLE_DEVBME680
+		SEGGER_RTT_WriteString(0, " BME680 Press, BME680 Temp, BME680 Hum,");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		#endif
+		#ifdef WARP_BUILD_ENABLE_DEVBMX055
+		SEGGER_RTT_WriteString(0, " BMX055acc x, BMX055acc y, BMX055acc z, BMX055acc Temp,");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, " BMX055mag x, BMX055mag y, BMX055mag z, BMX055mag RHALL,");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, " BMX055gyro x, BMX055gyro y, BMX055gyro z,");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		#endif
+		#ifdef WARP_BUILD_ENABLE_DEVCCS811
+		SEGGER_RTT_WriteString(0, " CCS811 ECO2, CCS811 TVOC, CCS811 RAW ADC value, CCS811 RAW R_REF value, CCS811 RAW R_NTC value,");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		#endif
+		#ifdef WARP_BUILD_ENABLE_DEVHDC1000
+		SEGGER_RTT_WriteString(0, " HDC1000 Temp, HDC1000 Hum,");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		#endif
+		SEGGER_RTT_WriteString(0, " RTC->TSR, RTC->TPR, # Config Errors");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+		SEGGER_RTT_WriteString(0, "\n\n");
+		OSA_TimeDelay(gWarpMenuPrintDelayMilliseconds);
+	}
+
+
+	while(1)
+	{
+		#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+		SEGGER_RTT_printf(0, "%u, %d, %d,", readingCount, RTC->TSR, RTC->TPR);
+		#endif
+
+		#ifdef WARP_BUILD_ENABLE_DEVAMG8834
+		printSensorDataAMG8834(hexModeFlag);
+		#endif
+		#ifdef WARP_BUILD_ENABLE_DEVMMA8451Q
+		printSensorDataMMA8451Q(hexModeFlag);
+		#endif
+		#ifdef WARP_BUILD_ENABLE_DEVMAG3110
+		printSensorDataMAG3110(hexModeFlag);
+		#endif
+		#ifdef WARP_BUILD_ENABLE_DEVL3GD20H
+		printSensorDataL3GD20H(hexModeFlag);
+		#endif
+		#ifdef WARP_BUILD_ENABLE_DEVBME680
+		printSensorDataBME680(hexModeFlag);
+		#endif
+		#ifdef WARP_BUILD_ENABLE_DEVBMX055
+		printSensorDataBMX055accel(hexModeFlag);
+		printSensorDataBMX055mag(hexModeFlag);
+		printSensorDataBMX055gyro(hexModeFlag);
+		#endif
+		#ifdef WARP_BUILD_ENABLE_DEVCCS811
+		printSensorDataCCS811(hexModeFlag);
+		#endif
+		#ifdef WARP_BUILD_ENABLE_DEVHDC1000
+		printSensorDataHDC1000(hexModeFlag);
+		#endif
+
+
+		#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+		SEGGER_RTT_printf(0, " %d, %d, %d\n", RTC->TSR, RTC->TPR, numberOfConfigErrors);
+		#endif
+
+		if (menuDelayBetweenEachRun > 0)
+		{
+			OSA_TimeDelay(menuDelayBetweenEachRun);
+		}
+
+		readingCount++;
+	}
+}
+
+
+void
+loopForSensor(	const char *  tagString,
+		WarpStatus  (* readSensorRegisterFunction)(uint8_t deviceRegister, int numberOfBytes),
+		volatile WarpI2CDeviceState *  i2cDeviceState,
+		volatile WarpSPIDeviceState *  spiDeviceState,
+		uint8_t  baseAddress,
+		uint8_t  minAddress,
+		uint8_t  maxAddress,
+		int  repetitionsPerAddress,
+		int  chunkReadsPerAddress,
+		int  spinDelay,
+		bool  autoIncrement,
+		uint16_t  sssupplyMillivolts,
+		uint8_t  referenceByte,
+		uint16_t adaptiveSssupplyMaxMillivolts,
+		bool  chatty
+		)
+{
+	WarpStatus		status;
+	uint8_t			address;
+	if((minAddress < baseAddress) || (baseAddress <= maxAddress))
+	{
+		 address = baseAddress;
+	}
+	else
+	{
+		address = minAddress;
+	}
+	int			readCount = repetitionsPerAddress + 1;
+	int			nSuccesses = 0;
+	int			nFailures = 0;
+	int			nCorrects = 0;
+	int			nBadCommands = 0;
+	uint16_t		actualSssupplyMillivolts = sssupplyMillivolts;
+
+
+	if (	(!spiDeviceState && !i2cDeviceState) ||
+		(spiDeviceState && i2cDeviceState) )
+	{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+		SEGGER_RTT_printf(0, RTT_CTRL_RESET RTT_CTRL_BG_BRIGHT_YELLOW RTT_CTRL_TEXT_BRIGHT_WHITE kWarpConstantStringErrorSanity RTT_CTRL_RESET "\n");
+#endif
+	}
+
+	enableSssupply(actualSssupplyMillivolts);
+	SEGGER_RTT_WriteString(0, tagString);
+
+	/*
+	 *	Keep on repeating until we are above the maxAddress, or just once if not autoIncrement-ing
+	 *	This is checked for at the tail end of the loop.
+	 */
+	while (true)
+	{
+		for (int i = 0; i < readCount; i++) for (int j = 0; j < chunkReadsPerAddress; j++)
+		{
+			status = readSensorRegisterFunction(address+j, 1 /* numberOfBytes */);
+			if (status == kWarpStatusOK)
+			{
+				nSuccesses++;
+				if (actualSssupplyMillivolts > sssupplyMillivolts)
+				{
+					actualSssupplyMillivolts -= 100;
+					enableSssupply(actualSssupplyMillivolts);
+				}
+
+				if (spiDeviceState)
+				{
+					if (referenceByte == spiDeviceState->spiSinkBuffer[2])
+					{
+						nCorrects++;
+					}
+
+					if (chatty)
+					{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+						SEGGER_RTT_printf(0, "\r\t0x%02x --> [0x%02x 0x%02x 0x%02x]\n",
+							address+j,
+							spiDeviceState->spiSinkBuffer[0],
+							spiDeviceState->spiSinkBuffer[1],
+							spiDeviceState->spiSinkBuffer[2]);
+#endif
+					}
+				}
+				else
+				{
+					if (referenceByte == i2cDeviceState->i2cBuffer[0])
+					{
+						nCorrects++;
+					}
+
+					if (chatty)
+					{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+						SEGGER_RTT_printf(0, "\r\t0x%02x --> 0x%02x\n",
+							address+j,
+							i2cDeviceState->i2cBuffer[0]);
+#endif
+					}
+				}
+			}
+			else if (status == kWarpStatusDeviceCommunicationFailed)
+			{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+				SEGGER_RTT_printf(0, "\r\t0x%02x --> ----\n",
+					address+j);
+#endif
+
+				nFailures++;
+				if (actualSssupplyMillivolts < adaptiveSssupplyMaxMillivolts)
+				{
+					actualSssupplyMillivolts += 100;
+					enableSssupply(actualSssupplyMillivolts);
+				}
+			}
+			else if (status == kWarpStatusBadDeviceCommand)
+			{
+				nBadCommands++;
+			}
+
+			if (spinDelay > 0)
+			{
+				OSA_TimeDelay(spinDelay);
+			}
+		}
+
+		if (autoIncrement)
+		{
+			address++;
+		}
+
+		if (address > maxAddress || !autoIncrement)
+		{
+			/*
+			 *	We either iterated over all possible addresses, or were asked to do only
+			 *	one address anyway (i.e. don't increment), so we're done.
+			 */
+			break;
+		}
+	}
+
+	/*
+	 *	We intersperse RTT_printfs with forced delays to allow us to use small
+	 *	print buffers even in RUN mode.
+	 */
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+	SEGGER_RTT_printf(0, "\r\n\t%d/%d success rate.\n", nSuccesses, (nSuccesses + nFailures));
+	OSA_TimeDelay(50);
+	SEGGER_RTT_printf(0, "\r\t%d/%d successes matched ref. value of 0x%02x.\n", nCorrects, nSuccesses, referenceByte);
+	OSA_TimeDelay(50);
+	SEGGER_RTT_printf(0, "\r\t%d bad commands.\n\n", nBadCommands);
+	OSA_TimeDelay(50);
+#endif
+
+
+	return;
+}
+
+
+
+void
+repeatRegisterReadForDeviceAndAddress(WarpSensorDevice warpSensorDevice, uint8_t baseAddress, uint8_t pullupValue, bool autoIncrement, int chunkReadsPerAddress, bool chatty, int spinDelay, int repetitionsPerAddress, uint16_t sssupplyMillivolts, uint16_t adaptiveSssupplyMaxMillivolts, uint8_t referenceByte)
+{
+	if (warpSensorDevice != kWarpSensorADXL362)
+	{
+		enableI2Cpins(pullupValue);
+	}
+
+	switch (warpSensorDevice)
+	{
+		case kWarpSensorADXL362:
+		{
+			/*
+			 *	ADXL362: VDD 1.6--3.5
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVADXL362
+			loopForSensor(	"\r\nADXL362:\n\r",		/*	tagString			*/
+					&readSensorRegisterADXL362,	/*	readSensorRegisterFunction	*/
+					NULL,				/*	i2cDeviceState			*/
+					&deviceADXL362State,		/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x00,				/*	minAddress			*/
+					0x2E,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\tADXL362 Read Aborted. Device Disabled :(");
+#endif
+			break;
+		}
+
+		case kWarpSensorMMA8451Q:
+		{
+			/*
+			 *	MMA8451Q: VDD 1.95--3.6
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVMMA8451Q
+			loopForSensor(	"\r\nMMA8451Q:\n\r",		/*	tagString			*/
+					&readSensorRegisterMMA8451Q,	/*	readSensorRegisterFunction	*/
+					&deviceMMA8451QState,		/*	i2cDeviceState			*/
+					NULL,				/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x00,				/*	minAddress			*/
+					0x31,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\tMMA8451Q Read Aborted. Device Disabled :(");
+#endif
+			break;
+		}
+
+		case kWarpSensorBME680:
+		{
+			/*
+			 *	BME680: VDD 1.7--3.6
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVBME680
+			loopForSensor(	"\r\nBME680:\n\r",		/*	tagString			*/
+					&readSensorRegisterBME680,	/*	readSensorRegisterFunction	*/
+					&deviceBME680State,		/*	i2cDeviceState			*/
+					NULL,				/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x1D,				/*	minAddress			*/
+					0x75,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\nBME680 Read Aborted. Device Disabled :(");
+#endif
+			break;
+		}
+
+		case kWarpSensorBMX055accel:
+		{
+			/*
+			 *	BMX055accel: VDD 2.4V -- 3.6V
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVBMX055
+			loopForSensor(	"\r\nBMX055accel:\n\r",		/*	tagString			*/
+					&readSensorRegisterBMX055accel,	/*	readSensorRegisterFunction	*/
+					&deviceBMX055accelState,	/*	i2cDeviceState			*/
+					NULL,				/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x00,				/*	minAddress			*/
+					0x39,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\tBMX055accel Read Aborted. Device Disabled :( ");
+#endif
+			break;
+		}
+
+		case kWarpSensorBMX055gyro:
+		{
+			/*
+			 *	BMX055gyro: VDD 2.4V -- 3.6V
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVBMX055
+			loopForSensor(	"\r\nBMX055gyro:\n\r",		/*	tagString			*/
+					&readSensorRegisterBMX055gyro,	/*	readSensorRegisterFunction	*/
+					&deviceBMX055gyroState,		/*	i2cDeviceState			*/
+					NULL,				/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x00,				/*	minAddress			*/
+					0x39,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\tBMX055gyro Read Aborted. Device Disabled :( ");
+#endif
+			break;
+		}
+
+		case kWarpSensorBMX055mag:
+		{
+			/*
+			 *	BMX055mag: VDD 2.4V -- 3.6V
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVBMX055
+			loopForSensor(	"\r\nBMX055mag:\n\r",		/*	tagString			*/
+					&readSensorRegisterBMX055mag,	/*	readSensorRegisterFunction	*/
+					&deviceBMX055magState,		/*	i2cDeviceState			*/
+					NULL,				/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x40,				/*	minAddress			*/
+					0x52,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\t BMX055mag Read Aborted. Device Disabled :( ");
+#endif
+			break;
+		}
+
+		case kWarpSensorMAG3110:
+		{
+			/*
+			 *	MAG3110: VDD 1.95 -- 3.6
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVMAG3110
+			loopForSensor(	"\r\nMAG3110:\n\r",		/*	tagString			*/
+					&readSensorRegisterMAG3110,	/*	readSensorRegisterFunction	*/
+					&deviceMAG3110State,		/*	i2cDeviceState			*/
+					NULL,				/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x00,				/*	minAddress			*/
+					0x11,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\tMAG3110 Read Aborted. Device Disabled :( ");
+#endif
+			break;
+		}
+
+		case kWarpSensorL3GD20H:
+		{
+			/*
+			 *	L3GD20H: VDD 2.2V -- 3.6V
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVL3GD20H
+			loopForSensor(	"\r\nL3GD20H:\n\r",		/*	tagString			*/
+					&readSensorRegisterL3GD20H,	/*	readSensorRegisterFunction	*/
+					&deviceL3GD20HState,		/*	i2cDeviceState			*/
+					NULL,				/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x0F,				/*	minAddress			*/
+					0x39,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\tL3GD20H Read Aborted. Device Disabled :( ");
+#endif
+			break;
+		}
+
+		case kWarpSensorLPS25H:
+		{
+			/*
+			 *	LPS25H: VDD 1.7V -- 3.6V
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVLPS25H
+			loopForSensor(	"\r\nLPS25H:\n\r",		/*	tagString			*/
+					&readSensorRegisterLPS25H,	/*	readSensorRegisterFunction	*/
+					&deviceLPS25HState,		/*	i2cDeviceState			*/
+					NULL,				/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x08,				/*	minAddress			*/
+					0x24,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\tLPS25H Read Aborted. Device Disabled :( ");
+#endif
+			break;
+		}
+
+		case kWarpSensorTCS34725:
+		{
+			/*
+			 *	TCS34725: VDD 2.7V -- 3.3V
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVTCS34725
+			loopForSensor(	"\r\nTCS34725:\n\r",		/*	tagString			*/
+					&readSensorRegisterTCS34725,	/*	readSensorRegisterFunction	*/
+					&deviceTCS34725State,		/*	i2cDeviceState			*/
+					NULL,				/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x00,				/*	minAddress			*/
+					0x1D,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\tTCS34725 Read Aborted. Device Disabled :( ");
+#endif
+			break;
+		}
+
+		case kWarpSensorSI4705:
+		{
+			/*
+			 *	SI4705: VDD 2.7V -- 5.5V
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVSI4705
+			loopForSensor(	"\r\nSI4705:\n\r",		/*	tagString			*/
+					&readSensorRegisterSI4705,	/*	readSensorRegisterFunction	*/
+					&deviceSI4705State,		/*	i2cDeviceState			*/
+					NULL,				/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x00,				/*	minAddress			*/
+					0x09,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\tSI4705 Read Aborted. Device Disabled :( ");
+#endif
+			break;
+		}
+
+		case kWarpSensorHDC1000:
+		{
+			/*
+			 *	HDC1000: VDD 3V--5V
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVHDC1000
+			loopForSensor(	"\r\nHDC1000:\n\r",		/*	tagString			*/
+					&readSensorRegisterHDC1000,	/*	readSensorRegisterFunction	*/
+					&deviceHDC1000State,		/*	i2cDeviceState			*/
+					NULL,				/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x00,				/*	minAddress			*/
+					0x1F,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\tHDC1000 Read Aborted. Device Disabled :( ");
+#endif
+			break;
+		}
+
+		case kWarpSensorSI7021:
+		{
+			/*
+			 *	SI7021: VDD 1.9V -- 3.6V
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVSI7021
+			loopForSensor(	"\r\nSI7021:\n\r",		/*	tagString			*/
+					&readSensorRegisterSI7021,	/*	readSensorRegisterFunction	*/
+					&deviceSI7021State,		/*	i2cDeviceState			*/
+					NULL,				/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x00,				/*	minAddress			*/
+					0x09,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\tSI7021 Read Aborted. Device Disabled :( ");
+#endif
+			break;
+		}
+
+		case kWarpSensorCCS811:
+		{
+			/*
+			 *	CCS811: VDD 1.8V -- 3.6V
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVCCS811
+			loopForSensor(	"\r\nCCS811:\n\r",		/*	tagString			*/
+					&readSensorRegisterCCS811,	/*	readSensorRegisterFunction	*/
+					&deviceCCS811State,		/*	i2cDeviceState			*/
+					NULL,				/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x00,				/*	minAddress			*/
+					0xFF,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\tCCS811 Read Aborted. Device Disabled :( ");
+#endif
+			break;
+		}
+
+		case kWarpSensorAMG8834:
+		{
+			/*
+			 *	AMG8834: VDD ?V -- ?V
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVAMG8834
+			loopForSensor(	"\r\nAMG8834:\n\r",		/*	tagString			*/
+					&readSensorRegisterAMG8834,	/*	readSensorRegisterFunction	*/
+					&deviceAMG8834State,		/*	i2cDeviceState			*/
+					NULL,				/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x00,				/*	minAddress			*/
+					0xFF,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\tAMG8834 Read Aborted. Device Disabled :( ");
+#endif
+			break;
+		}
+
+		case kWarpSensorAS7262:
+		{
+			/*
+			 *	AS7262: VDD 2.7--3.6
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVAS7262
+			loopForSensor(	"\r\nAS7262:\n\r",		/*	tagString			*/
+					&readSensorRegisterAS7262,	/*	readSensorRegisterFunction	*/
+					&deviceAS7262State,		/*	i2cDeviceState			*/
+					NULL,				/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x00,				/*	minAddress			*/
+					0x2B,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\tAS7262 Read Aborted. Device Disabled :( ");
+#endif
+			break;
+		}
+
+		case kWarpSensorAS7263:
+		{
+			/*
+			 *	AS7263: VDD 2.7--3.6
+			 */
+#ifdef WARP_BUILD_ENABLE_DEVAS7263
+			loopForSensor(	"\r\nAS7263:\n\r",		/*	tagString			*/
+					&readSensorRegisterAS7263,	/*	readSensorRegisterFunction	*/
+					&deviceAS7263State,		/*	i2cDeviceState			*/
+					NULL,				/*	spiDeviceState			*/
+					baseAddress,			/*	baseAddress			*/
+					0x00,				/*	minAddress			*/
+					0x2B,				/*	maxAddress			*/
+					repetitionsPerAddress,		/*	repetitionsPerAddress		*/
+					chunkReadsPerAddress,		/*	chunkReadsPerAddress		*/
+					spinDelay,			/*	spinDelay			*/
+					autoIncrement,			/*	autoIncrement			*/
+					sssupplyMillivolts,		/*	sssupplyMillivolts		*/
+					referenceByte,			/*	referenceByte			*/
+					adaptiveSssupplyMaxMillivolts,	/*	adaptiveSssupplyMaxMillivolts	*/
+					chatty				/*	chatty				*/
+					);
+			#else
+			SEGGER_RTT_WriteString(0, "\r\n\tAS7263 Read Aborted. Device Disabled :( ");
+#endif
+			break;
+		}
+
+		default:
+		{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+			SEGGER_RTT_printf(0, "\r\tInvalid warpSensorDevice [%d] passed to repeatRegisterReadForDeviceAndAddress.\n", warpSensorDevice);
+#endif
+		}
+	}
+
+	if (warpSensorDevice != kWarpSensorADXL362)
+	{
+		disableI2Cpins();
+	}
+}
+
+
+
+int
+char2int(int character)
+{
+	if (character >= '0' && character <= '9')
+	{
+		return character - '0';
+	}
+
+	if (character >= 'a' && character <= 'f')
+	{
+		return character - 'a' + 10;
+	}
+
+	if (character >= 'A' && character <= 'F')
+	{
+		return character - 'A' + 10;
+	}
+
+	return 0;
+}
+
+
+
+uint8_t
+readHexByte(void)
+{
+	uint8_t		topNybble, bottomNybble;
+
+	topNybble = SEGGER_RTT_WaitKey();
+	bottomNybble = SEGGER_RTT_WaitKey();
+
+	return (char2int(topNybble) << 4) + char2int(bottomNybble);
+}
+
+
+
+int
+read4digits(void)
+{
+	uint8_t		digit1, digit2, digit3, digit4;
+
+	digit1 = SEGGER_RTT_WaitKey();
+	digit2 = SEGGER_RTT_WaitKey();
+	digit3 = SEGGER_RTT_WaitKey();
+	digit4 = SEGGER_RTT_WaitKey();
+
+	return (digit1 - '0')*1000 + (digit2 - '0')*100 + (digit3 - '0')*10 + (digit4 - '0');
+}
+
+
+
+WarpStatus
+writeByteToI2cDeviceRegister(uint8_t i2cAddress, bool sendCommandByte, uint8_t commandByte, bool sendPayloadByte, uint8_t payloadByte)
+{
+	i2c_status_t	status;
+	uint8_t		commandBuffer[1];
+	uint8_t		payloadBuffer[1];
+	i2c_device_t	i2cSlaveConfig =
+			{
+				.address = i2cAddress,
+				.baudRate_kbps = gWarpI2cBaudRateKbps
+			};
+
+	commandBuffer[0] = commandByte;
+	payloadBuffer[0] = payloadByte;
+
+	status = I2C_DRV_MasterSendDataBlocking(
+						0	/* instance */,
+						&i2cSlaveConfig,
+						commandBuffer,
+						(sendCommandByte ? 1 : 0),
+						payloadBuffer,
+						(sendPayloadByte ? 1 : 0),
+						gWarpI2cTimeoutMilliseconds);
+
+	return (status == kStatus_I2C_Success ? kWarpStatusOK : kWarpStatusDeviceCommunicationFailed);
+}
+
+
+
+WarpStatus
+writeBytesToSpi(uint8_t *  payloadBytes, int payloadLength)
+{
+	uint8_t		inBuffer[payloadLength];
+	spi_status_t	status;
+
+	enableSPIpins();
+	status = SPI_DRV_MasterTransferBlocking(0		/* master instance */,
+						NULL		/* spi_master_user_config_t */,
+						payloadBytes,
+						inBuffer,
+						payloadLength	/* transfer size */,
+						1000		/* timeout in microseconds (unlike I2C which is ms) */);
+	disableSPIpins();
+
+	return (status == kStatus_SPI_Success ? kWarpStatusOK : kWarpStatusCommsError);
+}
+
+
+
+void
+powerupAllSensors(void)
+{
+	WarpStatus	status;
+
+	/*
+	 *	BMX055mag
+	 *
+	 *	Write '1' to power control bit of register 0x4B. See page 134.
+	 */
+#ifdef WARP_BUILD_ENABLE_DEVBMX055
+	status = writeByteToI2cDeviceRegister(	deviceBMX055magState.i2cAddress		/*	i2cAddress		*/,
+						true					/*	sendCommandByte		*/,
+						0x4B					/*	commandByte		*/,
+						true					/*	sendPayloadByte		*/,
+						(1 << 0)				/*	payloadByte		*/);
+	if (status != kWarpStatusOK)
+	{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+		SEGGER_RTT_printf(0, "\r\tPowerup command failed, code=%d, for BMX055mag @ 0x%02x.\n", status, deviceBMX055magState.i2cAddress);
+#endif
+	}
+	#else
+	SEGGER_RTT_WriteString(0, "\r\tPowerup command failed. BMX055 disabled \n");
+#endif
+}
+
+
+
+void
+activateAllLowPowerSensorModes(bool verbose)
+{
+	WarpStatus	status;
+
+
+
+	/*
+	 *	ADXL362:	See Power Control Register (Address: 0x2D, Reset: 0x00).
+	 *
+	 *	POR values are OK.
+	 */
+
+
+
+	/*
+	 *	BMX055accel: At POR, device is in Normal mode. Move it to Deep Suspend mode.
+	 *
+	 *	Write '1' to deep suspend bit of register 0x11, and write '0' to suspend bit of register 0x11. See page 23.
+	 */
+#ifdef WARP_BUILD_ENABLE_DEVBMX055
+	status = writeByteToI2cDeviceRegister(	deviceBMX055accelState.i2cAddress	/*	i2cAddress		*/,
+						true					/*	sendCommandByte		*/,
+						0x11					/*	commandByte		*/,
+						true					/*	sendPayloadByte		*/,
+						(1 << 5)				/*	payloadByte		*/);
+	if ((status != kWarpStatusOK) && verbose)
+	{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+		SEGGER_RTT_printf(0, "\r\tPowerdown command failed, code=%d, for BMX055accel @ 0x%02x.\n", status, deviceBMX055accelState.i2cAddress);
+#endif
+	}
+	#else
+	SEGGER_RTT_WriteString(0, "\r\tPowerdown command abandoned. BMX055 disabled\n");
+#endif
+
+	/*
+	 *	BMX055gyro: At POR, device is in Normal mode. Move it to Deep Suspend mode.
+	 *
+	 *	Write '1' to deep suspend bit of register 0x11. See page 81.
+	 */
+#ifdef WARP_BUILD_ENABLE_DEVBMX055
+	status = writeByteToI2cDeviceRegister(	deviceBMX055gyroState.i2cAddress	/*	i2cAddress		*/,
+						true					/*	sendCommandByte		*/,
+						0x11					/*	commandByte		*/,
+						true					/*	sendPayloadByte		*/,
+						(1 << 5)				/*	payloadByte		*/);
+	if ((status != kWarpStatusOK) && verbose)
+	{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+		SEGGER_RTT_printf(0, "\r\tPowerdown command failed, code=%d, for BMX055gyro @ 0x%02x.\n", status, deviceBMX055gyroState.i2cAddress);
+#endif
+	}
+	#else
+	SEGGER_RTT_WriteString(0, "\r\tPowerdown command abandoned. BMX055 disabled\n");
+#endif
+
+
+
+	/*
+	 *	BMX055mag: At POR, device is in Suspend mode. See page 121.
+	 *
+	 *	POR state seems to be powered down.
+	 */
+
+
+
+	/*
+	 *	MMA8451Q: See 0x2B: CTRL_REG2 System Control 2 Register (page 43).
+	 *
+	 *	POR state seems to be not too bad.
+	 */
+
+
+
+	/*
+	 *	LPS25H: See Register CTRL_REG1, at address 0x20 (page 26).
+	 *
+	 *	POR state seems to be powered down.
+	 */
+
+
+
+	/*
+	 *	MAG3110: See Register CTRL_REG1 at 0x10. (page 19).
+	 *
+	 *	POR state seems to be powered down.
+	 */
+
+
+
+	/*
+	 *	HDC1000: currently can't turn it on (3V)
+	 */
+
+
+
+	/*
+	 *	SI7021: Can't talk to it correctly yet.
+	 */
+
+
+
+	/*
+	 *	L3GD20H: See CTRL1 at 0x20 (page 36).
+	 *
+	 *	POR state seems to be powered down.
+	 */
+#ifdef WARP_BUILD_ENABLE_DEVL3GD20H
+	status = writeByteToI2cDeviceRegister(	deviceL3GD20HState.i2cAddress	/*	i2cAddress		*/,
+						true				/*	sendCommandByte		*/,
+						0x20				/*	commandByte		*/,
+						true				/*	sendPayloadByte		*/,
+						0x00				/*	payloadByte		*/);
+	if ((status != kWarpStatusOK) && verbose)
+	{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+		SEGGER_RTT_printf(0, "\r\tPowerdown command failed, code=%d, for L3GD20H @ 0x%02x.\n", status, deviceL3GD20HState.i2cAddress);
+#endif
+	}
+	#else
+	SEGGER_RTT_WriteString(0, "\r\tPowerdown command abandoned. L3GD20H disabled\n");
+#endif
+
+
+
+	/*
+	 *	BME680: TODO
+	 */
+
+
+
+	/*
+	 *	TCS34725: By default, is in the "start" state (see page 9).
+	 *
+	 *	Make it go to sleep state. See page 17, 18, and 19.
+	 */
+#ifdef WARP_BUILD_ENABLE_DEVTCS34725
+	status = writeByteToI2cDeviceRegister(	deviceTCS34725State.i2cAddress	/*	i2cAddress		*/,
+						true				/*	sendCommandByte		*/,
+						0x00				/*	commandByte		*/,
+						true				/*	sendPayloadByte		*/,
+						0x00				/*	payloadByte		*/);
+	if ((status != kWarpStatusOK) && verbose)
+	{
+#ifdef WARP_BUILD_ENABLE_SEGGER_RTT_PRINTF
+		SEGGER_RTT_printf(0, "\r\tPowerdown command failed, code=%d, for TCS34725 @ 0x%02x.\n", status, deviceTCS34725State.i2cAddress);
+#endif
+	}
+	#else
+	SEGGER_RTT_WriteString(0, "\r\tPowerdown command abandoned. TCS34725 disabled\n");
+#endif
+
+
+
+
+	/*
+	 *	SI4705: Send a POWER_DOWN command (byte 0x17). See AN332 page 124 and page 132.
+	 *
+	 *	For now, simply hold its reset line low.
+	 */
+#ifdef WARP_BUILD_ENABLE_DEVSI4705
+	GPIO_DRV_ClearPinOutput(kWarpPinSI4705_nRST);
+#endif
+
+
+
+	/*
+	 *	PAN1326.
+	 *
+	 *	For now, simply hold its reset line low.
+	 */
+#ifndef WARP_BUILD_ENABLE_THERMALCHAMBERANALYSIS
+#ifdef WARP_BUILD_ENABLE_DEVPAN1326
+	GPIO_DRV_ClearPinOutput(kWarpPinPAN1326_nSHUTD);
+#endif
+#endif
+}
diff --git a/src/boot/ksdk1.1.0/warp.h b/src/boot/ksdk1.1.0/warp.h
index 0eb08df..da16b4e 100644
--- a/src/boot/ksdk1.1.0/warp.h
+++ b/src/boot/ksdk1.1.0/warp.h
@@ -1,8 +1,5 @@
 #include "fsl_spi_master_driver.h"
 
-#define DEBUG 0
-#define DEBUG_LOOP 0
-
 #define	min(x,y)	((x) < (y) ? (x) : (y))
 #define	max(x,y)	((x) > (y) ? (x) : (y))
 #define	USED(x)		(void)(x)
@@ -69,16 +66,205 @@ typedef enum
 	kWarpPowerModeRUN,
 } WarpPowerMode;
 
+typedef enum
+{
+	kWarpSensorADXL362,
+	kWarpSensorMMA8451Q,
+	kWarpSensorBME680,
+	kWarpSensorBMX055accel,
+	kWarpSensorBMX055gyro,
+	kWarpSensorBMX055mag,
+	kWarpSensorTMP006B,
+	kWarpSensorMAG3110,
+	kWarpSensorL3GD20H,
+	kWarpSensorLPS25H,
+	kWarpSensorTCS34725,
+	kWarpSensorSI4705,
+	kWarpSensorHDC1000,
+	kWarpSensorSI7021,
+	kWarpSensorAMG8834,
+	kWarpSensorCCS811,
+	kWarpSensorPAN1326,
+	kWarpSensorAS7262,
+	kWarpSensorAS7263,
+	kWarpSensorSCD30,
+} WarpSensorDevice;
+
 typedef enum
 {
 	kWarpModeDisableAdcOnSleep		= (1 << 0),
 } WarpModeMask;
 
+typedef enum
+{
+	kWarpSensorConfigurationRegisterMMA8451QF_SETUP			= 0x09,
+	kWarpSensorConfigurationRegisterMMA8451QCTRL_REG1		= 0x2A,
+
+	kWarpSensorConfigurationRegisterMAG3110CTRL_REG1		= 0x10,
+	kWarpSensorConfigurationRegisterMAG3110CTRL_REG2		= 0x11,
+
+	kWarpSensorConfigurationRegisterHDC1000Configuration		= 0x02,
+
+	kWarpSensorConfigurationRegisterAMG8834PCTL			= 0x00,
+	kWarpSensorConfigurationRegisterAMG8834RST			= 0x01,
+	kWarpSensorConfigurationRegisterAMG8834FPSC			= 0x02,
+
+	kWarpSensorConfigurationRegisterCCS811MEAS_MODE			= 0x01,
+	kWarpSensorConfigurationRegisterCCS811APP_START			= 0xF4,
+
+	kWarpSensorConfigurationRegisterBMX055accelPMU_RANGE		= 0x0F,
+	kWarpSensorConfigurationRegisterBMX055accelPMU_BW		= 0x10,
+	kWarpSensorConfigurationRegisterBMX055accelPMU_LPW		= 0x11,
+	kWarpSensorConfigurationRegisterBMX055accelPMU_LOW_POWER	= 0x12,
+	kWarpSensorConfigurationRegisterBMX055accelACCD_HBW		= 0x13,
+	kWarpSensorConfigurationRegisterBMX055magPowerCtrl		= 0x4B,
+	kWarpSensorConfigurationRegisterBMX055magOpMode			= 0x4C,
+	kWarpSensorConfigurationRegisterBMX055gyroRANGE			= 0x0F,
+	kWarpSensorConfigurationRegisterBMX055gyroBW			= 0x10,
+	kWarpSensorConfigurationRegisterBMX055gyroLPM1			= 0x11,
+	kWarpSensorConfigurationRegisterBMX055gyroRATE_HBW		= 0x13,
+
+	kWarpSensorConfigurationRegisterL3GD20HCTRL1			= 0x20,
+	kWarpSensorConfigurationRegisterL3GD20HCTRL2			= 0x21,
+	kWarpSensorConfigurationRegisterL3GD20HCTRL5			= 0x24,
+
+	kWarpSensorConfigurationRegisterBME680Reset			= 0xE0,
+	kWarpSensorConfigurationRegisterBME680Config			= 0x75,
+	kWarpSensorConfigurationRegisterBME680Ctrl_Meas			= 0x74,
+	kWarpSensorConfigurationRegisterBME680Ctrl_Hum			= 0x72,
+	kWarpSensorConfigurationRegisterBME680Ctrl_Gas_1		= 0x71,
+	kWarpSensorConfigurationRegisterBME680Ctrl_Gas_0		= 0x70,
+
+	kWarpSensorConfigurationRegisterBME680CalibrationRegion1Start	= 0x89,
+	kWarpSensorConfigurationRegisterBME680CalibrationRegion1End	= 0xA2,
+	kWarpSensorConfigurationRegisterBME680CalibrationRegion2Start	= 0xE1,
+	kWarpSensorConfigurationRegisterBME680CalibrationRegion2End	= 0xF2,
+
+	/*
+	 *	See Table 4 of the ISL23415 manual. We choose to use the encoding
+	 *	where we always set R4:R0 to 0000
+	 */
+	kWarpSensorConfigurationRegisterISL23415nopInstruction		= 0x00,
+	kWarpSensorConfigurationRegisterISL23415ACRreadInstruction	= 0x20,
+	kWarpSensorConfigurationRegisterISL23415ACRwriteInstruction	= 0x60,
+	kWarpSensorConfigurationRegisterISL23415WRreadInstruction	= 0x80,
+	kWarpSensorConfigurationRegisterISL23415WRwriteInstruction	= 0xC0,
+
+	kWarpSensorConfigurationRegisterADXL362DEVID_AD			= 0x00,
+	kWarpSensorConfigurationRegisterADXL362DEVID_MST		= 0x01,
+	kWarpSensorConfigurationRegisterADXL362RESET			= 0x1F,
+} WarpSensorConfigurationRegister;
+
+typedef enum
+{
+	kWarpSensorOutputRegisterMMA8451QOUT_X_MSB			= 0x01,
+	kWarpSensorOutputRegisterMMA8451QOUT_X_LSB			= 0x02,
+	kWarpSensorOutputRegisterMMA8451QOUT_Y_MSB			= 0x03,
+	kWarpSensorOutputRegisterMMA8451QOUT_Y_LSB			= 0x04,
+	kWarpSensorOutputRegisterMMA8451QOUT_Z_MSB			= 0x05,
+	kWarpSensorOutputRegisterMMA8451QOUT_Z_LSB			= 0x06,
+
+	kWarpSensorOutputRegisterMAG3110OUT_X_MSB			= 0x01,
+	kWarpSensorOutputRegisterMAG3110OUT_X_LSB			= 0x02,
+	kWarpSensorOutputRegisterMAG3110OUT_Y_MSB			= 0x03,
+	kWarpSensorOutputRegisterMAG3110OUT_Y_LSB			= 0x04,
+	kWarpSensorOutputRegisterMAG3110OUT_Z_MSB			= 0x05,
+	kWarpSensorOutputRegisterMAG3110OUT_Z_LSB			= 0x06,
+	kWarpSensorOutputRegisterMAG3110DIE_TEMP			= 0x0F,
+
+	kWarpSensorOutputRegisterHDC1000Temperature			= 0x00,
+	kWarpSensorOutputRegisterHDC1000Humidity			= 0x01,
+
+	kWarpSensorOutputRegisterAMG8834TTHL				= 0x0E,
+	kWarpSensorOutputRegisterAMG8834TTHH				= 0x0F,
+	kWarpSensorOutputRegisterAMG8834T01L				= 0x80,
+	kWarpSensorOutputRegisterAMG8834T64H				= 0xFF,
+
+	kWarpSensorOutputRegisterCCS811ALG_DATA				= 0x02,
+	kWarpSensorOutputRegisterCCS811RAW_DATA				= 0x03,
+	kWarpSensorOutputRegisterCCS811RAW_REF_NTC			= 0x06,
+
+	kWarpSensorOutputRegisterBMX055accelACCD_X_LSB			= 0x02,
+	kWarpSensorOutputRegisterBMX055accelACCD_X_MSB			= 0x03,
+	kWarpSensorOutputRegisterBMX055accelACCD_Y_LSB			= 0x04,
+	kWarpSensorOutputRegisterBMX055accelACCD_Y_MSB			= 0x05,
+	kWarpSensorOutputRegisterBMX055accelACCD_Z_LSB			= 0x06,
+	kWarpSensorOutputRegisterBMX055accelACCD_Z_MSB			= 0x07,
+	kWarpSensorOutputRegisterBMX055accelACCD_TEMP			= 0x08,
+	kWarpSensorOutputRegisterBMX055gyroRATE_X_LSB			= 0x02,
+	kWarpSensorOutputRegisterBMX055gyroRATE_X_MSB			= 0x03,
+	kWarpSensorOutputRegisterBMX055gyroRATE_Y_LSB			= 0x04,
+	kWarpSensorOutputRegisterBMX055gyroRATE_Y_MSB			= 0x05,
+	kWarpSensorOutputRegisterBMX055gyroRATE_Z_LSB			= 0x06,
+	kWarpSensorOutputRegisterBMX055gyroRATE_Z_MSB			= 0x07,
+	kWarpSensorOutputRegisterBMX055magX_LSB				= 0x42,
+	kWarpSensorOutputRegisterBMX055magX_MSB				= 0x43,
+	kWarpSensorOutputRegisterBMX055magY_LSB				= 0x44,
+	kWarpSensorOutputRegisterBMX055magY_MSB				= 0x45,
+	kWarpSensorOutputRegisterBMX055magZ_LSB				= 0x46,
+	kWarpSensorOutputRegisterBMX055magZ_MSB				= 0x47,
+	kWarpSensorOutputRegisterBMX055magRHALL_LSB			= 0x48,
+	kWarpSensorOutputRegisterBMX055magRHALL_MSB			= 0x49,
+
+	kWarpSensorOutputRegisterL3GD20HOUT_TEMP			= 0x26,
+	kWarpSensorOutputRegisterL3GD20HOUT_X_L				= 0x28,
+	kWarpSensorOutputRegisterL3GD20HOUT_X_H				= 0x29,
+	kWarpSensorOutputRegisterL3GD20HOUT_Y_L				= 0x2A,
+	kWarpSensorOutputRegisterL3GD20HOUT_Y_H				= 0x2B,
+	kWarpSensorOutputRegisterL3GD20HOUT_Z_L				= 0x2C,
+	kWarpSensorOutputRegisterL3GD20HOUT_Z_H				= 0x2D,
+
+	kWarpSensorOutputRegisterBME680press_msb			= 0x1F,
+	kWarpSensorOutputRegisterBME680press_lsb			= 0x20,
+	kWarpSensorOutputRegisterBME680press_xlsb			= 0x21,
+	kWarpSensorOutputRegisterBME680temp_msb				= 0x22,
+	kWarpSensorOutputRegisterBME680temp_lsb				= 0x23,
+	kWarpSensorOutputRegisterBME680temp_xlsb			= 0x24,
+	kWarpSensorOutputRegisterBME680hum_msb				= 0x25,
+	kWarpSensorOutputRegisterBME680hum_lsb				= 0x26,
+
+	kWarpSensorOutputRegisterADXL362XDATA_L				= 0x0E,
+	kWarpSensorOutputRegisterADXL362XDATA_H				= 0x0F,
+	kWarpSensorOutputRegisterADXL362YDATA_L				= 0x10,
+	kWarpSensorOutputRegisterADXL362YDATA_H				= 0x11,
+	kWarpSensorOutputRegisterADXL362ZDATA_L				= 0x12,
+	kWarpSensorOutputRegisterADXL362ZDATA_H				= 0x13,
+	kWarpSensorOutputRegisterADXL362TEMP_L				= 0x14,
+	kWarpSensorOutputRegisterADXL362TEMP_H				= 0x15,
+	kWarpSensorOutputRegisterADXL362STATUS				= 0x0B,
+	kWarpSensorOutputRegisterADXL362FIFO_ENTRIES_L			= 0x0C,
+	kWarpSensorOutputRegisterADXL362FIFO_ENTRIES_H			= 0x0D,
+	kWarpSensorOutputRegisterADXL362ACT_INACT_CTL			= 0x27,
+	kWarpSensorOutputRegisterADXL362FIFO_CONTROL			= 0x28,
+	kWarpSensorOutputRegisterADXL362FIFO_SAMPLES			= 0x29,
+	kWarpSensorOutputRegisterADXL362FILTER_CTL			= 0x2C,
+	kWarpSensorOutputRegisterADXL362POWER_CTL			= 0x2D,
+
+
+} WarpSensorOutputRegister;
+
+typedef enum
+{
+	kWarpSensorConfigConstADXL362registerWriteCommand		= 0x0A,
+	kWarpSensorConfigConstADXL362registerReadRegister		= 0x0B,
+	kWarpSensorConfigConstADXL362registerFIFORead			= 0x0D,
+	kWarpSensorConfigConstADXL362resetCode				= 0x52,
+} WarpSensorConfigConst;
+
 typedef enum
 {
 	kWarpMiscMarkerForAbsentByte					= 0xFF,
 } WarpMisc;
 
+typedef struct
+{
+	bool			isInitialized;
+
+	uint8_t			i2cAddress;
+	uint8_t			i2cBuffer[kWarpSizesI2cBufferBytes];
+	uint16_t		operatingVoltageMillivolts;
+} WarpI2CDeviceState;
+
 typedef struct
 {
 	bool			isInitialized;
@@ -108,11 +294,13 @@ typedef struct
 	uint8_t			errorCount;
 } WarpPowerManagerCallbackStructure;
 
+void		warpScaleSupplyVoltage(uint16_t voltageMillivolts);
+void		warpDisableSupplyVoltage(void);
 WarpStatus	warpSetLowPowerMode(WarpPowerMode powerMode, uint32_t sleepSeconds);
+void		warpEnableI2Cpins(void);
+void		warpDisableI2Cpins(void);
 void		warpEnableSPIpins(void);
+void		warpDisableSPIpins(void);
 void		warpDeasserAllSPIchipSelects(void);
-void 		warpStart(void);
-
-#if DEBUG
 void		warpPrint(const char *fmt, ...);
-#endif
+int		warpWaitKey(void);
diff --git a/tools/scripts/glaux.jlink.commands b/tools/scripts/glaux.jlink.commands
index 672a98b..944324e 100644
--- a/tools/scripts/glaux.jlink.commands
+++ b/tools/scripts/glaux.jlink.commands
@@ -1,6 +1,6 @@
 power on perm
 exec EnableRemarks
 unlock kinetis
-loadfile /home/students/fwa20/Warp-firmware/build/ksdk1.1/work/demos/Glaux/armgcc/Glaux/release/Glaux.srec
+loadfile <full-path-to-warp-firmware>/build/ksdk1.1/work/demos/Glaux/armgcc/Glaux/release/Glaux.srec
 r
 go
diff --git a/tools/scripts/warp.jlink.commands b/tools/scripts/warp.jlink.commands
index 7b0781c..da5814a 100644
--- a/tools/scripts/warp.jlink.commands
+++ b/tools/scripts/warp.jlink.commands
@@ -1,6 +1,6 @@
 power on perm
 exec EnableRemarks
 unlock kinetis
-loadfile /home/students/fwa20/Warp-firmware/build/ksdk1.1/work/demos/Warp/armgcc/Warp/release/Warp.srec
+loadfile <full-path-to-warp-firmware>/build/ksdk1.1/work/demos/Warp/armgcc/Warp/release/Warp.srec
 r
 go
diff --git a/tools/sdk/ksdk1.1.0/platform/drivers/inc/fsl_adc16_driver.h b/tools/sdk/ksdk1.1.0/platform/drivers/inc/fsl_adc16_driver.h
index 98e287b..c3b3fac 100755
--- a/tools/sdk/ksdk1.1.0/platform/drivers/inc/fsl_adc16_driver.h
+++ b/tools/sdk/ksdk1.1.0/platform/drivers/inc/fsl_adc16_driver.h
@@ -34,8 +34,6 @@
 #include <stdint.h>
 #include <stdbool.h>
 #include "fsl_adc16_hal.h"
-#include "/home/students/fwa20/Warp-firmware/tools/sdk/ksdk1.1.0/platform/CMSIS/Include/device/MKL03Z4/MKL03Z4_features.h"
-
 
 /*!
  * @addtogroup adc16_driver
diff --git a/tools/sdk/ksdk1.1.0/platform/hal/inc/fsl_adc16_hal.h b/tools/sdk/ksdk1.1.0/platform/hal/inc/fsl_adc16_hal.h
index 2a378a5..083bb55 100755
--- a/tools/sdk/ksdk1.1.0/platform/hal/inc/fsl_adc16_hal.h
+++ b/tools/sdk/ksdk1.1.0/platform/hal/inc/fsl_adc16_hal.h
@@ -35,8 +35,6 @@
 #include <stdbool.h>
 #include <assert.h>
 #include "fsl_device_registers.h"
-#include "/home/students/fwa20/Warp-firmware/tools/sdk/ksdk1.1.0/platform/CMSIS/Include/device/MKL03Z4/MKL03Z4_features.h"
-
 
 /*!
  * @addtogroup adc16_hal
